<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python之旅：从入门到无限可能</title>
      <link href="/posts/23012.html"/>
      <url>/posts/23012.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.python.org/static/community_logos/python-logo.png" alt="Python"></p><p>欢迎来到本博客，这篇文章将为你提供一个Python学习的路线图。Python是一门简单易学、功能强大的编程语言，广泛应用于数据分析、人工智能、Web开发等领域。无论你是初学者还是有一定编程经验的开发者，都可以通过以下学习路线逐步提升自己的Python技能。</p><h2 id="基础指南"><a href="#基础指南" class="headerlink" title="基础指南"></a>基础指南</h2><ul><li><a href="https://cheneyblog.com//posts/25565.html">Python编程规范</a></li><li><a href="https://cheneyblog.com//posts/10532.html">Python编程基础指南</a></li><li><a href="https://cheneyblog.com//posts/29896.html">数字操作全攻略</a></li><li><a href="https://cheneyblog.com//posts/3294.html">字符串操作大全</a></li><li><a href="https://cheneyblog.com//posts/34654.html">列表操作精髓</a></li><li><a href="https://cheneyblog.com//posts/57085.html">字典魔法之匣</a></li><li><a href="https://cheneyblog.com//posts/34883.html">特殊全局变量：解锁创新思维</a></li><li><a href="https://cheneyblog.com//posts/29232.html">特殊关键字编程：解锁Python高级功能</a></li></ul><h2 id="通用模块"><a href="#通用模块" class="headerlink" title="通用模块"></a>通用模块</h2><ul><li><a href="https://cheneyblog.com//posts/14008.html">random模块：生成随机数的利器</a></li><li><a href="https://cheneyblog.com//posts/22313.html">io：文件操作的瑞士军刀</a></li><li><a href="https://cheneyblog.com//posts/62812.html">os：探索文件和目录操作的利器</a></li><li><a href="https://cheneyblog.com//posts/55569.html">shutil：高效操控文件和目录的魔法工具</a></li><li><a href="https://cheneyblog.com//posts/4274.html">time：玩转时间魔法</a></li></ul><h2 id="爬虫相关"><a href="#爬虫相关" class="headerlink" title="爬虫相关"></a>爬虫相关</h2><h3 id="常用爬虫库"><a href="#常用爬虫库" class="headerlink" title="常用爬虫库"></a>常用爬虫库</h3><ul><li><a href="https://cheneyblog.com//posts/19502.html">Builtwith：快速识别网站所用技术栈</a></li><li><a href="https://cheneyblog.com//posts/50810.html">Certifi：保障Python与Https服务器间的安全连接</a></li><li><a href="https://cheneyblog.com//posts/63921.html">Python-whois:轻松获取网站的WHOIS信息</a></li><li><a href="https://cheneyblog.com//posts/42010.html">urllib3：使网络请求变得简单易懂</a></li><li><a href="https://cheneyblog.com//posts/33051.html">Requests：轻松战胜网络请求</a></li><li><a href="https://cheneyblog.com//posts/53007.html">re：天生适合匹配样式的神器</a></li><li><a href="https://cheneyblog.com//posts/49271.html">multiprocessing:探索多进程并行计算的魔力</a></li><li><a href="https://cheneyblog.com//posts/24310.html">threading：助你驰骋多线程</a></li><li><a href="https://cheneyblog.com//posts/54088.html">Asyncio：飞跃边界助你实现异步编程</a></li><li><a href="https://cheneyblog.com//posts/35834.html">BeautifulSoup：HTML元素操控术</a></li><li><a href="https://cheneyblog.com//posts/56711.html">PyQuery：轻松搞定网页解析和数据提取</a></li><li><a href="https://cheneyblog.com//posts/21220.html">Selenium：打造你的Web自动化之旅</a></li><li><a href="https://cheneyblog.com//posts/8408.html">PyMySQL：让Python和MySQL轻松对话！</a></li></ul><h3 id="效率提升"><a href="#效率提升" class="headerlink" title="效率提升"></a>效率提升</h3><ul><li><a href="https://cheneyblog.com//posts/53891.html">XPath表达式：精准定位文档节点</a></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python是一门强大而灵活的编程语言，具有广泛的应用领域和庞大的开发社区。通过按照上述学习路线逐步提升自己的Python技能，你将能够快速上手开发各种类型的应用程序，并为自己的职业发展打下坚实的基础。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构建现代Web应用的核心技术剖析</title>
      <link href="/posts/41485.html"/>
      <url>/posts/41485.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img2.baidu.com/it/u=616006340,2148180051&fm=253&fmt=auto&app=138&f=JPEG?w=650&h=282" alt="Web生态"></p><p>Web技术作为构建现代互联网世界的基石，不仅给人们带来了无限的便利，也推动了互联网的不断发展。本文将对几个关键的Web核心技术进行总结，帮助您更好地了解和应用这些技术，为Web应用的开发和优化提供指导。</p><ol><li><a href="https://cheneyblog.com//posts/11682.html">域名：互联网命名系统</a></li><li><a href="https://cheneyblog.com//posts/330.html">域名解析：连接互联网的关键枢纽</a></li><li><a href="https://cheneyblog.com//posts/44850.html">DNS：互联网底层通信的重要基石</a></li><li><a href="https://cheneyblog.com//posts/59495.html">DNS配置：将域名连接到IP地址的关键步骤</a></li><li><a href="https://cheneyblog.com//posts/26748.html">HTTP与HTTPS：保障Web通信安全的重要技术</a></li><li><a href="https://cheneyblog.com//posts/34621.html">SSL证书：构建安全可信的Web通信环境</a></li><li><a href="https://cheneyblog.com//posts/62378.html">协议：链接互联网世界的规则与约定</a></li><li><a href="https://cheneyblog.com//posts/10760.html">互联网通信的关键：TCP/IP协议族</a></li><li><a href="https://cheneyblog.com//posts/6511.html">网络带宽解析：速度的背后隐藏着什么？</a></li><li><a href="https://cheneyblog.com//posts/36427.html">IP地址：连接互联网的数字指纹</a></li><li><a href="https://cheneyblog.com//posts/60895.html">IPv4：互联网的”小四”们如何玩转世界</a></li><li><a href="https://cheneyblog.com//posts/31314.html">CDN：实现高速可靠的网络内容分发</a></li><li><a href="https://cheneyblog.com//posts/31314.html">Cookie与Session：互联网世界的甜点与记忆法</a></li><li><a href="https://cheneyblog.com//posts/25853.html">Web请求：展开数字世界的魔法之门</a></li><li><a href="https://cheneyblog.com//posts/4273.html">揭秘Web响应背后的神秘面纱</a></li><li><a href="https://cheneyblog.com//posts/9494.html">Token：数字世界的魔法密匙</a></li><li><a href="https://cheneyblog.com//posts/53891.html">XPath表达式：精准定位文档节点</a></li></ol><p>通过深入理解和熟练应用这些Web核心技术，开发者可以构建功能强大、性能卓越、用户友好的Web应用。同时，这些技术也提供了不断学习和创新的机会，让我们能够驾驭Web技术的潮流，不断迭代和改善我们的应用。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发学习指南：从入门到精通，掌握高效编程的利器！</title>
      <link href="/posts/16531.html"/>
      <url>/posts/16531.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/v2-bb9f2b9a205a4d3eb0c3acab830b7c46_b.png" alt="Java"></p><p>Java作为一门广泛应用的编程语言，其在企业级应用和软件开发领域拥有广泛的影响力。学习Java开发能够让你掌握高效编程的利器，并为你未来的职业发展提供坚实的基础。本文将持续为你提供一个全面的Java开发学习目录，帮助你系统地学习并掌握这一领域的知识和技能。</p><h2 id="开发基础"><a href="#开发基础" class="headerlink" title="开发基础"></a>开发基础</h2><ul><li><a href="https://cheneyblog.com//posts/42473.html">Java简介</a></li><li><a href="https://cheneyblog.com//posts/4785.html">Java开发你必须了解的专有名词</a></li><li><a href="https://cheneyblog.com//posts/55389.html">解锁Java开发之JDK</a></li><li><a href="https://cheneyblog.com//posts/29193.html">Java关键字：“Foundation of Power”（权力基石）</a></li><li><a href="https://cheneyblog.com//posts/41318.html">解析Java数据类型</a></li><li><a href="https://cheneyblog.com//posts/33481.html">Java基本数据类型揭秘</a></li><li><a href="https://cheneyblog.com//posts/13247.html">数据类型转换的奥秘及精度丢失背后的故事</a></li><li><a href="https://cheneyblog.com//posts/44856.html">格式化输出指南</a></li><li><a href="https://cheneyblog.com//posts/39770.html">探索Java引用数据类型</a></li><li><a href="https://cheneyblog.com//posts/36533.html">剖析Java变量</a></li><li><a href="https://cheneyblog.com//posts/37240.html">Java运算符：逻辑与算术的连接器</a></li><li><a href="https://cheneyblog.com//posts/42343.html">高效编程利器：Java流程控制</a></li><li><a href="https://cheneyblog.com//posts/37227.html">Java表达式：算与术的巧妙结合</a></li><li><a href="https://cheneyblog.com//posts/50102.html">Java数组：一种新的数据结构</a></li></ul><h2 id="开发进阶"><a href="#开发进阶" class="headerlink" title="开发进阶"></a>开发进阶</h2><ul><li><a href="https://cheneyblog.com//posts/14925.html">破解Java字符串秘密：String、StringBuilder和StringBuffer的区别与用途</a></li></ul><h2 id="类库详解"><a href="#类库详解" class="headerlink" title="类库详解"></a>类库详解</h2><ul><li><a href="https://cheneyblog.com//posts/25425.html">Math：数学魔法</a></li><li><a href="https://cheneyblog.com//posts/49312.html">String:不可或缺的字符型</a></li><li><a href="https://cheneyblog.com//posts/50488.html">StringBuffer：字符串的伙伴兼美容师</a></li><li><a href="https://cheneyblog.com//posts/63259.html">StringBuilder：释放字符串操作的终极力量</a></li><li><a href="https://cheneyblog.com//posts/53039.html">Scanner：与用户互动的秘密武器</a></li></ul><blockquote><p>持续更新中，敬请期待！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle开发学习指南：从入门到精通，打造高效数据库应用</title>
      <link href="/posts/50904.html"/>
      <url>/posts/50904.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://img0.baidu.com/it/u=447362092,1027630128&fm=253&fmt=auto&app=120&f=JPEG?w=1080&h=720" alt="Oracle"></p><p>当涉及到Oracle开发学习，有一些关键的指南可以帮助你更好地掌握这个数据库管理系统。在本文中，我将向大家分享一些有关Oracle开发学习的重要指南。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li><a href="https://cheneyblog.com//posts/565.html">物理结构</a></li><li><a href="https://cheneyblog.com//posts/14901.html">内存结构</a></li><li><a href="https://cheneyblog.com//posts/35730.html">进程结构</a></li><li><a href="https://cheneyblog.com//posts/24947.html">逻辑结构</a></li><li><a href="https://cheneyblog.com//posts/47150.html">体系结构总结</a></li><li><a href="https://cheneyblog.com//posts/39514.html">Library Cache 的基本结构</a></li><li><a href="https://cheneyblog.com//posts/27399.html">Library Cache 详解</a></li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="SQL原理"><a href="#SQL原理" class="headerlink" title="SQL原理"></a>SQL原理</h3><ul><li><a href="https://cheneyblog.com//posts/65435.html">SQL语句执行过程</a></li><li><a href="https://cheneyblog.com//posts/22532.html">Cursor（游标）</a></li><li><a href="https://cheneyblog.com//posts/55163.html">Session Cursor</a></li><li><a href="https://cheneyblog.com//posts/22265.html">硬解析、软解析和软软解析</a></li></ul><h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><ul><li><a href="https://cheneyblog.com//posts/59934.html">Listagg函数的交响乐</a></li></ul><h2 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><ul><li><a href="https://cheneyblog.com//posts/20895.html">执行计划简介</a></li><li><a href="https://cheneyblog.com//posts/26508.html">Oracle统计信息</a></li><li><a href="https://cheneyblog.com//posts/32449.html">统计信息管理工具：DBMS_STATS包</a></li><li><a href="https://cheneyblog.com//posts/54365.html">获取执行计划</a></li><li><a href="https://cheneyblog.com//posts/12101.html">看懂执行计划之执行顺序</a></li><li><a href="https://cheneyblog.com//posts/65395.html">看懂执行计划之基于规则的优化器（RBO）</a></li><li><a href="https://cheneyblog.com//posts/61.html">看懂执行计划之基于成本的优化器（CBO）</a></li><li><a href="https://cheneyblog.com//posts/49498.html">看懂执行计划之优化器的模式</a></li><li><a href="https://cheneyblog.com//posts/46535.html">看懂执行计划之表相关执行计划</a></li><li><a href="https://cheneyblog.com//posts/9739.html">看懂执行计划之索引介绍</a></li><li><a href="https://cheneyblog.com//posts/26997.html">看懂执行计划之B-tree索引</a></li><li><a href="https://cheneyblog.com//posts/35895.html">看懂执行计划之位图索引</a></li><li><a href="https://cheneyblog.com//posts/10468.html">看懂执行计划之表连接</a></li><li><a href="https://cheneyblog.com//posts/44822.html">看懂执行计划之其他执行计划</a></li><li><a href="https://cheneyblog.com//posts/1085.html">看懂执行计划之稳定执行计划</a></li><li><a href="https://cheneyblog.com//posts/24522.html">加速查询优化——深入了解Oracle Hint</a></li><li><a href="https://cheneyblog.com//posts/20503.html">如何根据执行计划识别低效SQL</a></li></ul><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><ul><li><a href="https://cheneyblog.com//posts/30060.html">简介</a></li><li><a href="https://cheneyblog.com//posts/10092.html">绑定变量PL/SQL中的应用</a></li><li><a href="https://cheneyblog.com//posts/6732.html">绑定变量窥探</a></li><li><a href="https://cheneyblog.com//posts/54542.html">常量游标共享</a></li><li><a href="https://cheneyblog.com//posts/39784.html">自适应游标共享</a></li><li><a href="https://cheneyblog.com//posts/17267.html">自适应游标共享流程实践</a></li></ul><h3 id="查询转换"><a href="#查询转换" class="headerlink" title="查询转换"></a>查询转换</h3><ul><li><a href="https://cheneyblog.com//posts/15852.html">深入解析Oracle优化器中的查询转换操作</a></li><li><a href="https://cheneyblog.com//posts/51875.html">子查询展开：揭秘Oracle的“嵌套奇迹”</a></li></ul><p>通过以上的指南，你可以更好地学习和掌握Oracle开发技能。无论是作为初学者还是有一定经验的开发者，这些指南都能够为你提供有价值的指导和帮助。祝你在Oracle开发学习的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探秘Conda、MiniConda与Anaconda</title>
      <link href="/posts/41556.html"/>
      <url>/posts/41556.html</url>
      
        <content type="html"><![CDATA[<p>在当今科技发展的时代，对于数据科学家而言，正确选择适合的工具和环境是至关重要的。而在Python生态系统中，Conda、MiniConda和Anaconda是备受推崇和广泛使用的工具。让我们一起来揭开它们之间的联系吧！</p><h2 id="🌱-1-MiniConda：精简而强大"><a href="#🌱-1-MiniConda：精简而强大" class="headerlink" title="🌱 1. MiniConda：精简而强大"></a>🌱 1. MiniConda：精简而强大</h2><p>MiniConda是一种基于Conda的最小化安装方式。MiniConda只包含了Python解释器和Conda包管理器，它的优势在于大小轻巧且易于安装。你可以根据自己的需求，灵活地手动添加所需要的软件包，而不会被预先安装的包所束缚。</p><p>MiniConda的安装速度非常快，同时还能节省系统的存储空间。这使得MiniConda成为数据科学家喜爱的选择，尤其适用于轻量级项目或低资源的环境。</p><p>提醒大家，使用MiniConda时，需要自行安装其他常用的数据科学包，如NumPy、Pandas等。但不用担心，Conda的强大包管理能力会帮你解决这一问题！</p><h2 id="🐍-2-Anaconda：全能者的首选"><a href="#🐍-2-Anaconda：全能者的首选" class="headerlink" title="🐍 2. Anaconda：全能者的首选"></a>🐍 2. Anaconda：全能者的首选</h2><p>相比MiniConda，Anaconda则是一种更全面的Python数据科学解决方案。Anaconda安装包括了大量常用的数据科学包和工具，并且直接支持主流操作系统。这包括了Python解释器、Conda包管理器以及Jupyter Notebook等强大的工具。</p><p>Anaconda一站式的解决方案，使得初学者和专业人士都能方便地开始他们的数据科学之旅。而且，Anaconda支持创建独立的虚拟环境，从而确保项目之间的隔离和安全性。</p><p>作为离线环境下的完整Python生态系统，Anaconda在数据分析、机器学习和科学计算等领域发挥着重要的作用。无论是进行实验还是开发生产环境，Anaconda的强大功能绝对不容忽视！</p><h2 id="🌟-3-Conda：包管理的佼佼者"><a href="#🌟-3-Conda：包管理的佼佼者" class="headerlink" title="🌟 3. Conda：包管理的佼佼者"></a>🌟 3. Conda：包管理的佼佼者</h2><p>Conda是一个功能强大的包管理器，它可以用于管理Python以及其他多种语言的软件包和环境。Conda具有两个重要的特点：包管理和环境管理。</p><p>包管理方面，Conda可以帮助我们快速安装、更新和删除各种软件包。它可以处理不同平台和操作系统之间的依赖关系，使得软件包的安装变得简单而方便。</p><p>环境管理方面，Conda可以创建和管理多个独立的环境。这意味着你可以为不同的项目创建独立的Python环境，并在这些环境中安装特定版本的软件包。这种灵活的环境管理方式，可以帮助我们有效地组织和控制项目的依赖关系。</p><p>Conda的强大功能让它成为数据科学家、开发人员和研究人员的理想选择。无论是创建虚拟环境、管理软件包，还是跨平台协作，Conda都将为你提供最佳的解决方案。</p><blockquote><p>总结起来，我们可以将它们看作是一个集体：Conda作为包管理兼环境管理的基础，MiniConda是精简版的Conda，而Anaconda则是搭载了常用数据科学包的完整解决方案。根据你的需求和项目规模，选择适合自己的那个吧！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda操作手册</title>
      <link href="/posts/7349.html"/>
      <url>/posts/7349.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装-Conda"><a href="#安装-Conda" class="headerlink" title="安装 Conda"></a>安装 Conda</h2><p>要开始使用 Conda，首先需要安装它。安装 Conda 很简单，只需执行以下步骤：</p><ol><li>打开终端或命令提示符。</li><li>访问 Anaconda 官方网站<a href="https://www.anaconda.com/products/individual">https://www.anaconda.com/products/individual</a> 并下载适合您操作系统的最新版本的Anaconda。</li><li>根据您的操作系统，选择适当的安装程序并下载。</li><li>双击下载的安装程序，按照提示进行安装。注意，如果系统提示您是否要将 Conda 添加到系统的 PATH 环境变量中，请务必选择此选项。</li></ol><p>安装完成后，可以通过在终端或命令提示符中运行 <code>conda --version</code> 命令来验证安装是否成功。</p><h2 id="创建和管理环境"><a href="#创建和管理环境" class="headerlink" title="创建和管理环境"></a>创建和管理环境</h2><p>在 Conda 中，可以创建多个独立的环境，每个环境可以有不同的软件包和版本。这是非常有用的，因为不同的项目有不同的依赖关系。以下是一些常用的环境管理命令。</p><ul><li>创建一个新环境：<code>conda create --name 环境名称</code></li><li>激活一个环境：<code>conda activate 环境名称</code></li><li>停用当前环境：<code>conda deactivate</code></li><li>列出所有已创建的环境：<code>conda env list</code></li><li>删除一个环境：<code>conda env remove --name 环境名称</code></li></ul><p>可以使用 <code>conda --help</code> 命令查看更多环境管理命令的详细信息。</p><h2 id="安装和管理软件包"><a href="#安装和管理软件包" class="headerlink" title="安装和管理软件包"></a>安装和管理软件包</h2><p>Conda 使得安装和管理软件包变得非常简单。以下是一些常用的软件包管理命令。</p><ul><li>安装一个软件包：<code>conda install 软件包名称</code></li><li>安装特定版本的软件包：<code>conda install 软件包名称=版本</code></li><li>更新一个软件包：<code>conda update 软件包名称</code></li><li>移除一个软件包：<code>conda remove 软件包名称</code></li><li>搜索可用的软件包：<code>conda search 关键词</code></li></ul><p>可以使用 <code>conda --help</code> 命令查看更多软件包管理命令的详细信息。</p><h2 id="导出和导入环境"><a href="#导出和导入环境" class="headerlink" title="导出和导入环境"></a>导出和导入环境</h2><p>Conda 允许导出和导入环境，这为团队合作和环境复制提供了便利。以下是一些常用的环境导出和导入命令。</p><ul><li>导出一个环境的配置：<code>conda env export &gt; 环境.yml</code></li><li>创建一个环境并基于导出的配置进行导入：<code>conda env create -f 环境.yml</code></li></ul><p>可以使用 <code>conda env --help</code> 命令查看更多环境导入和导出命令的详细信息。</p><blockquote><p>注意：本手册仅提供了最基本的 Conda 操作指南。要深入了解 Conda 的更多功能和选项，请查阅官方文档或使用 <code>conda --help</code> 命令获取帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Conda：让你的项目管理起来更得心应手</title>
      <link href="/posts/21260.html"/>
      <url>/posts/21260.html</url>
      
        <content type="html"><![CDATA[<p>今天给大家介绍一个非常好用的工具——Conda，这是一款专为数据科学家和Python开发人员设计的软件包管理系统。它可以帮助我们更轻松地创建、组织和管理我们的Python项目。</p><h2 id="Conda是什么"><a href="#Conda是什么" class="headerlink" title="Conda是什么"></a>Conda是什么</h2><p>Conda 是一个开源的软件包管理系统和环境管理系统，可以安装和管理多个软件包和环境。它是 Python 语言的一个跨平台包和环境管理系统。不仅如此，Conda 还可以安装和管理非 Python 包。它使您能够轻松地安装各种不同版本的软件包、创建自己的环境并分享它们。无论你是在数据分析、机器学习还是科学计算，Conda 都是必备的利器！😊</p><h2 id="为什么要使用Conda"><a href="#为什么要使用Conda" class="headerlink" title="为什么要使用Conda"></a>为什么要使用Conda</h2><h3 id="环境管理的方便性-📦"><a href="#环境管理的方便性-📦" class="headerlink" title="环境管理的方便性 📦"></a>环境管理的方便性 📦</h3><p>一个常见的问题是，当我们开发多个项目或运行多个应用程序时，经常会遇到依赖关系冲突的问题。而Conda的环境管理功能能够轻松解决这个问题！通过Conda，我们可以创建独立的环境，每个环境都有自己的依赖包集合，从而避免潜在的冲突。这使得我们能够更加灵活地管理和切换不同的工作环境，极大地提高了开发的效率和稳定性。不再为依赖问题而烦恼，是不是很棒呢？✨</p><h3 id="跨平台性的无缝体验-🌎"><a href="#跨平台性的无缝体验-🌎" class="headerlink" title="跨平台性的无缝体验 🌎"></a>跨平台性的无缝体验 🌎</h3><p>Conda是一个跨平台的软件包管理器，支持 Windows、MacOS 和 Linux 等操作系统。这意味着无论你使用哪种操作系统，Conda都能保证你在不同环境下获得一致的使用体验。而且，Conda的安装非常简单，只需几个简单的命令或几次点击，你就能在你的计算机上愉快地使用Conda了！不再为不同操作系统的兼容性问题而烦恼，是不是很酷呢？🌐</p><h3 id="丰富的软件包生态系统-📚"><a href="#丰富的软件包生态系统-📚" class="headerlink" title="丰富的软件包生态系统 📚"></a>丰富的软件包生态系统 📚</h3><p>Conda提供了一个庞大而丰富的软件包生态系统，其中包括各类开发工具、数据分析工具、机器学习库等等。无论你需要哪种工具或库，Conda都能为你提供多种选择。通过Conda，你可以轻松安装、更新和管理这些软件包，而不需要手动配置复杂的依赖关系。这个强大的生态系统为我们提供了丰富的资源和便利，让我们能够更加专注于我们的工作和学习。开发者的福音，是不是很棒呢？📚</p><h2 id="如何开始使用Conda"><a href="#如何开始使用Conda" class="headerlink" title="如何开始使用Conda"></a>如何开始使用Conda</h2><p>要开始使用Conda，你可以首先安装 Anaconda 或 Miniconda，它们是预装了 Conda 的科学计算和数据分析的发行版。安装好后，你可以轻松地通过命令行来创建、管理、激活和切换环境，安装和更新软件包等等。对于编程初学者和专业开发者来说，Conda都是一个非常友好而又强大的工具。在使用过程中，你会发现它能够带来极大的便利和效率提升。快来尝试一下吧！🚀</p>]]></content>
      
      
      <categories>
          
          <category> Conda </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java格式化输出指南</title>
      <link href="/posts/44856.html"/>
      <url>/posts/44856.html</url>
      
        <content type="html"><![CDATA[<p>Java中的格式化输出主要用于将数据以特定的格式输出到控制台或文件中。这种输出方式可以让输出的数据更易于阅读和理解，并且可以按照规定的格式进行对齐和排列。</p><p>使用格式化输出可以控制输出的字符串的长度、精度、对齐方式等，可以输出带有特定格式的日期、时间和数字。这对于生成报表、日志、表格等结构化的输出非常有用，也能提供更好的用户体验。</p><h2 id="String-format-方法"><a href="#String-format-方法" class="headerlink" title="String.format 方法"></a>String.format 方法</h2><p><code>String.format</code> 方法可以用于创建格式化的字符串，它的用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(format, args);</span><br></pre></td></tr></table></figure><p>其中，<code>format</code> 是格式化字符串，用于指定输出的格式；<code>args</code> 是要插入到格式化字符串中的参数。格式化字符串可以包含转换说明符（conversion specifiers）、标志（flags）、宽度（width）、精度（precision）等，用于指定输出的格式。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s! Today is %tF&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">System.out.println(formattedString);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>%s</code> 用于替换字符串，<code>%tF</code> 用于替换日期，<code>%tF</code> 是日期格式化的一种方式。</p><h2 id="System-out-printf-方法"><a href="#System-out-printf-方法" class="headerlink" title="System.out.printf 方法"></a>System.out.printf 方法</h2><p><code>System.out.printf</code> 方法可以用于格式化输出到标准输出流，它的用法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.printf(format, args);</span><br></pre></td></tr></table></figure><p>与 <code>String.format</code> 方法类似，<code>format</code> 是格式化字符串，<code>args</code> 是要插入到格式化字符串中的参数。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, name, age);</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>%s</code> 用于替换字符串，<code>%d</code> 用于替换整数。</p><h2 id="转换符"><a href="#转换符" class="headerlink" title="转换符"></a>转换符</h2><table><thead><tr><th>转换符</th><th>描述</th></tr></thead><tbody><tr><td>%d</td><td>整数型</td></tr><tr><td>%f</td><td>浮点型</td></tr><tr><td>%c</td><td>字符型</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%b</td><td>布尔型</td></tr><tr><td>%x</td><td>十六进制</td></tr><tr><td>%o</td><td>八进制</td></tr><tr><td>%e</td><td>科学计数法</td></tr><tr><td>%tA</td><td>完整星期名称</td></tr><tr><td>%ta</td><td>缩写星期名称</td></tr><tr><td>%tB</td><td>完整月份名称</td></tr><tr><td>%tb</td><td>缩写月份名称</td></tr><tr><td>%tY</td><td>4 位年份</td></tr><tr><td>%ty</td><td>2 位年份</td></tr><tr><td>%tm</td><td>2 位月份</td></tr><tr><td>%td</td><td>2 位日</td></tr><tr><td>%tH</td><td>24 小时格式的小时</td></tr><tr><td>%tI</td><td>12 小时格式的小时</td></tr><tr><td>%tM</td><td>2 位分钟</td></tr><tr><td>%tS</td><td>2 位秒数</td></tr><tr><td>%tp</td><td>上午或下午</td></tr></tbody></table><h2 id="标志符"><a href="#标志符" class="headerlink" title="标志符"></a>标志符</h2><table><thead><tr><th>标识符</th><th>说明</th></tr></thead><tbody><tr><td><code>-</code></td><td>结果将是左对齐的。默认情况下，结果将是右对齐的。</td></tr><tr><td><code>+</code></td><td>结果将包括一个加号（+）对于正数或一个减号（-）对于负数。默认情况下，只有负数前面才会添加减号。</td></tr><tr><td><code>0</code></td><td>结果将用零来填充，而不是空格。默认情况下，结果将使用空格来填充。</td></tr><tr><td><code>,</code></td><td>用作分组分隔符。例如，<code>12345</code> 可以用 <code>,</code> 标识符来格式化为 <code>12,345</code>。</td></tr><tr><td><code>(</code></td><td>结果将在负数前面加上括号。例如，<code>-10</code> 可以被格式化为 <code>(10)</code>。</td></tr><tr><td><code>#</code></td><td>根据不同的转换类型，对结果加上特定的标记。例如，在十六进制数中使用 <code>#</code> 可以表示加上 <code>0x</code> 前缀，对于浮点数则表示包括小数点。</td></tr><tr><td><code>&lt;空格&gt;</code></td><td>结果将包括一个前导的空格（对于正数），而不是加号。</td></tr></tbody></table><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化字符串输出</span></span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedString</span> <span class="operator">=</span> String.format(<span class="string">&quot;Hello, %s!&quot;</span>, name);</span><br><span class="line">System.out.println(formattedString); <span class="comment">// 输出：Hello, Alice!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化浮点数输出</span></span><br><span class="line"><span class="type">double</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">123.456</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedNumber</span> <span class="operator">=</span> String.format(<span class="string">&quot;The number is: %f&quot;</span>, number);</span><br><span class="line">System.out.println(formattedNumber); <span class="comment">// 输出：The number is: 123.456000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标志符进行浮点数格式化输出</span></span><br><span class="line"><span class="type">double</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="number">123.456</span>;</span><br><span class="line"><span class="comment">// 格式化输出一个浮点数，带正负号，总宽度为10如果不足则在左侧使用空格进行填充，保留小数点后两位。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedNumber1</span> <span class="operator">=</span> String.format(<span class="string">&quot;The number is: %+10.2f&quot;</span>, number1);</span><br><span class="line">System.out.println(formattedNumber1); <span class="comment">// 输出：The number is:    +123.46</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 格式化时间输出</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">formattedTime</span> <span class="operator">=</span> String.format(<span class="string">&quot;Current time: %tF %tT&quot;</span>, now, now);</span><br><span class="line">System.out.println(formattedTime); <span class="comment">// 输出：Current time: 2024-01-15 14:30:00</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标志符进行时间格式化输出</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="comment">// &lt;：表示在当前位置使用前面给出的参数列表中的参数，避免重复指定参数。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">formattedTime1</span> <span class="operator">=</span> String.format(<span class="string">&quot;Current time: %tA, %&lt;tB %&lt;td, %&lt;tY&quot;</span>, now1);</span><br><span class="line">System.out.println(formattedTime1); <span class="comment">// 输出：Current time: Sunday, January 15, 2024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标志符控制对齐方式和最小宽度</span></span><br><span class="line"><span class="type">int</span> <span class="variable">number1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">number2</span> <span class="operator">=</span> <span class="number">456</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;Left aligned: %-10d, Right aligned: %10d%n&quot;</span>, number1, number2);</span><br><span class="line"><span class="comment">// 输出：Left aligned: 123       , Right aligned:        456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标志符控制数值的显示格式</span></span><br><span class="line"><span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">12345.6789</span>;</span><br><span class="line">System.out.printf(<span class="string">&quot;Scientific notation: %e, Currency: %.2f%n&quot;</span>, value, value);</span><br><span class="line"><span class="comment">// 输出：Scientific notation: 1.234568e+04, Currency: 12345.68</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用标志符控制日期时间的显示格式</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">System.out.printf(<span class="string">&quot;24-hour time: %tT, 12-hour time: %tr%n&quot;</span>, now, now);</span><br><span class="line"><span class="comment">// 输出：24-hour time: 14:30:00, 12-hour time: 02:30:00 PM</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人工智能的蜕变：从人类智能到超级智能</title>
      <link href="/posts/14773.html"/>
      <url>/posts/14773.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.cdn.cheneyblog.com/blog/202401141830529.jpeg" alt="人工智能的发展历程"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>人工智能（Artificial Intelligence，简称AI）的发展自20世纪50年代以来一直在迅猛进展，它涉及了计算机科学、数学、神经科学、心理学等多个领域，致力于创造智能机器以模仿和执行人类智能任务。它的发展从符号推理时期到知识推理和专家系统时期，再到统计学习和机器学习时期，人工智能逐渐取得突破。最近几年，感知智能和强化学习成为关键技术，推动了图像识别、语音识别和游戏中的重要进展。人工智能的发展历程仍在继续，为实现更广泛的应用和更深层次的智能而努力。</p><h2 id="第一阶段：符号推理时期（1950年代-1960年代）"><a href="#第一阶段：符号推理时期（1950年代-1960年代）" class="headerlink" title="第一阶段：符号推理时期（1950年代-1960年代）"></a>第一阶段：符号推理时期（1950年代-1960年代）</h2><p>在这个时期人工智能的主要关注点是如何使用符号逻辑来进行推理和解决问题。这一时期的研究集中在符号处理系统和基于规则的推理技术上，其中代表性的工作包括逻辑推理和专家系统的初步尝试。</p><p>代表事件：</p><ul><li>1950年，图灵测试被提出，旨在评估机器是否具备人类智能。测试者通过与机器进行文字对话来判断其是否能够以与人类无法区分的方式进行交流。图灵测试推动了人工智能技术的发展，对于实现智能机器和人类的更紧密互动具有重要意义。</li><li>1956年，达特茅斯会议聚集了计算机科学家和认知心理学家，讨论了人工智能的概念和发展方向。会议是人工智能领域的开端，推动了学术界对人工智能的研究和发展。</li><li>1956年，逻辑理论家（Logic Theorist）发布。它是世界上第一个模拟人类思维的计算机程序，引领了人工智能的发展。它的出现促进了对人工智能的研究，为我们开辟了一条探索人类思维和解决问题的新途径。</li></ul><p>成就：</p><ul><li>人工智能的概念和领域在这个时期确立。</li><li>开发出了一些具备专家级能力的AI程序。</li></ul><p>问题：</p><ul><li>符号推理在复杂问题上遇到了局限性，无法处理模糊和不确定性的情况。</li></ul><h2 id="第二阶段：知识推理和专家系统时期（1970年代-1980年代）"><a href="#第二阶段：知识推理和专家系统时期（1970年代-1980年代）" class="headerlink" title="第二阶段：知识推理和专家系统时期（1970年代-1980年代）"></a>第二阶段：知识推理和专家系统时期（1970年代-1980年代）</h2><p>这个时期引入了知识表示和推理的概念，人们开始关注如何更好地利用领域专家的知识来解决复杂的问题。专家系统成为了当时的研究热点，这些系统可以模拟领域专家的思维过程，用于辅助决策和问题解决。</p><p>代表事件：</p><ul><li>1965年，DENDRAL诞生，这是一款革命性的人工智能系统。它能够通过分析和解释化学实验数据，自动推断有机化合物的结构。DENDRAL的诞生不仅在化学领域取得了重大突破，也开启了人工智能在科学研究中的应用。这一成果为人工智能技术的发展铺平了道路，为我们带来了更加高效和准确的研究方法。</li><li>1968年，麻省理工学院开发的计算机程序Shrdlu，能够理解和执行自然语言指令。这标志着人工智能在自然语言处理方面取得重要进展，为今后发展奠定了基础。</li><li>1980年，XCON系统开始应用于数字设备公司的配置过程，标志着专家系统开始实际应用。</li></ul><p>成就：</p><ul><li>开发出了一些基于规则的专家系统，如MYCIN（用于诊断感染疾病）和DENDRAL（用于化学分析）等。</li></ul><p>问题：</p><ul><li>专家系统在知识获取、推理效率和处理不确定性等方面存在局限。</li><li>面临知识库维护和知识表示的挑战。</li></ul><h2 id="第三阶段：统计学习和机器学习时期（1990年代-2000年代）"><a href="#第三阶段：统计学习和机器学习时期（1990年代-2000年代）" class="headerlink" title="第三阶段：统计学习和机器学习时期（1990年代-2000年代）"></a>第三阶段：统计学习和机器学习时期（1990年代-2000年代）</h2><p>在这一时期，人们开始关注如何利用数据和统计学习方法来构建智能系统。支持向量机、神经网络和随机森林等机器学习技术得到了广泛的应用，人工智能的研究重点开始从知识表示和推理转向了数据驱动的方法。</p><p>代表事件：</p><ul><li>1997年，IBM的深蓝计算机战胜国际象棋冠军卡斯帕罗夫，标志着人工智能在复杂智力游戏领域取得突破，引发了对人工智能在其他领域的更广泛应用的讨论。</li></ul><p>成就：</p><ul><li>机器学习算法的进步，如支持向量机(SVM)、隐马尔可夫模型(HMM)和神经网络等。</li><li>在自然语言处理、计算机视觉和语音识别等领域取得了突破。</li></ul><p>问题：</p><ul><li>数据依赖性较强，对大规模标注数据的需求较大。</li><li>深度学习模型参数调整与解释较为困难。</li></ul><h2 id="第四阶段：感知智能和强化学习时期（2010年代至今）"><a href="#第四阶段：感知智能和强化学习时期（2010年代至今）" class="headerlink" title="第四阶段：感知智能和强化学习时期（2010年代至今）"></a>第四阶段：感知智能和强化学习时期（2010年代至今）</h2><p>随着大数据和计算能力的快速发展，计算机视觉、自然语言处理、语音识别等感知智能领域取得了显著进展。同时，强化学习成为了研究的热点，人工智能系统可以通过与环境的交互学习并不断优化决策策略。</p><p>代表事件：</p><ul><li>2011年，IBM的超级电脑Watson在知名电视节目Jeopardy中战胜两位人类选手，成为全球瞩目的焦点。这一事件标志着人工智能技术的重大突破，为人类揭示了人工智能在解决复杂问题上的无限潜力，引发了全球对人工智能的关注与探索。</li><li>2015年，谷歌推出了深度学习框架TensorFlow。它是一个开源的机器学习框架，可以帮助开发者设计、构建和训练人工智能模型。TensorFlow的出现为人工智能的发展带来了巨大的推动力，让机器学习变得更加普及和可行，为实现智能化应用奠定了基础。</li><li>2016年，AlphaGo在围棋比赛中击败世界冠军李世石。这标志着人工智能在复杂游戏中取得突破，对人工智能发展意义重大，挑战人类思维极限，促进了AI技术和思维模式的深刻革新。</li></ul><p>成就：</p><ul><li>在图像识别和语音识别等感知任务上取得突破。</li><li>强化学习在游戏和机器人控制等领域取得重要进展。</li></ul><p>问题：</p><ul><li>深度学习模型依然面临黑盒化和解释不透明的问题。</li><li>面临数据隐私和伦理权衡的挑战。</li></ul>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Console：脱单入场的控制台王者</title>
      <link href="/posts/50470.html"/>
      <url>/posts/50470.html</url>
      
        <content type="html"><![CDATA[<h2 id="来历与发展历史"><a href="#来历与发展历史" class="headerlink" title="来历与发展历史"></a>来历与发展历史</h2><p>Console类是Java 1.6引入的，它为我们提供了一个简单而强大的工具，用于与控制台进行输入和输出交互。在这之前，我们使用System类的in和out对象来实现控制台输入输出。但Console类的出现，使得我们可以更方便地进行字符输入和密码掩码等操作。</p><h2 id="Console类的作用"><a href="#Console类的作用" class="headerlink" title="Console类的作用"></a>Console类的作用</h2><ol><li><p><strong>输入输出交互</strong>：它可以轻松处理控制台的输入输出，包括读取用户输入的字符、字符串，以及向控制台输出信息。这意味着我们可以通过Console类来创建出更加友好和互动性的命令行应用程序。</p></li><li><p><strong>密码掩码</strong>：Console类还提供了输入密码时的掩码功能。不再担心密码在控制台上明文显示了，Console类会自动将输入密码转换为特殊字符（如星号）来保护隐私。</p></li><li><p><strong>方法验证</strong>：它还提供了一些实用的方法，用于验证用户输入的数据是否符合指定的格式要求。比如，我们可以使用Console类的readPassword方法，并结合正则表达式来验证密码的复杂度。</p></li></ol><h2 id="常用方法举例解析"><a href="#常用方法举例解析" class="headerlink" title="常用方法举例解析"></a>常用方法举例解析</h2><ol><li><p><strong>readLine方法</strong>：这个方法用于从控制台读取一行用户输入，并以字符串的形式返回。比如，我们可以用它来实现一个简单的问答程序：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span> <span class="variable">console</span> <span class="operator">=</span> System.console();</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> console.readLine(<span class="string">&quot;请输入你的名字：&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;你好，&quot;</span> + name + <span class="string">&quot;！欢迎来到Java的世界！&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>readPassword方法</strong>：这个方法用于从控制台读取用户输入的密码，并以字符数组的形式返回。让我们来看一个登录验证的例子：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span> <span class="variable">console</span> <span class="operator">=</span> System.console();</span><br><span class="line"><span class="type">char</span>[] password = console.readPassword(<span class="string">&quot;请输入密码：&quot;</span>);</span><br><span class="line"><span class="comment">// 使用密码进行登录验证的逻辑</span></span><br></pre></td></tr></table></figure></li><li><p><strong>format方法</strong>：这个方法用于格式化输出信息到控制台。比如，我们可以使用format方法来实现一个简单的计算器程序：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Console</span> <span class="variable">console</span> <span class="operator">=</span> System.console();</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">console.format(<span class="string">&quot;两个数的和是：%d%n&quot;</span>, a + b);</span><br></pre></td></tr></table></figure></li></ol><h2 id="常见Error解析"><a href="#常见Error解析" class="headerlink" title="常见Error解析"></a>常见Error解析</h2><h2 id="NullPointerException"><a href="#NullPointerException" class="headerlink" title="NullPointerException"></a>NullPointerException</h2><h3 id="Error信息"><a href="#Error信息" class="headerlink" title="Error信息"></a>Error信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">&quot;main&quot;</span> java.lang.NullPointerException: Cannot invoke <span class="string">&quot;java.io.Console.readLine(String, Object[])&quot;</span> because <span class="string">&quot;console&quot;</span> is <span class="literal">null</span></span><br></pre></td></tr></table></figure><h3 id="Error解析"><a href="#Error解析" class="headerlink" title="Error解析"></a>Error解析</h3><p>System.console()在IDE环境中不可用。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>尝试从控制台（命令提示符/终端）运行它。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System：系统操作利器</title>
      <link href="/posts/8531.html"/>
      <url>/posts/8531.html</url>
      
        <content type="html"><![CDATA[<h2 id="来源与发展历史"><a href="#来源与发展历史" class="headerlink" title="来源与发展历史"></a>来源与发展历史</h2><p>System类是Java的内置类，它提供了与系统相关的操作功能。它的诞生源于Java设计者们对于系统操作的需求，希望能够在Java中提供一种便捷的方式来访问系统级资源。因此，他们创建了System类，并将其作为Java标准库的一部分。自从Java诞生以来，System类一直扮演着重要的角色，并不断演化和完善，为我们的Java世界带来了许多实用的特性。</p><h2 id="System类的作用"><a href="#System类的作用" class="headerlink" title="System类的作用"></a>System类的作用</h2><p>System类的作用几乎无所不能！它为我们提供了许多有用的功能，包括：</p><ol><li><strong>与环境变量有关的操作</strong>：System类可以帮助我们获取和设置系统的环境变量，例如<code>System.getenv(&quot;JAVA_HOME&quot;)</code>可以获取Java的安装路径。</li><li><strong>标准输入输出流</strong>：System类提供了<code>System.in</code>、<code>System.out</code>和<code>System.err</code>三个流对象，分别用于标准输入、标准输出和标准错误输出。通过它们，我们可以实现与用户的交互、输出信息和错误处理。</li><li><strong>获取当前时间</strong>：System类中的<code>System.currentTimeMillis()</code>方法可以获取当前时间的毫秒值，非常有用！</li><li><strong>垃圾回收</strong>：System类还提供了<code>System.gc()</code>方法，用于显式地调用垃圾回收器，帮助我们释放不再使用的内存资源。</li></ol><p>除了以上功能，System类还有许多其他实用的方法，比如：复制数组、获取系统属性、退出程序等等。</p><h2 id="常用方法的使用介绍和举例解析"><a href="#常用方法的使用介绍和举例解析" class="headerlink" title="常用方法的使用介绍和举例解析"></a>常用方法的使用介绍和举例解析</h2><h3 id="1-System-getenv"><a href="#1-System-getenv" class="headerlink" title="1. System.getenv()"></a>1. <code>System.getenv()</code></h3><p>这个方法可以帮助我们获取系统的环境变量。比如说，如果我们需要获取”JAVA_HOME”环境变量，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">javaHome</span> <span class="operator">=</span> System.getenv(<span class="string">&quot;JAVA_HOME&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Java安装路径：&quot;</span> + javaHome);</span><br></pre></td></tr></table></figure><h3 id="2-System-out-println"><a href="#2-System-out-println" class="headerlink" title="2. System.out.println()"></a>2. <code>System.out.println()</code></h3><p><code>System.out.println()</code>是我们常用的输出语句。它可以将指定的内容打印到控制台上，方便我们观察程序的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello, World!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="3-System-currentTimeMillis"><a href="#3-System-currentTimeMillis" class="headerlink" title="3. System.currentTimeMillis()"></a>3. <code>System.currentTimeMillis()</code></h3><p>这个方法返回当前时间的毫秒数，可以用于统计程序的执行时间，或者进行时间相关的计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算程序执行时间...</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">long</span> <span class="variable">executionTime</span> <span class="operator">=</span> endTime - startTime;</span><br><span class="line">System.out.println(<span class="string">&quot;程序执行时间：&quot;</span> + executionTime + <span class="string">&quot;毫秒&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="4-System-gc"><a href="#4-System-gc" class="headerlink" title="4. System.gc()"></a>4. <code>System.gc()</code></h3><p>这个方法用于显式地调用垃圾回收器，帮助我们释放不再使用的内存资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用垃圾回收器</span></span><br><span class="line">System.gc();</span><br></pre></td></tr></table></figure><h2 id="探索System世界的乐趣不止于此"><a href="#探索System世界的乐趣不止于此" class="headerlink" title="探索System世界的乐趣不止于此"></a>探索System世界的乐趣不止于此</h2><p>System类是Java中一个非常重要的类，也是我们开发中的得力助手。通过学习和掌握System类，你可以更加灵活地操作系统资源，提高程序的性能和稳定性。同时，以System类为起点，你可以进一步探索Java庞大的类库和丰富的开发工具。相信我，Java的世界远远不止于System类，还有无限的乐趣等待你去发现！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scanner：与用户互动的秘密武器</title>
      <link href="/posts/53039.html"/>
      <url>/posts/53039.html</url>
      
        <content type="html"><![CDATA[<h2 id="Scanner类的基本概述"><a href="#Scanner类的基本概述" class="headerlink" title="Scanner类的基本概述"></a>Scanner类的基本概述</h2><p>首先，让我们来了解一下Scanner类的基本概述。Scanner类位于java.util包中，通过创建Scanner对象，我们可以从不同的数据源读取输入，并将其解析为Java的基本数据类型或字符串。</p><h2 id="Scanner的创建与导入"><a href="#Scanner的创建与导入" class="headerlink" title="Scanner的创建与导入"></a>Scanner的创建与导入</h2><p>在开始之前，我们需要先导入Scanner类所在的包，使用以下语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br></pre></td></tr></table></figure><p>然后，我们可以通过以下代码创建Scanner对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br></pre></td></tr></table></figure><p>这里的<code>System.in</code>表示我们将从控制台获取输入。</p><h2 id="基本的输入操作"><a href="#基本的输入操作" class="headerlink" title="基本的输入操作"></a>基本的输入操作</h2><p>接下来，我们就可以开始进行一些基本的输入操作了。</p><h3 id="1-读取字符串"><a href="#1-读取字符串" class="headerlink" title="1. 读取字符串"></a>1. 读取字符串</h3><p>我们可以使用<code>next()</code>方法来读取控制台输入的字符串。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入您的姓名：&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> scanner.next();</span><br><span class="line">System.out.println(<span class="string">&quot;您好，&quot;</span> + name + <span class="string">&quot;！&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行以上代码，程序将会要求用户输入姓名，然后打印出”您好，XXX！”的欢迎消息。</p><h3 id="2-读取整数"><a href="#2-读取整数" class="headerlink" title="2. 读取整数"></a>2. 读取整数</h3><p>如果我们需要读取整数，可以使用<code>nextInt()</code>方法。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入您的年龄：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;您的年龄是：&quot;</span> + age + <span class="string">&quot;岁&quot;</span>);</span><br></pre></td></tr></table></figure><p>通过<code>nextInt()</code>方法，程序将会读取用户输入的整数，并打印出用户的年龄。</p><h2 id="Scanner类的高级应用"><a href="#Scanner类的高级应用" class="headerlink" title="Scanner类的高级应用"></a>Scanner类的高级应用</h2><p>除了基本的输入操作外，Scanner类还有一些高级的应用，可以更灵活地处理用户的输入。</p><h3 id="1-使用正则表达式验证输入格式"><a href="#1-使用正则表达式验证输入格式" class="headerlink" title="1. 使用正则表达式验证输入格式"></a>1. 使用正则表达式验证输入格式</h3><p>Scanner类提供了<code>hasNext(String pattern)</code>方法，可以用来判断输入是否符合指定的正则表达式。下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入一个整数：&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (!scanner.hasNextInt()) &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;输入有误，请重新输入：&quot;</span>);</span><br><span class="line">    scanner.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(<span class="string">&quot;您输入的数字是：&quot;</span> + number);</span><br></pre></td></tr></table></figure><p>当用户输入非整数时，程序会提示用户重新输入，直到用户输入了一个合法的整数。</p><h3 id="2-处理多个输入值"><a href="#2-处理多个输入值" class="headerlink" title="2. 处理多个输入值"></a>2. 处理多个输入值</h3><p>有时候，我们可能需要同时读取多个输入值。Scanner类提供了诸如<code>nextDouble()</code>、<code>nextBoolean()</code>等方法，可以方便地读取不同类型的输入值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入您的体重（kg）：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">weight</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line">System.out.print(<span class="string">&quot;请输入您的身高（m）：&quot;</span>);</span><br><span class="line"><span class="type">double</span> <span class="variable">height</span> <span class="operator">=</span> scanner.nextDouble();</span><br><span class="line"><span class="type">double</span> <span class="variable">bmi</span> <span class="operator">=</span> weight / (height * height);</span><br><span class="line">System.out.println(<span class="string">&quot;您的BMI指数为：&quot;</span> + bmi);</span><br></pre></td></tr></table></figure><p>在上述代码中，我们通过<code>nextDouble()</code>方法分别读取用户的体重和身高，并计算出对应的BMI指数。</p><h3 id="3-从文件中读取数据"><a href="#3-从文件中读取数据" class="headerlink" title="3. 从文件中读取数据"></a>3. 从文件中读取数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScannerTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\blog\\JavaTest\\Test\\src\\data.txt&quot;</span>);</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(file);</span><br><span class="line">            <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                System.out.println(line);</span><br><span class="line">            &#125;</span><br><span class="line">            scanner.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述代码中，我们首先创建了一个File对象，指定要读取数据的文件名为data.txt。然后，我们通过Scanner对象读取文件中的每一行数据，并将其输出到控制台上。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>破解Java字符串秘密：String、StringBuilder和StringBuffer的区别与用途</title>
      <link href="/posts/14925.html"/>
      <url>/posts/14925.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Java中的字符串操作类有String、StringBuilder和StringBuffer三种，大家都很熟悉，但你是否真正了解它们的区别和各自的优势呢？今天我就来揭开它们的神秘面纱，带你走进它们的世界。</p><h2 id="String：不变的经典之选"><a href="#String：不变的经典之选" class="headerlink" title="String：不变的经典之选"></a>String：不变的经典之选</h2><p>我们先来说说大家最熟悉的String类。String代表不可变的字符序列，一旦创建，就无法更改其中的内容。这也是为什么我们经常说String是”线程安全”的，因为你不必担心它会被改变。</p><p>由于String是不可变的，每次对String进行操作都会创建一个新的String对象。这会导致频繁的内存分配和回收，特别是在频繁拼接字符串的场景下，性能较差。所以在需要频繁操作字符串并且不需要线程安全的情况下，我们需要寻找更好的选择。</p><h2 id="StringBuilder：灵活且高效"><a href="#StringBuilder：灵活且高效" class="headerlink" title="StringBuilder：灵活且高效"></a>StringBuilder：灵活且高效</h2><p>接下来，让我们转向StringBuilder。StringBuilder同样代表可变的字符序列，但与String不同的是，它的内容可以被修改。这意味着我们可以在原来的字符串上直接添加、修改或删除字符，而无需创建新的对象。</p><p>由于StringBuilder的可变性，它在频繁拼接字符串的场景下表现优异。它通过预先分配一块较大的内存空间，避免了频繁的内存分配和回收，提高了性能。</p><p>然而需要注意的是，StringBuilder是非线程安全的。如果在多线程环境下使用StringBuilder，需要自行保证线程安全，比如使用同步块或锁。</p><h2 id="StringBuffer：线程安全的选择"><a href="#StringBuffer：线程安全的选择" class="headerlink" title="StringBuffer：线程安全的选择"></a>StringBuffer：线程安全的选择</h2><p>最后，让我们来看看StringBuffer。StringBuffer与StringBuilder非常类似，也是可变的字符序列。唯一的区别在于StringBuffer是线程安全的，内部的操作都是同步的。</p><p>由于同步的特性，StringBuffer在多线程环境中表现出色。虽然性能相对较差，因为每次操作都需要进行同步，但它能确保多个线程同时对字符串进行操作时不会出现不一致的情况。</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>综上所述，在选择使用String、StringBuilder还是StringBuffer时应根据具体的需求进行判断：</p><ul><li>如果你的字符串是固定不变的，比如表示常量或数据库记录等，使用String是最适合的选择。</li><li>如果你需要频繁地修改字符串，并且在单线程环境下操作，那么StringBuilder是最佳选择。</li><li>如果你需要频繁操作字符串，并且在多线程环境下操作，那么应该使用StringBuffer。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://www.cdn.cheneyblog.com//blog/202401121642095.png" alt="Java Strings"></p><p>String、StringBuilder和StringBuffer都有各自的优势和适用场景。了解它们的区别和特点，能够在实际开发中更好地选择合适的字符串操作类，提高代码的效率和性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuffer：字符串的伙伴兼美容师</title>
      <link href="/posts/50488.html"/>
      <url>/posts/50488.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是StringBuffer？"><a href="#什么是StringBuffer？" class="headerlink" title="什么是StringBuffer？"></a>什么是StringBuffer？</h2><p>在正式进入StringBuffer的世界之前，让我们来了解一下StringBuffer是什么。简而言之，StringBuffer是Java提供的一个用于操作字符串的类，它允许我们进行字符串的增删改查等操作，而且非常高效。</p><p>与Java中的String类相比，StringBuffer类有一个重要的特点——可变性。也就是说，使用StringBuffer类，我们可以在原有字符串的基础上进行修改，而不是每次都创建新的字符串对象。这在涉及频繁操作字符串的场景中非常实用。</p><h2 id="StringBuffer的基本使用方法"><a href="#StringBuffer的基本使用方法" class="headerlink" title="StringBuffer的基本使用方法"></a>StringBuffer的基本使用方法</h2><h3 id="创建StringBuffer对象"><a href="#创建StringBuffer对象" class="headerlink" title="创建StringBuffer对象"></a>创建StringBuffer对象</h3><p>要创建一个StringBuffer对象，我们可以使用以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(); <span class="comment">// 创建一个空的StringBuffer对象</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// 使用指定字符串初始化StringBuffer对象</span></span><br></pre></td></tr></table></figure><h3 id="字符串的拼接"><a href="#字符串的拼接" class="headerlink" title="字符串的拼接"></a>字符串的拼接</h3><p>StringBuffer提供了<code>append()</code>方法来进行字符串的拼接。下面是一个简单的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出：&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串的插入"><a href="#字符串的插入" class="headerlink" title="字符串的插入"></a>字符串的插入</h3><p>StringBuffer还提供了<code>insert()</code>方法来在指定位置插入字符串。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// 在第5个字符位置插入逗号</span></span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出：&quot;Hello, World&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串的删除"><a href="#字符串的删除" class="headerlink" title="字符串的删除"></a>字符串的删除</h3><p>当我们需要删除字符串中的某些部分时，可以使用StringBuffer的<code>delete()</code>方法。示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">sb.delete(<span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 删除从第5个字符到第7个字符之间的部分</span></span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出：&quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><h3 id="字符串的反转"><a href="#字符串的反转" class="headerlink" title="字符串的反转"></a>字符串的反转</h3><p>想要将字符串翻过来？没问题！StringBuffer的<code>reverse()</code>方法可以帮我们实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.reverse();</span><br><span class="line">System.out.println(sb.toString());  <span class="comment">// 输出：&quot;olleH&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>尽管在Java 5之后，StringBuffer的性能被String类的StringBuilder替代，但对于多线程场景下的并发处理，StringBuffer仍然是首选。所以，让我们充分利用这个字符串伙伴兼任美容师！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>StringBuilder：释放字符串操作的终极力量</title>
      <link href="/posts/63259.html"/>
      <url>/posts/63259.html</url>
      
        <content type="html"><![CDATA[<h2 id="释放字符串操作的终极力量：Java中的StringBuilder类"><a href="#释放字符串操作的终极力量：Java中的StringBuilder类" class="headerlink" title="释放字符串操作的终极力量：Java中的StringBuilder类"></a>释放字符串操作的终极力量：Java中的StringBuilder类</h2><p><img src="https://www.cdn.cheneyblog.com//blog/202401121545041.png" alt="Java StringBuilder"></p><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>作为Java开发人员，我们经常需要对字符串进行动态操作，传统的String类由于不可变性会导致频繁的字符串对象创建和销毁，这对内存和性能会带来一定的负担。而Java中的StringBuilder类则提供了一种可变的字符串操作方式，极大地提高了对字符串的处理效率。本文将详细介绍StringBuilder类的使用方法和示例，助你释放字符串操作的终极力量。</p><h3 id="StringBuilder类简介"><a href="#StringBuilder类简介" class="headerlink" title="StringBuilder类简介"></a>StringBuilder类简介</h3><p>StringBuilder类位于java.lang包中，是Java中用于动态字符串操作的重要工具。它基于可变字符数组实现，允许我们进行高效的字符串追加、删除、替换和插入等操作，而无需创建新的字符串对象。通过使用StringBuilder，我们能够避免频繁的字符串对象创建和内存开销，提高了代码的性能和效率。</p><h3 id="StringBuilder类的主要方法"><a href="#StringBuilder类的主要方法" class="headerlink" title="StringBuilder类的主要方法"></a>StringBuilder类的主要方法</h3><h4 id="StringBuilder构造方法"><a href="#StringBuilder构造方法" class="headerlink" title="StringBuilder构造方法"></a>StringBuilder构造方法</h4><ul><li><code>StringBuilder()</code>：创建一个空的StringBuilder对象。</li><li><code>StringBuilder(CharSequence seq)</code>：在构造StringBuilder对象时，将指定的CharSequence追加到末尾。</li></ul><h4 id="添加字符和字符串"><a href="#添加字符和字符串" class="headerlink" title="添加字符和字符串"></a>添加字符和字符串</h4><ul><li><code>append(boolean b)</code>：将boolean类型的值添加到当前StringBuilder对象的末尾。</li><li><code>append(char c)</code>：将char类型的字符添加到当前StringBuilder对象的末尾。</li><li><code>append(int i)</code>：将int类型的整数添加到当前StringBuilder对象的末尾。</li><li><code>append(double d)</code>：将double类型的浮点数添加到当前StringBuilder对象的末尾。</li><li><code>append(String str)</code>：将字符串str添加到当前StringBuilder对象的末尾。</li></ul><h4 id="删除字符和字符串"><a href="#删除字符和字符串" class="headerlink" title="删除字符和字符串"></a>删除字符和字符串</h4><ul><li><code>delete(int start, int end)</code>：删除从start到end-1索引范围内的字符。</li><li><code>deleteCharAt(int index)</code>：删除指定索引位置上的字符。</li></ul><h4 id="替换字符和字符串"><a href="#替换字符和字符串" class="headerlink" title="替换字符和字符串"></a>替换字符和字符串</h4><ul><li><code>replace(int start, int end, String str)</code>：用字符串str替换从start到end-1索引范围内的字符。</li></ul><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><ul><li><code>reverse()</code>：反转当前StringBuilder对象中的字符顺序。</li></ul><h4 id="插入字符和字符串"><a href="#插入字符和字符串" class="headerlink" title="插入字符和字符串"></a>插入字符和字符串</h4><ul><li><code>insert(int offset, boolean b)</code>：在指定偏移量offset处插入boolean类型的值。</li><li><code>insert(int offset, char c)</code>：在指定偏移量offset处插入char类型的字符。</li><li><code>insert(int offset, int i)</code>：在指定偏移量offset处插入int类型的整数。</li><li><code>insert(int offset, double d)</code>：在指定偏移量offset处插入double类型的浮点数。</li><li><code>insert(int offset, String str)</code>：在指定偏移量offset处插入字符串str。</li></ul><h3 id="StringBuilder的示例"><a href="#StringBuilder的示例" class="headerlink" title="StringBuilder的示例"></a>StringBuilder的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例1：使用append方法拼接字符串</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb.append(<span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">System.out.println(message); <span class="comment">// 输出：Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例2：使用insert方法在指定位置插入字符串</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">sb2.append(<span class="string">&quot;Java is &quot;</span>);</span><br><span class="line">sb2.append(<span class="string">&quot;awesome!&quot;</span>);</span><br><span class="line">sb2.insert(<span class="number">7</span>, <span class="string">&quot;really &quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">message2</span> <span class="operator">=</span> sb2.toString();</span><br><span class="line">System.out.println(message2); <span class="comment">// 输出：Java is really awesome!</span></span><br></pre></td></tr></table></figure><p>上述示例演示了使用StringBuilder类的append()方法进行字符串拼接，以及使用insert()方法在指定位置插入字符串。通过toString()方法，我们可以将StringBuilder对象转换为String对象，得到最终的字符串结果。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html">Java官方文档 - StringBuilder</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String:不可或缺的字符型</title>
      <link href="/posts/49312.html"/>
      <url>/posts/49312.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.cdn.cheneyblog.com//blog/202401111041908.png" alt="String"></p><h2 id="1-String类概述"><a href="#1-String类概述" class="headerlink" title="1. String类概述"></a>1. String类概述</h2><p>String类是Java编程中用于表示文本字符串的一种数据类型。它可以存储任意长度的文本，可用于表示URL、文件路径、XML、HTML等各种文本数据。</p><p>String类是一个<code>final</code>类，因此它的值一旦确定就无法修改。它实现了<code>Serializable</code>、<code>CharSequence</code>和<code>Comparable</code>接口。</p><h2 id="2-String类的创建"><a href="#2-String类的创建" class="headerlink" title="2. String类的创建"></a>2. String类的创建</h2><h3 id="2-1-直接赋值"><a href="#2-1-直接赋值" class="headerlink" title="2.1 直接赋值"></a>2.1 直接赋值</h3><p>字符串可以直接在双引号内赋值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="2-2-使用new关键字"><a href="#2-2-使用new关键字" class="headerlink" title="2.2 使用new关键字"></a>2.2 使用<code>new</code>关键字</h3><p>也可以使用<code>new</code>关键字来创建一个字符串。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello, world!&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="2-3-使用字符串连接符"><a href="#2-3-使用字符串连接符" class="headerlink" title="2.3 使用字符串连接符"></a>2.3 使用字符串连接符</h3><p>可以使用<code>+</code>号将多个字符串连接起来，形成一个新字符串。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;Hello, &quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;world!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> str3 + str4;</span><br></pre></td></tr></table></figure><h2 id="3-String类的方法"><a href="#3-String类的方法" class="headerlink" title="3. String类的方法"></a>3. String类的方法</h2><h3 id="大小写"><a href="#大小写" class="headerlink" title="大小写"></a>大小写</h3><p>在 Java 中，String 类默认是不可变的，也就是说它的值一旦创建就不能被修改。因此，String 类并没有提供直接修改大小写的方法。</p><p>然而，你可以使用以下方法来实现大小写转换：</p><ol><li><p>使用 <code>toLowerCase()</code> 方法将字符串转换为小写形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">lowercaseStr</span> <span class="operator">=</span> str.toLowerCase(); <span class="comment">// 将字符串转换为小写形式</span></span><br><span class="line">System.out.println(lowercaseStr); <span class="comment">// 输出：hello world</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>toUpperCase()</code> 方法将字符串转换为大写形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">uppercaseStr</span> <span class="operator">=</span> str.toUpperCase(); <span class="comment">// 将字符串转换为大写形式</span></span><br><span class="line">System.out.println(uppercaseStr); <span class="comment">// 输出：HELLO WORLD</span></span><br></pre></td></tr></table></figure></li></ol><p>请注意，这些方法会创建一个新的字符串对象，而不会修改原始的字符串。</p><p>如果你需要在程序中频繁修改字符串的大小写，可以考虑使用 StringBuilder 或 StringBuffer，它们提供了一些更高效的方法来修改字符串。</p><h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>在Java中，比较字符串有两种常用的方法：使用<code>equals()</code>方法和使用<code>compareTo()</code>方法。</p><ol><li><p>使用<code>equals()</code>方法进行字符串比较：</p><p><code>equals()</code>方法是String类提供的用于比较字符串内容的方法。它会比较两个字符串的每一个字符，并返回一个布尔值，表示两个字符串是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">equal</span> <span class="operator">=</span> str1.equals(str2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>str1</code>与<code>str2</code>的内容不相等，因此<code>equals()</code>方法返回<code>false</code>。</p><p>需要注意的是，<code>equals()</code>方法区分大小写。如果需要忽略大小写进行比较，可以使用<code>equalsIgnoreCase()</code>方法。</p></li><li><p>使用<code>compareTo()</code>方法进行字符串比较：</p><p><code>compareTo()</code>方法是String类提供的用于比较字符串大小关系的方法。它比较两个字符串的字典顺序，并返回一个整数值来表示比较结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> str1.compareTo(str2); <span class="comment">// -15</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>compareTo()</code>方法返回一个负整数，表示<code>str1</code>在字典顺序中排在<code>str2</code>之前。</p><p><code>compareTo()</code>方法返回值的含义如下：</p><ul><li>如果返回值为负数，表示调用者字符串小于传入的字符串。</li><li>如果返回值为零，表示两个字符串相等。</li><li>如果返回值为正数，表示调用者字符串大于传入的字符串。</li></ul><p>需要注意的是，<code>compareTo()</code>方法区分大小写。如果需要忽略大小写进行比较，可以使用<code>compareToIgnoreCase()</code>方法。</p></li></ol><h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><p>在Java的String类中，可以使用substring()方法来实现字符串的截取。该方法有两个重载形式：</p><ol><li>substring(int beginIndex)：从指定的索引位置开始截取字符串到结尾。</li><li>substring(int beginIndex, int endIndex)：从指定的索引位置开始截取字符串，直到指定的结束索引位置，但不包括结束位置的字符。</li></ol><p>下面是几个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">substring1</span> <span class="operator">=</span> str.substring(<span class="number">7</span>);            <span class="comment">// &quot;World!&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring2</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">5</span>);         <span class="comment">// &quot;Hello&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">substring3</span> <span class="operator">=</span> str.substring(<span class="number">7</span>, str.length()); <span class="comment">// &quot;World!&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，我们使用substring()方法截取了不同范围的字符串。</p><ul><li>在第一个示例中，从索引位置7开始截取到结尾，得到字符串”World!”。</li><li>在第二个示例中，从索引位置0开始截取到索引位置5（不包括索引位置5），得到字符串”Hello”。</li><li>在第三个示例中，从索引位置7开始截取到字符串的长度（结尾），得到字符串”World!”。</li></ul><p>需要注意的是，截取操作并不会改变原始字符串的值，而是返回一个新的字符串。</p><p>另外，如果传入的索引位置超出了字符串的范围，会抛出IndexOutOfBoundsException异常。因此，在使用substring()方法时，要确保传入的索引位置在有效的范围内。</p><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>在Java的String类中，可以使用”+”运算符或者concat()方法来实现字符串的拼接。</p><ol><li><p>使用”+”运算符进行字符串拼接：</p><p>可以使用”+”运算符将两个字符串进行拼接，并返回拼接后的新字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str1 + <span class="string">&quot; &quot;</span> + str2; <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，”+”运算符将str1、空格和str2进行拼接，得到新的字符串”Hello World”。</p></li><li><p>使用concat()方法进行字符串拼接：</p><p>String类还提供了concat()方法，可以将指定的字符串连接到调用者字符串的末尾，并返回拼接后的新字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;World&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str1.concat(<span class="string">&quot; &quot;</span>).concat(str2); <span class="comment">// &quot;Hello World&quot;</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，先使用concat()方法将空格拼接到str1的末尾，然后再将str2拼接到末尾，得到新的字符串”Hello World”。</p></li></ol><p>无论是使用”+”运算符还是concat()方法，拼接操作都不会改变原始字符串的值，而是返回一个新的拼接后的字符串。</p><p>需要注意的是，使用”+”运算符拼接字符串时，底层实际上是调用了StringBuilder类来进行拼接操作。因此，在进行大量拼接操作时，使用StringBuilder的append()方法可能更高效。</p><h3 id="获取字符数量"><a href="#获取字符数量" class="headerlink" title="获取字符数量"></a>获取字符数量</h3><p>在Java的String类中，要获取字符串的长度，可以使用length()方法。这个方法返回字符串的字符数量，也就是字符串的长度。</p><p>下面是一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length();</span><br><span class="line">System.out.println(length); <span class="comment">// 输出 13</span></span><br></pre></td></tr></table></figure><p>需要注意的是，长度指的是字符串中字符的数量，而不是内存空间的大小。这意味着即使字符串中有一些特殊字符或者Unicode字符，length()方法返回的结果也是它们在字符串中的实际数量，而不是它们在内存中占用的字节数。</p><h3 id="获取指定位置的字符"><a href="#获取指定位置的字符" class="headerlink" title="获取指定位置的字符"></a>获取指定位置的字符</h3><p>在Java的String类中，你可以使用charAt()方法来获取指定位置的字符。这个方法接受一个整数参数，代表了要获取的字符在字符串中的索引，然后返回该位置上的字符。</p><p>下面是一个用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>);</span><br><span class="line">System.out.println(ch); <span class="comment">// 输出 e</span></span><br></pre></td></tr></table></figure><p>需要注意的是，如果你传递给charAt()方法的索引超出了字符串的有效范围，将会抛出StringIndexOutOfBoundsException异常。因此，在使用charAt()方法时，需要谨慎确保索引的有效性。</p><h3 id="查找字符"><a href="#查找字符" class="headerlink" title="查找字符"></a>查找字符</h3><p>在Java的String类中，你可以使用indexOf()方法来查找指定字符在字符串中第一次出现的位置。该方法接受一个字符作为参数，并返回字符在字符串中的索引，如果没有找到指定的字符，则返回-1。</p><p>另外，Java的String类也提供了lastIndexOf()方法来查找指定字符在字符串中最后一次出现的位置。这个方法同样接受一个字符作为参数，并返回字符在字符串中最后一次出现的位置的索引，如果没有找到指定的字符，则返回-1。</p><p>下面是这两个方法的用法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">firstIndex</span> <span class="operator">=</span> str.indexOf(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">lastIndex</span> <span class="operator">=</span> str.lastIndexOf(<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line">System.out.println(firstIndex); <span class="comment">// 输出 4</span></span><br><span class="line">System.out.println(lastIndex); <span class="comment">// 输出 8</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用了indexOf()方法和lastIndexOf()方法分别查找了字符串”Hello, World!”中字符’o’第一次出现的位置和最后一次出现的位置，并将结果打印出来。</p><p>如果你想要查找字符在字符串中所有出现的位置，你可能需要使用循环结合indexOf()方法来实现。当然，Java的String类也提供了其他更复杂的查找方法，比如contains()方法用于检查是否包含某个字符，matches()方法用于正则表达式匹配等。</p><h3 id="替换字符"><a href="#替换字符" class="headerlink" title="替换字符"></a>替换字符</h3><p>在Java的String类中，你可以使用replace()方法来替换字符串中的字符或者子串。这个方法接受两个参数，第一个参数是需要被替换的字符或者子串，第二个参数是用来替换的新字符或者新子串。</p><p>下面是一个使用replace()方法的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.replace(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">System.out.println(newStr); <span class="comment">// 输出 Hellx, Wxrld!</span></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们使用了replace()方法将字符串”Hello, World!”中的字符’o’替换为’x’，然后将替换后的新字符串打印出来。</p><p>如果你想替换的是一个子串，也可以使用replace()方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">newStr</span> <span class="operator">=</span> str.replace(<span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>);</span><br><span class="line">System.out.println(newStr); <span class="comment">// 输出 Hello, Universe!</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用了replace()方法将字符串”Hello, World!”中的子串”World”替换为”Universe”，然后将替换后的新字符串打印出来。</p><p>需要注意的是，调用replace()方法并不会改变原始的字符串，它会返回一个新的字符串作为替换后的结果。</p><h3 id="代码单元、代码点"><a href="#代码单元、代码点" class="headerlink" title="代码单元、代码点"></a>代码单元、代码点</h3><p>在Java的String类中，字符串被存储为一个由Unicode字符序列组成的数组。在Java中，字符使用UTF-16编码，每个字符由一个或两个代码单元（code unit）表示。</p><ol><li><p>代码单元（Code unit）：代码单元是指UTF-16编码中的最小单位，每个代码单元占用16位（2个字节）的存储空间。对于大部分字符，一个代码单元就足够表示，但对于一些特殊字符（例如Emoji表情符号），需要使用两个代码单元来表示。在String类中，可以通过charAt()方法获取指定索引位置的代码单元。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">codeUnit</span> <span class="operator">=</span> str.charAt(<span class="number">1</span>); <span class="comment">// 获取索引为1的代码单元，结果为&#x27;e&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>代码点（Code point）：代码点是指Unicode代码空间中的一个位置，每个代码点对应一个字符。在Java中，可以使用codePointAt()方法获取指定索引位置的代码点。一个代码点可能由一个或多个代码单元组成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">codePoint</span> <span class="operator">=</span> str.codePointAt(<span class="number">1</span>); <span class="comment">// 获取索引为1的代码点，结果为127757，对应字符&#x27;🌍&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="“🌍Hello🌎”-解析"><a href="#“🌍Hello🌎”-解析" class="headerlink" title="“🌍Hello🌎” 解析"></a>“🌍Hello🌎” 解析</h4><ol><li><p>“🌍” (地球表情符号): 这个字符由一个代码点组成 (U+1F30D)，表示地球图标。</p><ul><li>Unicode 代码点: U+1F30D</li><li>UTF-16 编码: 0xD83C 0xDF0D</li></ul></li><li><p>“H” (英文字母 H): 这是一个普通的 ASCII 字符，由一个代码点组成 (U+0048)。</p></li><li><p>“e” (英文字母 e): 这也是一个普通的 ASCII 字符，由一个代码点组成 (U+0065)。</p></li><li><p>“l” (英文字母 l): 这也是一个普通的 ASCII 字符，由一个代码点组成 (U+006C)。</p></li><li><p>“l” (英文字母 l): 这也是一个普通的 ASCII 字符，由一个代码点组成 (U+006C)。</p></li><li><p>“o” (英文字母 o): 这也是一个普通的 ASCII 字符，由一个代码点组成 (U+006F)。</p></li><li><p>“🌎” (地球表情符号): 这个字符由一个代码点组成 (U+1F30E)，表示地球图标。</p><ul><li>Unicode 代码点: U+1F30E</li><li>UTF-16 编码: 0xD83C 0xDF0E</li></ul></li></ol><p>综上所述，字符串 “🌍Hello🌎” 包含了 7 个不同的代码点。需要注意的是，地球表情符号是由两个代码单元 (UTF-16 编码) 组成的，而其他的字符都是由一个代码单元表示的。此外，这个字符串中融合了不同语言的字符和表情符号，展示了 Unicode 字符编码的多样性。</p><h4 id="代码点方法解析"><a href="#代码点方法解析" class="headerlink" title="代码点方法解析"></a>代码点方法解析</h4><ol><li><p>codePointAt(int index):</p><ul><li><code>codePointAt</code> 方法返回给定索引位置的代码点（Unicode 字符）。</li><li>传入的索引值表示要访问的位置，可以是合法的索引范围内的任何位置。</li><li>注意，对于代理对（surrogate pair）这样的扩展字符，需要使用两个代码单元（高低代理对）来表示一个代码点。</li><li>如果索引越界或不合法，此方法将引发 <code>IndexOutOfBoundsException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">codePoint</span> <span class="operator">=</span> str.codePointAt(i); <span class="comment">// 返回 U+1F30D</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">chat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Character.toChars(codePoint));</span><br><span class="line">            System.out.println(<span class="string">&quot;索引（&quot;</span> + i + <span class="string">&quot;）对应代码点是：&quot;</span> + codePoint + <span class="string">&quot; 字符是：&quot;</span> + chat);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">索引（0）对应代码点是：127757 字符是：🌍</span><br><span class="line">索引（1）对应代码点是：57101 字符是：?</span><br><span class="line">索引（2）对应代码点是：72 字符是：H</span><br><span class="line">索引（3）对应代码点是：101 字符是：e</span><br><span class="line">索引（4）对应代码点是：108 字符是：l</span><br><span class="line">索引（5）对应代码点是：108 字符是：l</span><br><span class="line">索引（6）对应代码点是：111 字符是：o</span><br><span class="line">索引（7）对应代码点是：127758 字符是：🌎</span><br><span class="line">索引（8）对应代码点是：57102 字符是：?</span><br></pre></td></tr></table></figure></li><li><p>codePointCount(int beginIndex, int endIndex):</p><ul><li><code>codePointCount</code> 方法返回指定索引范围内的代码点数量。</li><li>传入的索引范围是从开始索引（包括）到结束索引（不包括）之间的范围。</li><li>引入这个方法的目的是为了处理字符串中可能包含的代理对和其他 Unicode 字符。</li><li>当计算代码点数量时，会自动将代理对视为一个代码点。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;(🌍Hello🌎)有&quot;</span> + str.codePointCount(<span class="number">0</span>, str.length()) + <span class="string">&quot;个代码点&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(🌍Hello🌎)有7个代码点</span><br></pre></td></tr></table></figure></li><li><p>codePointBefore(int index):</p><ul><li><code>codePointBefore</code> 方法返回给定索引位置之前一个代码点的值。</li><li>如果在给定索引位置之前存在代理对的低代理项，则返回对应的 Unicode 代码点。</li><li>如果给定索引位置之前没有代码点，或者在开始索引位置，则此方法将引发 <code>IndexOutOfBoundsException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">codePointBefore</span> <span class="operator">=</span> str.codePointBefore(<span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;代码点：&quot;</span> + codePointBefore); <span class="comment">// 输出：127757</span></span><br><span class="line"><span class="type">String</span> <span class="variable">codePointString</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;codePointBefore&#125;, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符：&quot;</span> + codePointString); <span class="comment">// 输出：🌍</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">代码点：127757</span><br><span class="line">字符：🌍</span><br></pre></td></tr></table></figure></li><li><p>length():</p><ul><li><code>length</code> 方法返回字符串的代码单元数量（UTF-16 编码的代码单元个数）。</li><li>对于 ASCII 字符和大多数常见的非 ASCII 字符，一个字符对应一个代码单元。</li><li>对于代理对和其他 Unicode 符号，一个字符可能对应两个代码单元（即一个扩展字符）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> str.length(); <span class="comment">// 返回 9</span></span><br><span class="line">System.out.println(<span class="string">&quot;（🌍Hello🌎）的长度为：&quot;</span> + length);</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">（🌍Hello🌎）的长度为：9</span><br></pre></td></tr></table></figure></li><li><p>offsetByCodePoints(int index, int codePointOffset):</p><ul><li><code>offsetByCodePoints</code> 方法返回从给定索引位置开始，偏移指定的代码点数量后的索引位置。</li><li>这个方法主要用于处理代码点之间的偏移，考虑到代理对的情况。</li><li>用 <code>index</code> 指定要偏移的起始索引，<code>codePointOffset</code> 指定要偏移的代码点数量。</li><li>如果偏移数量是正数，则索引向后移动；如果偏移数量是负数，则索引向前移动。</li><li>如果计算得到的索引位置超出了字符串的有效范围，此方法将引发 <code>IndexOutOfBoundsException</code> 异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;🌍Hello🌎&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">2</span>; <span class="comment">// 获取第三个代码点对应的字符，索引是从0开始的</span></span><br><span class="line"><span class="type">int</span> <span class="variable">codePoint</span> <span class="operator">=</span> str.codePointAt(str.offsetByCodePoints(<span class="number">0</span>, index)); <span class="comment">// 获取指定索引位置的代码点</span></span><br><span class="line"><span class="type">String</span> <span class="variable">character</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(Character.toChars(codePoint)); <span class="comment">// 将代码点转换为对应的字符</span></span><br><span class="line">System.out.println(<span class="string">&quot;第三个代码点对应的字符是：&quot;</span> + character); <span class="comment">// 输出指定代码点位置的字符</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第三个代码点对应的字符是：e</span><br></pre></td></tr></table></figure></li></ol><h3 id="空串和NULL串"><a href="#空串和NULL串" class="headerlink" title="空串和NULL串"></a>空串和NULL串</h3><p>在Java中，String类对空字符串（也就是空串，长度为0的字符串）和null字符串（未初始化的字符串引用）有着不同的处理方式。</p><ol><li><p>空串（Empty String）：空串是指长度为0的字符串，可以使用双引号””表示。String类的方法可以对空串进行操作，比如获取长度、连接、查找子串等等。在处理空串时，不会引发空指针异常，因为空串的长度为0，所有的操作都能够正常进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">emptyStr</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> emptyStr.length(); <span class="comment">// 获取空串的长度，结果为0</span></span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> emptyStr + <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 将空串与其他字符串连接，结果为&quot;Hello&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> emptyStr.indexOf(<span class="string">&quot;abc&quot;</span>); <span class="comment">// 在空串中查找子串，结果为-1</span></span><br></pre></td></tr></table></figure></li><li><p>null串（Null String）：null串是指未初始化的字符串引用，它不指向任何有效的字符串对象。如果尝试在null串上调用方法或者进行操作，就会引发空指针异常（NullPointerException）。因此，在对字符串进行操作之前，必须确保其不为null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">nullStr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// 下面的代码会引发空指针异常</span></span><br><span class="line"><span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> nullStr.length(); </span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> nullStr + <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> nullStr.indexOf(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>在实际编程中，需要注意在使用String类的方法时，要确保字符串不为null。可以通过条件判断或者空指针检查来避免空指针异常的发生。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型转换的奥秘及精度丢失背后的故事</title>
      <link href="/posts/13247.html"/>
      <url>/posts/13247.html</url>
      
        <content type="html"><![CDATA[<p>作为一个Java开发人员，你一定对数据类型转换非常熟悉。然而，你是否真正理解它背后的原理和精度丢失问题呢？本文将详细介绍Java中数据类型转换的各种方法和注意事项，并深入探讨涉及的精度丢失问题。</p><h2 id="1-数据类型转换的种类"><a href="#1-数据类型转换的种类" class="headerlink" title="1. 数据类型转换的种类"></a>1. 数据类型转换的种类</h2><h3 id="1-1-隐式类型转换"><a href="#1-1-隐式类型转换" class="headerlink" title="1.1 隐式类型转换"></a>1.1 隐式类型转换</h3><p>隐式类型转换发生在将数据范围小的类型转换为数据范围大的类型时，编译器会自动进行转换。这种转换是安全的，不涉及精度丢失。</p><h3 id="1-2-显式类型转换"><a href="#1-2-显式类型转换" class="headerlink" title="1.2 显式类型转换"></a>1.2 显式类型转换</h3><p>显式类型转换需要手动指定，常见于将数据范围大的类型转换为数据范围小的类型。但需要注意的是，这种转换可能会导致精度丢失。</p><h2 id="2-理解精度丢失问题"><a href="#2-理解精度丢失问题" class="headerlink" title="2. 理解精度丢失问题"></a>2. 理解精度丢失问题</h2><p>在进行数据类型转换时，尤其是将包含小数部分的<code>double</code>值转换为整数类型时，可能会遇到精度丢失的问题。这是因为整数类型无法表示小数部分，转换结果将直接截断小数部分。</p><p>下面是一个示例，展示了精度丢失问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10.7</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) a; <span class="comment">// 显式类型转换</span></span><br><span class="line">System.out.println(b); <span class="comment">// 输出结果为10，小数部分丢失</span></span><br></pre></td></tr></table></figure><h2 id="3-图解精度丢失问题"><a href="#3-图解精度丢失问题" class="headerlink" title="3. 图解精度丢失问题"></a>3. 图解精度丢失问题</h2><p>下面的图片将帮助你更直观地理解精度丢失问题：</p><p><img src="https://www.cdn.cheneyblog.com/blog/202401102148064.png" alt="精度丢失示意图"></p><h2 id="4-使用方法示例"><a href="#4-使用方法示例" class="headerlink" title="4. 使用方法示例"></a>4. 使用方法示例</h2><p>下面是关于数据类型转换的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataTypeConversion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 隐式类型转换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 显式类型转换</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10.5</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> (<span class="type">int</span>) c;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;隐式类型转换结果：&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;显式类型转换结果：&quot;</span> + d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行上述示例代码，你将会看到以下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">隐式类型转换结果：10.0</span><br><span class="line">显式类型转换结果：10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Math:数学魔法</title>
      <link href="/posts/25425.html"/>
      <url>/posts/25425.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Math类库？"><a href="#什么是Math类库？" class="headerlink" title="什么是Math类库？"></a>什么是Math类库？</h2><p>Math类是Java标准库中的一部分，位于java.lang包中。它提供了一系列用于执行常见数学运算的静态方法和常量。不需要创建Math类的实例，我们可以直接通过类名来调用这些方法。</p><h2 id="常用的Math类方法"><a href="#常用的Math类方法" class="headerlink" title="常用的Math类方法"></a>常用的Math类方法</h2><h3 id="绝对值方法"><a href="#绝对值方法" class="headerlink" title="绝对值方法"></a>绝对值方法</h3><p>在Java的Math类中，提供了一个abs函数用于计算绝对值。这个函数接受一个数值参数，并返回其绝对值。</p><p>以下是使用Math.abs方法计算绝对值的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> -<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">absValue</span> <span class="operator">=</span> Math.abs(number);</span><br><span class="line">System.out.println(<span class="string">&quot;The absolute value of &quot;</span> + number + <span class="string">&quot; is: &quot;</span> + absValue);</span><br></pre></td></tr></table></figure><p>运行以上代码会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The absolute value of -10 is: 10</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了Math.abs方法来计算-10的绝对值，并输出结果。</p><p>Math.abs方法可以用于整数、浮点数和长整数类型的绝对值计算。如果在使用时提供了负数，它将返回该数值的正值。</p><h3 id="平方根"><a href="#平方根" class="headerlink" title="平方根"></a>平方根</h3><p>在Java中，可以使用Math类的sqrt方法来求一个数的平方根。该方法的函数原型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sqrt</span><span class="params">(<span class="type">double</span> a)</span></span><br></pre></td></tr></table></figure><p>它接受一个double类型的参数a，返回a的平方根。例如，要计算数字16的平方根，可以这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> Math.sqrt(<span class="number">16</span>);  <span class="comment">// 结果为4.0</span></span><br></pre></td></tr></table></figure><h3 id="指数运算方法"><a href="#指数运算方法" class="headerlink" title="指数运算方法"></a>指数运算方法</h3><p>指数运算是数学中的一种运算方式，用于表示一个数（底数）的多少次幂。指数运算通常用符号 “^” 表示。例如，a^b 表示将底数 a 自乘 b 次，其中 a 为底数，b 为指数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">exponential</span> <span class="operator">=</span> Math.exp(<span class="number">2</span>);  <span class="comment">// 结果为7.389</span></span><br></pre></td></tr></table></figure><p>  自然对数 e（约等于2.71828），Math.exp(2) 就表示 e 的平方，即 e^2，结果为约等于7.389。</p><h3 id="最大值和最小值方法"><a href="#最大值和最小值方法" class="headerlink" title="最大值和最小值方法"></a>最大值和最小值方法</h3><p>在Java中，Math类提供了两个静态方法来获取一组数值中的最大值和最小值。这两个方法分别是 Math.max 和 Math.min 。下面我将详细介绍这两个方法的用法：</p><ol><li><p>获取最大值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(a, b);</span><br><span class="line">System.out.println(<span class="string">&quot;The maximum value is: &quot;</span> + max);</span><br></pre></td></tr></table></figure><p> 在这个示例中，我们使用了 Math.max 方法来获取 a 和 b 中的最大值。max 方法接受两个参数，返回其中较大的那个值。</p></li><li><p>获取最小值：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> -<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(x, y);</span><br><span class="line">System.out.println(<span class="string">&quot;The minimum value is: &quot;</span> + min);</span><br></pre></td></tr></table></figure><p> 在这个示例中，我们使用了 Math.min 方法来获取 x 和 y 中的最小值。min 方法同样接受两个参数，返回其中较小的那个值。</p></li></ol><p>通过使用这两个方法，你可以方便地获取一组数值中的最大值和最小值，而无需手动编写比较逻辑。这样不仅减少了冗余代码，还提高了代码的可读性和可维护性。</p><h3 id="角度和弧度转换方法"><a href="#角度和弧度转换方法" class="headerlink" title="角度和弧度转换方法"></a>角度和弧度转换方法</h3><p>当使用Java中的Math类来实现角度和弧度之间的转换时，你可以使用Math.toRadians和Math.toDegrees两个静态方法。下面我将详细介绍这两个方法的用法：</p><ol><li><p>角度转弧度：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">degree</span> <span class="operator">=</span> <span class="number">45.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">radian</span> <span class="operator">=</span> Math.toRadians(degree);</span><br><span class="line">System.out.println(degree + <span class="string">&quot; degrees is equal to &quot;</span> + radian + <span class="string">&quot; radians&quot;</span>);</span><br></pre></td></tr></table></figure><p> 在这个示例中，我们使用了Math.toRadians方法来将45度转换为弧度。toRadians方法接受一个double类型的参数，表示角度，然后返回对应的弧度值。</p></li><li><p>弧度转角度：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">radianValue</span> <span class="operator">=</span> Math.PI / <span class="number">4</span>; <span class="comment">// 45 度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">degreeValue</span> <span class="operator">=</span> Math.toDegrees(radianValue);</span><br><span class="line">System.out.println(radianValue + <span class="string">&quot; radians is equal to &quot;</span> + degreeValue + <span class="string">&quot; degrees&quot;</span>);</span><br></pre></td></tr></table></figure><p> 在这个示例中，我们使用了Math.toDegrees方法来将π/4弧度（45度）转换为角度。toDegrees方法同样接受一个double类型的参数，表示弧度，然后返回对应的角度值。</p></li></ol><h3 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h3><p>在Java中，可以使用Math类的pow方法进行幂运算。该方法的函数原型为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span></span><br></pre></td></tr></table></figure><p>它接受两个double类型的参数a和b，返回a的b次幂。例如，要计算2的3次幂，可以这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">result</span> <span class="operator">=</span> Math.pow(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 结果为8.0</span></span><br></pre></td></tr></table></figure><p>这样就可以得到2的3次幂的值8.0。Math类的pow方法可以用于计算任意底数的任意次幂，非常强大和灵活。</p><h3 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h3><p>当涉及到三角函数时，Java的Math类提供了一系列函数用于计算各种三角函数的值，包括正弦、余弦、正切以及它们的反函数。以下是这些函数的介绍：</p><ol><li><p>正弦函数（Sine Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">angle</span> <span class="operator">=</span> Math.PI / <span class="number">4.0</span>; <span class="comment">// 弧度制角度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">sinValue</span> <span class="operator">=</span> Math.sin(angle); <span class="comment">// 计算正弦值</span></span><br><span class="line">System.out.println(<span class="string">&quot;sin(&quot;</span> + angle + <span class="string">&quot;) is: &quot;</span> + sinValue);</span><br></pre></td></tr></table></figure></li><li><p>余弦函数（Cosine Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">angle</span> <span class="operator">=</span> Math.PI / <span class="number">4.0</span>; <span class="comment">// 弧度制角度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">cosValue</span> <span class="operator">=</span> Math.cos(angle); <span class="comment">// 计算余弦值</span></span><br><span class="line">System.out.println(<span class="string">&quot;cos(&quot;</span> + angle + <span class="string">&quot;) is: &quot;</span> + cosValue);</span><br></pre></td></tr></table></figure></li><li><p>正切函数（Tangent Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">angle</span> <span class="operator">=</span> Math.PI / <span class="number">4.0</span>; <span class="comment">// 弧度制角度</span></span><br><span class="line"><span class="type">double</span> <span class="variable">tanValue</span> <span class="operator">=</span> Math.tan(angle); <span class="comment">// 计算正切值</span></span><br><span class="line">System.out.println(<span class="string">&quot;tan(&quot;</span> + angle + <span class="string">&quot;) is: &quot;</span> + tanValue);</span><br></pre></td></tr></table></figure></li><li><p>反正弦函数（Arcsine Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">sinValue</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">asinValue</span> <span class="operator">=</span> Math.asin(sinValue); <span class="comment">// 计算反正弦值</span></span><br><span class="line">System.out.println(<span class="string">&quot;asin(&quot;</span> + sinValue + <span class="string">&quot;) is: &quot;</span> + asinValue);</span><br></pre></td></tr></table></figure></li><li><p>反余弦函数（Arccosine Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">cosValue</span> <span class="operator">=</span> <span class="number">0.5</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">acosValue</span> <span class="operator">=</span> Math.acos(cosValue); <span class="comment">// 计算反余弦值</span></span><br><span class="line">System.out.println(<span class="string">&quot;acos(&quot;</span> + cosValue + <span class="string">&quot;) is: &quot;</span> + acosValue);</span><br></pre></td></tr></table></figure></li><li><p>反正切函数（Arctangent Function）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">tanValue</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">atanValue</span> <span class="operator">=</span> Math.atan(tanValue); <span class="comment">// 计算反正切值</span></span><br><span class="line">System.out.println(<span class="string">&quot;atan(&quot;</span> + tanValue + <span class="string">&quot;) is: &quot;</span> + atanValue);</span><br></pre></td></tr></table></figure></li></ol><p>这些函数都接受一个弧度制的角度作为参数，并返回相应的三角函数值或反三角函数值。</p><h3 id="对数"><a href="#对数" class="headerlink" title="对数"></a>对数</h3><p>当涉及到对数运算时，Java的Math类提供了一些方法来计算对数。主要包括自然对数（以e为底的对数）和常用对数（以10为底的对数）的计算。</p><ol><li><p>自然对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">naturalLog</span> <span class="operator">=</span> Math.log(x); <span class="comment">// 计算以 e 为底的对数</span></span><br><span class="line">System.out.println(<span class="string">&quot;ln(&quot;</span> + x + <span class="string">&quot;) is: &quot;</span> + naturalLog);</span><br></pre></td></tr></table></figure></li><li><p>常用对数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100.0</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">log10</span> <span class="operator">=</span> Math.log10(y); <span class="comment">// 计算以 10 为底的对数</span></span><br><span class="line">System.out.println(<span class="string">&quot;log(&quot;</span> + y + <span class="string">&quot;) is: &quot;</span> + log10);</span><br></pre></td></tr></table></figure></li></ol><p>在这两个示例中，我们分别使用了Math类中的log方法和log10方法来计算自然对数和常用对数。</p><p>值得注意的是，Math类中的log方法表示自然对数，计算数学常数e为底的对数，而log10方法表示常用对数，计算以10为底的对数。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="圆周率常量"><a href="#圆周率常量" class="headerlink" title="圆周率常量"></a>圆周率常量</h3><p>在Java中，Math类提供了一个常量字段 Math.PI，它代表了圆周率π的近似值。π是一个无理数，表示圆的周长与直径的比值，约等于3.14159。</p><p>你可以通过直接引用 Math.PI 来使用圆周率常量。以下是一个使用 Math.PI 的简单示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PiConstant</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">circumference</span> <span class="operator">=</span> <span class="number">2</span> * Math.PI * radius;</span><br><span class="line">        System.out.println(<span class="string">&quot;The circumference of the circle is: &quot;</span> + circumference);</span><br><span class="line">        </span><br><span class="line">        <span class="type">double</span> <span class="variable">area</span> <span class="operator">=</span> Math.PI * radius * radius;</span><br><span class="line">        System.out.println(<span class="string">&quot;The area of the circle is: &quot;</span> + area);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用了 Math.PI 来计算圆的周长和面积。Math.PI 代表了圆周率的近似值，它会在计算中自动被替换。这样，我们就能够在不需要手动输入圆周率的情况下进行计算。</p><p>运行这段代码会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The circumference of the circle is: 6.283185307179586</span><br><span class="line">The area of the circle is: 3.141592653589793</span><br></pre></td></tr></table></figure><p>这样，你可以使用 Math.PI 来方便地在计算中使用圆周率常量，而不需要自己手动定义或计算圆周率的值。</p><h3 id="自然对数e"><a href="#自然对数e" class="headerlink" title="自然对数e"></a>自然对数e</h3><p>在Java的Math类中，可以使用常量Math.E来表示自然对数的底e。Math.E代表一个双精度浮点数，它是一个近似于2.71828的常量。你可以直接使用Math.E来进行各种数学计算。</p><p>下面是一个简单的示例，展示了如何使用Math.E常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="variable">eValue</span> <span class="operator">=</span> Math.E; <span class="comment">// 获取e的值</span></span><br><span class="line">System.out.println(<span class="string">&quot;The value of e is: &quot;</span> + eValue);</span><br></pre></td></tr></table></figure><p>这段代码将打印出e的值：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The value of e is: 2.718281828459045</span><br></pre></td></tr></table></figure><p>这表明，使用Math.E常量，你可以方便地在Java中进行自然对数相关的计算。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java类库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专有名词解析：从人工智能到机器学习、深度学习</title>
      <link href="/posts/5484.html"/>
      <url>/posts/5484.html</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><p>人工智能（AI）正迅速渗透到我们的日常生活中，但随之而来的是一系列专有名词，如人工职能、机器学习、深度学习等，这些名词对于初学者来说可能有些晦涩。本文将解析这些名词，帮助读者更好地理解AI领域，以更快速地进入AI的学习之旅。</p><h2 id="人工智能（Artificial-Intelligence，简称AI）"><a href="#人工智能（Artificial-Intelligence，简称AI）" class="headerlink" title="人工智能（Artificial Intelligence，简称AI）"></a>人工智能（Artificial Intelligence，简称AI）</h2><p>人工智能是计算机系统模拟、推理和表现人类智能的一门科学。它旨在使计算机能够像人类一样感知、理解、学习和决策。人工智能可以分为狭义和广义。狭义人工智能仅关注特定任务的表现，广义人工智能则追求与人类智能相媲美的多个智能领域的综合表现。</p><h2 id="机器学习（Machine-Learning，简称ML）"><a href="#机器学习（Machine-Learning，简称ML）" class="headerlink" title="机器学习（Machine Learning，简称ML）"></a>机器学习（Machine Learning，简称ML）</h2><p>机器学习是一种人工智能的分支，它关注使计算机能够通过数据学习和改进性能，而无需明确编程。机器学习有监督学习、无监督学习和强化学习等不同类型。在监督学习中，计算机通过事先提供的标记数据进行训练；在无监督学习中，计算机从未标记的数据中寻找模式；在强化学习中，计算机通过与环境互动来学习采取适当行动的策略。</p><h2 id="深度学习（Deep-Learning）"><a href="#深度学习（Deep-Learning）" class="headerlink" title="深度学习（Deep Learning）"></a>深度学习（Deep Learning）</h2><p>深度学习是机器学习的一个子领域，它模仿人脑神经网络的结构和功能。深度学习通过多层神经网络将数据进行多次非线性变换，从而实现对输入数据的高级抽象和表示。相比传统的机器学习方法，深度学习在处理大规模数据和复杂任务时表现出更好的性能。它被广泛应用于计算机视觉、语音识别、自然语言处理等领域。</p><h2 id="自然语言处理（Natural-Language-Processing，简称NLP）"><a href="#自然语言处理（Natural-Language-Processing，简称NLP）" class="headerlink" title="自然语言处理（Natural Language Processing，简称NLP）"></a>自然语言处理（Natural Language Processing，简称NLP）</h2><p>自然语言处理是研究计算机与人类语言之间交互的一门技术。它涉及语音识别、文本理解、机器翻译等任务。自然语言处理利用机器学习和深度学习方法，使计算机能够理解、生成和处理人类语言，实现自动化的文本处理和人机交互。</p><h2 id="神经网络（Neural-Network）"><a href="#神经网络（Neural-Network）" class="headerlink" title="神经网络（Neural Network）"></a>神经网络（Neural Network）</h2><p>神经网络是一种模仿生物神经系统运作方式的计算模型。它由一系列人工神经元互连而成，每个神经元接收输入、执行计算和生成输出。神经网络通过学习和调整连接权重，能够从输入中提取有用的特征并进行准确的预测。深度学习就是基于深层神经网络的理论和方法。</p><h2 id="数据挖掘（Data-Mining）"><a href="#数据挖掘（Data-Mining）" class="headerlink" title="数据挖掘（Data Mining）"></a>数据挖掘（Data Mining）</h2><p>数据挖掘是从大量数据中自动地发现模式、规律和信息的过程。它运用统计学、机器学习和数据库技术，从结构化和非结构化的数据中提取知识和洞察力。数据挖掘可以帮助企业发现消费者行为、市场趋势、异常情况等，为决策提供支持。</p>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyMySQL:让Python和MySQL轻松对话！</title>
      <link href="/posts/8408.html"/>
      <url>/posts/8408.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Python是一门广泛应用于数据处理和开发领域的高级编程语言。而MySQL作为一种常用的关系型数据库管理系统，在Python开发中扮演着重要的角色。pymysql模块是Python中连接和操作MySQL数据库的一个强大工具。</p><h2 id="安装pymysql模块"><a href="#安装pymysql模块" class="headerlink" title="安装pymysql模块"></a>安装pymysql模块</h2><p>首先，我们需要确保已经在Python环境中安装了pymysql模块。可以通过以下命令进行安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><h2 id="连接MySQL数据库"><a href="#连接MySQL数据库" class="headerlink" title="连接MySQL数据库"></a>连接MySQL数据库</h2><p>在使用pymysql之前，我们需要建立与MySQL数据库的连接。可以通过以下代码来创建连接对象并连接到数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建连接</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;localhost&#x27;</span>,  <span class="comment"># 数据库主机名</span></span><br><span class="line">    port=<span class="number">3306</span>,  <span class="comment"># 数据库端口号</span></span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,  <span class="comment"># 数据库用户名</span></span><br><span class="line">    password=<span class="string">&#x27;password&#x27;</span>,  <span class="comment"># 数据库密码</span></span><br><span class="line">    db=<span class="string">&#x27;mydatabase&#x27;</span>  <span class="comment"># 数据库名</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建游标对象</span></span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行SQL语句</span></span><br><span class="line">cur.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理执行结果</span></span><br><span class="line">data = cur.fetchall()</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> data:</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭游标和连接</span></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h2 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h2><p>使用pymysql执行SQL语句非常简单。可以通过以下代码来执行SELECT、INSERT、UPDATE和DELETE语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;password&#x27;</span>, db=<span class="string">&#x27;mydatabase&#x27;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询数据</span></span><br><span class="line">cur.execute(<span class="string">&quot;SELECT * FROM users&quot;</span>)</span><br><span class="line">data = cur.fetchall()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">cur.execute(<span class="string">&quot;INSERT INTO users (name, age) VALUES (&#x27;Alice&#x27;, 25)&quot;</span>)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line">cur.execute(<span class="string">&quot;UPDATE users SET age = 26 WHERE name = &#x27;Alice&#x27;&quot;</span>)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除数据</span></span><br><span class="line">cur.execute(<span class="string">&quot;DELETE FROM users WHERE name = &#x27;Alice&#x27;&quot;</span>)</span><br><span class="line">conn.commit()</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h2 id="使用参数化查询"><a href="#使用参数化查询" class="headerlink" title="使用参数化查询"></a>使用参数化查询</h2><p>为了提高安全性和性能，在执行SQL查询时，我们推荐使用参数化查询。可以通过以下代码来实现参数化查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;password&#x27;</span>, db=<span class="string">&#x27;mydatabase&#x27;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数化查询</span></span><br><span class="line">name = <span class="string">&#x27;Alice&#x27;</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">cur.execute(<span class="string">&quot;SELECT * FROM users WHERE name = %s AND age = %s&quot;</span>, (name, age))</span><br><span class="line">data = cur.fetchall()</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>在数据库操作过程中，异常处理非常重要。我们可以使用try-except语句来捕获并处理可能发生的异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, user=<span class="string">&#x27;root&#x27;</span>, password=<span class="string">&#x27;password&#x27;</span>, db=<span class="string">&#x27;mydatabase&#x27;</span>)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cur.execute(<span class="string">&quot;INSERT INTO nonexistent_table (name) VALUES (&#x27;Alice&#x27;)&quot;</span>)</span><br><span class="line">    conn.commit()</span><br><span class="line"><span class="keyword">except</span> pymysql.Error <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Error: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">cur.close()</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Listagg函数详解</title>
      <link href="/posts/59934.html"/>
      <url>/posts/59934.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Listagg函数？"><a href="#什么是Listagg函数？" class="headerlink" title="什么是Listagg函数？"></a>什么是Listagg函数？</h2><p><code>Listagg</code>函数是Oracle数据库中用于字符串拼接的函数。它可以将多行数据中的某个字段的值按照指定的分隔符拼接为一个字符串，并将结果返回。</p><h2 id="Listagg函数的语法"><a href="#Listagg函数的语法" class="headerlink" title="Listagg函数的语法"></a>Listagg函数的语法</h2><p><code>Listagg</code>函数的语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">LISTAGG</span>(expression, delimiter) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span>)</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>expression</code>：用于拼接的列或表达式。</li><li><code>delimiter</code>：指定的分隔符，用于将拼接的字符串分隔开。</li><li><code>column</code>：用于排序的列，可选参数。</li></ul><h2 id="Listagg函数的示例"><a href="#Listagg函数的示例" class="headerlink" title="Listagg函数的示例"></a>Listagg函数的示例</h2><p>假设我们有一个名为<code>employees</code>的表，包含以下数据：</p><table><thead><tr><th>ID</th><th>NAME</th><th>DEPARTMENT</th></tr></thead><tbody><tr><td>1</td><td>Alice</td><td>IT</td></tr><tr><td>2</td><td>Bob</td><td>HR</td></tr><tr><td>3</td><td>Charlie</td><td>IT</td></tr><tr><td>4</td><td>David</td><td>Finance</td></tr><tr><td>5</td><td>Eve</td><td>HR</td></tr></tbody></table><p>现在，我们将演示一些常见的<code>Listagg</code>函数的用法。</p><h3 id="示例1：无分组拼接"><a href="#示例1：无分组拼接" class="headerlink" title="示例1：无分组拼接"></a>示例1：无分组拼接</h3><p>假设我们想将<code>employees</code>表中的所有员工名字按照逗号分隔拼接成一个字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LISTAGG</span>(NAME, <span class="string">&#x27;,&#x27;</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> NAMES</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAMES</span><br><span class="line">-----------------</span><br><span class="line">Alice,Bob,Charlie,David,Eve</span><br></pre></td></tr></table></figure><h3 id="示例2：分组拼接"><a href="#示例2：分组拼接" class="headerlink" title="示例2：分组拼接"></a>示例2：分组拼接</h3><p>假设我们想将<code>employees</code>表中每个部门的员工名字按照逗号分隔拼接成一个字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DEPARTMENT, <span class="built_in">LISTAGG</span>(NAME, <span class="string">&#x27;,&#x27;</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> NAMES</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> DEPARTMENT;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DEPARTMENT | NAMES</span><br><span class="line">-----------|-----------------</span><br><span class="line">IT         | Alice,Charlie</span><br><span class="line">HR         | Bob,Eve</span><br><span class="line">Finance    | David</span><br></pre></td></tr></table></figure><h3 id="示例3：指定排序顺序"><a href="#示例3：指定排序顺序" class="headerlink" title="示例3：指定排序顺序"></a>示例3：指定排序顺序</h3><p>假设我们想将<code>employees</code>表中所有员工名字按照部门和ID进行排序，并按照逗号分隔拼接成一个字符串。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">LISTAGG</span>(NAME, <span class="string">&#x27;,&#x27;</span>) <span class="keyword">WITHIN</span> <span class="keyword">GROUP</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> DEPARTMENT, ID) <span class="keyword">AS</span> NAMES</span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAMES</span><br><span class="line">-----------------</span><br><span class="line">Alice,Charlie,Bob,David,Eve</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> OracleSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络代理：突破边界，畅游网络世界</title>
      <link href="/posts/45661.html"/>
      <url>/posts/45661.html</url>
      
        <content type="html"><![CDATA[<p>在如今信息时代的浪潮中，互联网已经成为了人们日常生活中不可或缺的一部分。然而，有时我们会遭遇一些困扰，包括限制访问、屏蔽内容等问题。这时候，网络代理就成了我们寻找自由和突破边界的利器。本文将带您探索网络代理的奇妙之处，让您在数字世界中尽情畅游。</p><h2 id="什么是网络代理？"><a href="#什么是网络代理？" class="headerlink" title="什么是网络代理？"></a>什么是网络代理？</h2><p>网络代理（Proxy）指的是在网络通讯中，代理服务器充当客户端和目标服务器之间的中间人。当您访问一个网站时，一般情况下，请求会直接发送到目标服务器并返回响应。而通过使用网络代理，您的请求会先发送到代理服务器，再由代理服务器转发给目标服务器，并把响应返回给您。这个过程中，代理服务器可以改变请求和响应的内容、隐藏真实IP地址等，从而达到突破网络限制和保护隐私的目的。</p><h2 id="网络代理的分类"><a href="#网络代理的分类" class="headerlink" title="网络代理的分类"></a>网络代理的分类</h2><p>网络代理可以根据其功能和部署位置进行多种分类，主要可以分为正向代理、反向代理、透明代理和匿名代理。</p><ol><li><p><strong>正向代理</strong>：<br>正向代理位于客户端和真实服务器之间，代替客户端向服务器发起请求，获取服务器响应后再转发给客户端。常见用途包括：</p><ul><li><strong>突破网络限制</strong>：访问被封锁的网站或服务，如翻墙软件。</li><li><strong>访问控制</strong>：控制员工访问外部网站的权限。</li><li><strong>缓存服务</strong>：加快用户访问速度，节省带宽。</li></ul></li><li><p><strong>反向代理</strong>：<br>反向代理位于真实服务器和客户端之间，代替服务器响应客户端的请求。主要用途包括：</p><ul><li><strong>负载均衡</strong>：分发客户端请求到多个服务器，提高网站性能与可用性。</li><li><strong>安全过滤</strong>：隐藏真实服务器IP地址，保护服务器免受直接攻击。</li><li><strong>缓存加速</strong>：缓存静态资源，加快用户访问速度。</li></ul></li><li><p><strong>透明代理</strong>：<br>用户在不知情的情况下由网络设备自动进行代理转发。主要用途包括：</p><ul><li><strong>访问控制</strong>：企业内部网络对外部通信进行过滤和监控。</li><li><strong>安全防护</strong>：对网络流量进行检查和过滤，保护内部网络安全。</li></ul></li><li><p><strong>匿名代理</strong>：<br>匿名代理隐藏了客户端的真实IP地址，在网络中具有一定的匿名性。通常用于：</p><ul><li><strong>隐藏身份</strong>：通过匿名代理访问互联网，保护用户隐私。</li><li><strong>防止追踪</strong>：避免被追踪或监视，提高网络安全性。</li></ul></li></ol><p>这些不同类型的网络代理在实际应用中有着不同的功能和用途，能够为网络通信提供更多的安全性、隐私保护、性能优化和访问控制等功能。</p><h2 id="网络代理的应用场景"><a href="#网络代理的应用场景" class="headerlink" title="网络代理的应用场景"></a>网络代理的应用场景</h2><p>网络代理在各个领域有着广泛的应用，以下是一些常见的应用场景：</p><h3 id="1-企业网络安全"><a href="#1-企业网络安全" class="headerlink" title="1. 企业网络安全"></a>1. 企业网络安全</h3><p>企业可以设置反向代理来保护内部网络资源，防御DDoS攻击，实现安全访问控制。</p><h3 id="2-访问受限内容"><a href="#2-访问受限内容" class="headerlink" title="2. 访问受限内容"></a>2. 访问受限内容</h3><p>正向代理可以帮助我们绕过地区限制和网络封锁，访问被屏蔽的网站和服务。</p><h3 id="3-隐私保护"><a href="#3-隐私保护" class="headerlink" title="3. 隐私保护"></a>3. 隐私保护</h3><p>通过匿名代理或高匿代理，我们可以隐藏真实IP地址，保护个人隐私免受追踪和监视。</p><h3 id="4-流量分发与负载均衡"><a href="#4-流量分发与负载均衡" class="headerlink" title="4. 流量分发与负载均衡"></a>4. 流量分发与负载均衡</h3><p>反向代理可以在多个服务器之间分配流量，实现负载均衡，并提高网站的可用性和性能。</p><h3 id="5-加速访问速度"><a href="#5-加速访问速度" class="headerlink" title="5. 加速访问速度"></a>5. 加速访问速度</h3><p>通过正向代理的缓存和压缩技术，可以加快静态资源的加载速度，提供更快的访问体验。</p><h2 id="网络代理的高级技巧"><a href="#网络代理的高级技巧" class="headerlink" title="网络代理的高级技巧"></a>网络代理的高级技巧</h2><ol><li><p><strong>代理链与多重跳板</strong>：使用代理链和多重跳板可以增加网络安全性和匿名性，混淆你的真实身份和访问路径，提高防御能力。</p></li><li><p><strong>逆向代理与脱壳分析</strong>：逆向代理是将原本作为服务器的应用程序转化为正向代理，可以更好地进行应用程序的逆向工程和脱壳分析。</p></li><li><p><strong>自建代理服务器与自定义规则</strong>：通过自建代理服务器和自定义规则，你可以更加自由地控制代理行为，实现更高级的功能和个性化需求。</p></li></ol><h2 id="如何选择合适的网络代理工具"><a href="#如何选择合适的网络代理工具" class="headerlink" title="如何选择合适的网络代理工具"></a>如何选择合适的网络代理工具</h2><p>在选择网络代理工具时，我们需要考虑以下几个因素：</p><ol><li><strong>安全性</strong>：选择可靠的网络代理工具，确保其能提供安全的数据传输和保护您的隐私。</li><li><strong>稳定性</strong>：选择稳定可靠的网络代理服务器，确保其不会频繁出现连接断开或服务不可用的情况。</li><li><strong>速度</strong>：考虑网络代理工具的速度表现，确保其不会显著降低网络连接的速度。</li><li><strong>易用性</strong>：选择易于使用和设置的工具，以确保您能够快速配置和管理网络代理。</li></ol><blockquote><p>注：本文仅提供网络代理的基本概念和作用，具体使用请参考相关服务提供商的指导和文档。<br>请注意，本文仅提供一般性信息，并不构成对网络代理服务的推荐或认可。使用网络代理时，请遵守相关法律法规和服务条款。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊全局变量：解锁创新思维</title>
      <link href="/posts/34883.html"/>
      <url>/posts/34883.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-name"><a href="#1-name" class="headerlink" title="1. __name__"></a>1. <code>__name__</code></h2><p><code>__name__</code> 是一个特殊的全局变量，用于表示当前模块的名称。它常用于判断一个模块是被直接运行还是被导入到其他模块中。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This is the main function.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be executed when the file is run directly.&quot;</span>)</span><br><span class="line">    main()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;This will be executed when the file is imported as a module.&quot;</span>)</span><br></pre></td></tr></table></figure><p>当直接运行 <code>example.py</code> 文件时，会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This will be executed when the file is run directly.</span><br><span class="line">This is the main <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure><p>而当在另一个 Python 文件中导入 <code>example.py</code> 时，会输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This will be executed when the file is imported as a module.</span><br></pre></td></tr></table></figure><h2 id="2-file"><a href="#2-file" class="headerlink" title="2. __file__"></a>2. <code>__file__</code></h2><p><code>__file__</code> 是一个特殊的全局变量，用于表示当前模块的文件路径。它可以帮助我们获取模块的绝对路径或相对路径。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">module_path = os.path.abspath(__file__)</span><br><span class="line"><span class="built_in">print</span>(module_path)  <span class="comment"># 输出：/path/to/module.py</span></span><br></pre></td></tr></table></figure><h2 id="3-doc"><a href="#3-doc" class="headerlink" title="3. __doc__"></a>3. <code>__doc__</code></h2><p><code>__doc__</code> 是一个特殊的全局变量，用于表示当前对象的文档字符串。它常用于在代码中添加文档注释和生成文档。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;This is a documentation string for my_function.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(my_function.__doc__)  <span class="comment"># 输出：This is a documentation string for my_function.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-builtins"><a href="#4-builtins" class="headerlink" title="4. __builtins__"></a>4. <code>__builtins__</code></h2><p><code>__builtins__</code> 是一个特殊的全局变量，用于表示内置命名空间。通过它，我们可以访问和使用内置函数和常用对象。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(__builtins__.<span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># 输出：3</span></span><br></pre></td></tr></table></figure><h2 id="5-package"><a href="#5-package" class="headerlink" title="5. __package__"></a>5. <code>__package__</code></h2><p><code>__package__</code> 是一个特殊的全局变量，用于表示当前模块所属的包名称。它常用于在包内部引用其他模块。以下是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package_name = __package__</span><br><span class="line"><span class="built_in">print</span>(package_name)  <span class="comment"># 输出：my_package</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字典魔法之匣</title>
      <link href="/posts/57085.html"/>
      <url>/posts/57085.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-字典基本操作"><a href="#1-字典基本操作" class="headerlink" title="1. 字典基本操作"></a>1. 字典基本操作</h2><p>在Python中，字典是一种非常常用的数据结构，用于存储键值对。以下是一些常用的字典基本操作方法：</p><ul><li><strong>创建字典</strong>：使用花括号和冒号创建一个字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>访问元素</strong>：通过键访问字典中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(my_dict[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出：Alice</span></span><br></pre></td></tr></table></figure><ul><li><strong>更新元素</strong>：通过键更新字典中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;age&quot;</span>] = <span class="number">31</span></span><br><span class="line"><span class="built_in">print</span>(my_dict)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 31, &#x27;city&#x27;: &#x27;New York&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加元素</strong>：通过新的键值对添加元素到字典中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_dict[<span class="string">&quot;gender&quot;</span>] = <span class="string">&quot;female&quot;</span></span><br><span class="line"><span class="built_in">print</span>(my_dict)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 31, &#x27;city&#x27;: &#x27;New York&#x27;, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除元素</strong>：使用 <code>del</code> 关键字或 <code>pop</code> 方法删除字典中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> my_dict[<span class="string">&quot;city&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(my_dict)  <span class="comment"># 输出：&#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;age&#x27;: 31, &#x27;gender&#x27;: &#x27;female&#x27;&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>键、值、键值对操作</strong>：通过 <code>keys</code>、<code>values</code>、<code>items</code> 方法进行字典键、值和键值对的操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">keys = my_dict.keys()</span><br><span class="line">values = my_dict.values()</span><br><span class="line">items = my_dict.items()</span><br><span class="line"><span class="built_in">print</span>(keys, values, items)</span><br></pre></td></tr></table></figure><h2 id="2-字典高级操作"><a href="#2-字典高级操作" class="headerlink" title="2. 字典高级操作"></a>2. 字典高级操作</h2><p>除了基本操作之外，Python的字典还提供了许多强大的高级操作方法，以下是一些示例：</p><ul><li><strong>字典解析</strong>：使用字典解析式快速创建字典。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_dict = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> numbers&#125;</span><br><span class="line"><span class="built_in">print</span>(squared_dict)</span><br></pre></td></tr></table></figure><ul><li><strong>获取默认值</strong>：使用 <code>get</code> 方法获取字典中的对应键的值，若键不存在返回默认值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = my_dict.get(<span class="string">&quot;age&quot;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(value)  <span class="comment"># 若&quot;age&quot;存在则返回对应值，否则返回0</span></span><br></pre></td></tr></table></figure><ul><li><strong>合并字典</strong>：使用 <code>update</code> 方法将一个字典的键值对更新到另一个字典中。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">new_dict = &#123;<span class="string">&quot;city&quot;</span>: <span class="string">&quot;Los Angeles&quot;</span>, <span class="string">&quot;country&quot;</span>: <span class="string">&quot;USA&quot;</span>&#125;</span><br><span class="line">my_dict.update(new_dict)</span><br><span class="line"><span class="built_in">print</span>(my_dict)  <span class="comment"># 将new_dict中的键值对更新到my_dict中</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>列表操作精髓</title>
      <link href="/posts/34654.html"/>
      <url>/posts/34654.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-列表基本操作"><a href="#1-列表基本操作" class="headerlink" title="1. 列表基本操作"></a>1. 列表基本操作</h2><p>在Python中，列表是一种非常常用的数据结构，我们可以对列表进行各种操作和处理。以下是一些常用的列表基本操作方法：</p><ul><li><strong>创建列表</strong>：使用方括号和逗号创建一个列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li><strong>访问元素</strong>：使用索引访问列表中的元素，索引从0开始计数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出：1</span></span><br></pre></td></tr></table></figure><ul><li><strong>修改元素</strong>：通过索引修改列表中的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出：[10, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure><ul><li><strong>添加元素</strong>：使用 <code>append</code> 方法在列表末尾添加新元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">my_list.append(<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出：[10, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><ul><li><strong>删除元素</strong>：使用 <code>pop</code> 方法删除指定索引的元素，或使用 <code>remove</code> 方法删除指定数值的元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_list.pop(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出：[2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">my_list.remove(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(my_list)  <span class="comment"># 输出：[2, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><ul><li><strong>列表长度</strong>：使用 <code>len</code> 方法获取列表的长度。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length = <span class="built_in">len</span>(my_list)</span><br><span class="line"><span class="built_in">print</span>(length)  <span class="comment"># 输出：4</span></span><br></pre></td></tr></table></figure><h2 id="2-列表切片操作"><a href="#2-列表切片操作" class="headerlink" title="2. 列表切片操作"></a>2. 列表切片操作</h2><p>列表切片操作可以让我们灵活地截取列表的子集，进行各种处理和操作。以下是一些常用的列表切片操作示例：</p><ul><li><strong>截取子列表</strong>：使用切片操作截取列表的子集。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub_list = my_list[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(sub_list)  <span class="comment"># 输出：[4, 5]</span></span><br></pre></td></tr></table></figure><ul><li><strong>步长切片</strong>：使用步长对列表进行切片。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">step_list = my_list[::<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(step_list)  <span class="comment"># 输出：[2, 5]</span></span><br></pre></td></tr></table></figure><ul><li><strong>反转列表</strong>：使用切片操作反转列表的顺序。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">reversed_list = my_list[::-<span class="number">1</span>]</span><br><span class="line"><span class="built_in">print</span>(reversed_list)  <span class="comment"># 输出：[6, 5, 4, 2]</span></span><br></pre></td></tr></table></figure><h2 id="3-列表推导式"><a href="#3-列表推导式" class="headerlink" title="3. 列表推导式"></a>3. 列表推导式</h2><p>列表推导式是Python中非常强大和高效的特性，可以快速生成列表并进行各种操作。以下是几个常见的列表推导式示例：</p><ul><li><strong>生成新列表</strong>：使用列表推导式生成新的列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_list = [x * <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> my_list]</span><br><span class="line"><span class="built_in">print</span>(new_list)  <span class="comment"># 输出：[4, 8, 10, 12]</span></span><br></pre></td></tr></table></figure><ul><li><strong>条件筛选</strong>：结合条件表达式进行列表推导，实现条件筛选操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filtered_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> my_list <span class="keyword">if</span> x &gt; <span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(filtered_list)  <span class="comment"># 输出：[4, 5, 6]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字操作全攻略</title>
      <link href="/posts/29896.html"/>
      <url>/posts/29896.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-数学运算"><a href="#1-数学运算" class="headerlink" title="1. 数学运算"></a>1. 数学运算</h2><p>在Python中，我们可以进行各种数学运算，包括基本的加减乘除，以及更高级的数学函数操作。以下是一些常用的数学运算方法：</p><ul><li><strong>绝对值（abs）</strong>：返回一个数的绝对值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：10</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>最大值（max）</strong> 和 <strong>最小值（min）</strong>：返回一组数中的最大值和最小值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">5</span>]</span><br><span class="line">max_value = <span class="built_in">max</span>(numbers)</span><br><span class="line">min_value = <span class="built_in">min</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(max_value, min_value)  <span class="comment"># 输出：8 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>四舍五入（round）</strong>：对一个数进行指定精度的四舍五入操作。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">round</span>(<span class="number">3.14159</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：3.14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>幂运算（</strong>）**：对一个数进行任意次幂的计算。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="number">2</span> ** <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：8</span></span><br></pre></td></tr></table></figure><h2 id="2-随机数生成"><a href="#2-随机数生成" class="headerlink" title="2. 随机数生成"></a>2. 随机数生成</h2><p>Python中的random模块提供了丰富的随机数生成函数，可以满足各种需求。以下是一些随机数生成的常用方法：</p><ul><li><strong>生成随机整数</strong>：使用 <code>randint</code> 函数生成指定范围内的随机整数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">result = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：介于1和100之间的随机整数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>生成随机浮点数</strong>：使用 <code>uniform</code> 函数生成指定范围内的随机浮点数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">result = random.uniform(<span class="number">1.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：介于1.0和5.0之间的随机浮点数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>从列表中随机选择</strong>：使用 <code>choice</code> 函数从列表中随机选择一个元素。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>, <span class="string">&quot;date&quot;</span>, <span class="string">&quot;elderberry&quot;</span>]</span><br><span class="line">result = random.choice(fruits)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：列表中的某个随机水果</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-进制转换"><a href="#3-进制转换" class="headerlink" title="3. 进制转换"></a>3. 进制转换</h2><p>在Python中，我们可以进行不同进制的数值转换，例如二进制、八进制和十六进制。以下是一些进制转换的常用方法：</p><ul><li><strong>十进制转二进制</strong>：使用 <code>bin</code> 函数将十进制数转换为二进制数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">bin</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：0b1010</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>十进制转八进制</strong>：使用 <code>oct</code> 函数将十进制数转换为八进制数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">oct</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：0o12</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><strong>十进制转十六进制</strong>：使用 <code>hex</code> 函数将十进制数转换为十六进制数。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = <span class="built_in">hex</span>(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出：0xa</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程基础指南</title>
      <link href="/posts/10532.html"/>
      <url>/posts/10532.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Python的特点"><a href="#1-Python的特点" class="headerlink" title="1. Python的特点"></a>1. Python的特点</h2><p>Python具有许多令人惊叹的特点，这也使它成为众多开发者钟爱的编程语言之一：</p><ul><li><strong>简单明了</strong>：Python拥有优雅的语法和简单的代码结构，易于学习和理解。</li><li><strong>高效易用</strong>：Python具有丰富的内置库和第三方库，可以帮助你快速开发优质的应用程序。</li><li><strong>跨平台</strong>：Python可以在不同操作系统（如Windows、Mac和Linux）上运行，具有良好的可移植性。</li><li><strong>多样性</strong>：无论是Web开发、数据科学、人工智能还是物联网，Python都具备广泛的应用领域。</li><li><strong>社区活跃</strong>：Python拥有庞大而活跃的开源社区，在解决问题和获取支持方面非常有帮助。</li></ul><h2 id="2-数据类型与变量"><a href="#2-数据类型与变量" class="headerlink" title="2. 数据类型与变量"></a>2. 数据类型与变量</h2><p>在Python中，你可以使用不同的数据类型来存储和操作数据。以下是一些常见的数据类型示例：</p><ul><li><strong>整数（int）</strong>：表示整数，如 <code>10</code> 和 <code>-5</code>。</li><li><strong>浮点数（float）</strong>：表示带有小数点的数，如 <code>3.14</code> 和 <code>-2.5</code>。</li><li><strong>字符串（string）</strong>：表示文本数据，用引号括起来，如 <code>&quot;Hello, World!&quot;</code>。</li><li><strong>布尔值（bool）</strong>：表示真（True）或假（False）的值，用于逻辑判断。</li></ul><p>你可以声明变量来存储这些数据，并通过简单的赋值语句进行操作。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明整数变量</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明浮点数变量</span></span><br><span class="line">salary = <span class="number">2500.50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明字符串变量</span></span><br><span class="line">name = <span class="string">&quot;John Doe&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明布尔值变量</span></span><br><span class="line">is_student = <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="3-控制流程与循环"><a href="#3-控制流程与循环" class="headerlink" title="3. 控制流程与循环"></a>3. 控制流程与循环</h2><p>编写程序时，我们需要根据特定的条件执行不同的代码块，或者重复执行某些代码。Python提供了条件语句和循环语句，用于控制程序的流程。</p><ul><li><strong>条件语句（if-elif-else）</strong>：根据条件的真假执行不同的代码块。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄判断条件</span></span><br><span class="line">age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断年龄范围并输出相应的消息</span></span><br><span class="line"><span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未成年人&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> age &gt;= <span class="number">18</span> <span class="keyword">and</span> age &lt; <span class="number">65</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;成年人&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;老年人&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>循环语句</strong>：重复执行一段代码，直到满足特定条件。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用for循环打印列表中的元素</span></span><br><span class="line">fruits = [<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;cherry&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="built_in">print</span>(fruit)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 使用while循环计算数字之和</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt;= <span class="number">10</span>:</span><br><span class="line">    total += i</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数字之和:&quot;</span>, total)</span><br></pre></td></tr></table></figure><h2 id="4-函数和模块"><a href="#4-函数和模块" class="headerlink" title="4. 函数和模块"></a>4. 函数和模块</h2><p>函数和模块是组织和重复使用代码的重要方式。通过定义函数，你可以将一段逻辑封装起来，并在需要时进行调用。模块是一个包含Python代码的文件，可以包含函数、类和变量等。</p><ul><li><strong>函数</strong>：使用 <code>def</code> 关键字定义函数，并指定输入参数和返回值。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两个数的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><ul><li><strong>模块</strong>：创建.py文件，将相关的函数和代码放在其中，并通过 <code>import</code> 语句引入到其他程序中使用。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入自定义的模块</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用模块中的函数</span></span><br><span class="line">result = my_module.add_numbers(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;结果:&quot;</span>, result)</span><br></pre></td></tr></table></figure><h2 id="5-学习资源和进一步探索"><a href="#5-学习资源和进一步探索" class="headerlink" title="5. 学习资源和进一步探索"></a>5. 学习资源和进一步探索</h2><p>要掌握Python编程，只有阅读本篇博客远远不够。以下是一些推荐的Python学习资源：</p><ul><li><a href="https://docs.python.org/3/">Python官方文档</a>：Python官方文档是最权威的参考资料，包含语言的详细说明和示例代码。</li><li><a href="https://www.learnpython.org/">Python教程</a>：LearnPython.org提供交互式的Python教程，适用于初学者和有经验的开发者。</li><li><a href="https://www.python.org/community/">Python编程社区</a>：参与Python开源社区，与其他开发者交流和分享经验。</li></ul><p>祝贺你迈出了学习Python编程的第一步！通过不断学习、实践和应用，你将成为一名熟练的Python开发人员，创造出令人惊叹的应用和解决方案。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python编程规范</title>
      <link href="/posts/25565.html"/>
      <url>/posts/25565.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>编写高质量的Python代码是至关重要的。清晰、一致和易读的代码能够提高代码质量和可维护性，并且有助于加快开发速度。本篇博客将介绍一些重要的Python编程规范及最佳实践，帮助你写出优雅、高效的Python代码。</p><h2 id="1-代码格式化"><a href="#1-代码格式化" class="headerlink" title="1. 代码格式化"></a>1. 代码格式化</h2><p>良好的代码格式化可以增强代码的可读性，使其易于理解和维护。遵循以下代码格式化规范：</p><ul><li>使用四个空格缩进。避免使用制表符，因为不同编辑器中制表符的宽度可能不同。</li><li>每行代码不超过79个字符。可以使用括号换行或反斜杠换行进行长表达式的拆分。</li><li>使用空行分隔函数和类定义、函数内部的逻辑块以及不同功能的代码块。</li><li>在二元运算符前后使用空格，以增加可读性。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    result = a + b</span><br><span class="line">    <span class="keyword">if</span> result &gt; <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="2-命名规范"><a href="#2-命名规范" class="headerlink" title="2. 命名规范"></a>2. 命名规范</h2><p>良好的命名规范能够让你的代码更易读，并提供更多的信息。遵循以下命名规范：</p><ul><li>使用有描述性的变量和函数名。避免使用单个字符或缩写。</li><li>使用小写字母和下划线分隔的命名方式，例如 <code>my_variable</code>。</li><li>对于常量，使用全大写字母和下划线的命名方式，例如 <code>PI = 3.14</code>。</li><li>类名使用驼峰命名方式，首字母大写，例如 <code>MyClass</code>。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_variable = <span class="number">10</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">width, height</span>):</span><br><span class="line">    <span class="keyword">return</span> width * height</span><br></pre></td></tr></table></figure><h2 id="3-注释和文档"><a href="#3-注释和文档" class="headerlink" title="3. 注释和文档"></a>3. 注释和文档</h2><p>清晰明了的注释和文档能够提供代码的可读性和可维护性。遵循以下注释和文档规范：</p><ul><li>在代码中使用注释来解释代码的意图、设计思路等。</li><li>对于复杂的功能或重要的函数，使用文档字符串(Docstrings)来提供详细的函数说明。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算两个数的和</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_numbers</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算两个数的和</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        a (int): 第一个数</span></span><br><span class="line"><span class="string">        b (int): 第二个数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        int: 两个数的和</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><h2 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h2><p>优秀的异常处理能够提高代码的鲁莽性和可靠性。以下是一些建议：</p><ul><li>只捕获你能够处理的特定异常类型，避免捕获所有异常。</li><li>使用 <code>try-except-else</code> 结构，将可能引发异常的部分放在 <code>try</code> 块中，处理异常的逻辑放在 <code>except</code> 块中，<code>try-except-else</code>结构能清晰地分离正常逻辑和异常处理逻辑。</li><li>在适当的地方引发自定义异常以提高代码的可读性和可维护性。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = calculate_division(a, b)</span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;除数不能为零&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;计算结果:&quot;</span>, result)</span><br></pre></td></tr></table></figure><h2 id="5-模块和包管理"><a href="#5-模块和包管理" class="headerlink" title="5. 模块和包管理"></a>5. 模块和包管理</h2><p>模块和包是组织和管理代码的重要组成部分。以下是一些最佳实践：</p><ul><li>在每个文件的开头使用 <code>import</code> 语句导入模块，并按一定的顺序分组导入语句。</li><li>对于长的模块名或重复使用的模块，请使用 <code>import ... as ...</code> 语句进行简化，但确保名称仍然有意义。</li><li>使用 <code>__init__.py</code> 文件来将文件夹转换为包，并在其中添加必要的初始化代码。</li><li>使用虚拟环境和包管理工具（例如pip）来管理项目的依赖关系。</li></ul><p>参考资料：</p><ul><li>PEP 8 – Python编码风格指南：<a href="https://www.python.org/dev/peps/pep-0008/">https://www.python.org/dev/peps/pep-0008/</a></li><li>Google Python编程风格指南：<a href="https://google.github.io/styleguide/pyguide.html">https://google.github.io/styleguide/pyguide.html</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特殊关键字编程：解锁Python高级功能</title>
      <link href="/posts/29232.html"/>
      <url>/posts/29232.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>我们在日常Python开发中经常会遇到一些特殊写法关键字，它们在语言中扮演着重要的角色。本篇博客将系统地介绍Python中常见的特殊写法关键字，包括其使用方法以及常见的应用场景。通过本文的阅读，你将更加深入地理解这些特殊写法关键字，并能够运用它们来编写更加优雅和高效的Python代码。</p><h2 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h2><p><code>yield</code>是Python中的一个关键字，用于定义生成器函数。生成器函数是一种特殊的函数，它可以生成一个可迭代对象，并且可以在每次迭代中返回一个值。</p><p>生成器函数使用 <code>yield</code> 语句来返回一个值，并暂停函数的执行，保存当前状态。在下一次迭代时，生成器函数将从上一次暂停的位置继续执行，直到遇到下一个 <code>yield</code> 语句。</p><p>以下是使用 <code>yield</code> 的几种常见用法：</p><ol><li><p>创建生成器函数</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count_up_to</span>(<span class="params">n</span>):</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = count_up_to(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(numbers))  <span class="comment"># 输出: [0, 1, 2, 3, 4, 5]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个例子中，我们定义了一个生成器函数 <code>count_up_to</code>，它从0开始逐步计数，并使用 <code>yield</code> 语句返回每个计数值。通过调用 <code>count_up_to(5)</code>，我们创建了一个生成器对象 <code>numbers</code>，然后使用 <code>list()</code> 函数将其转换为列表。</p></li><li><p>惰性求值</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>():</span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fib = fibonacci()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(fib))  <span class="comment"># 输出: 0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(fib))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(fib))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(fib))  <span class="comment"># 输出: 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个例子中，我们定义了一个斐波那契数列的生成器函数 <code>fibonacci</code>。每次调用 <code>next(fib)</code> 时，生成器函数将生成下一个斐波那契数，并在函数的 <code>yield</code> 语句处暂停。这种惰性求值的方式可以节省内存，因为它只在需要时才生成下一个值。</p><p> 需要注意的是，生成器函数的执行是延迟的，即在调用 <code>next()</code> 或使用循环迭代时才会触发生成器函数的执行。</p><p> <code>yield</code> 语句用于在生成器函数中返回值，并且可以在函数的执行过程中多次使用，每次调用 <code>next()</code> 都会到达下一个 <code>yield</code> 语句。这种能够保存函数的状态并继续执行的特性使生成器函数非常强大且灵活。</p><p> 生成器函数和 <code>yield</code> 的用法可以用来处理大型数据集、无限序列或需要逐个返回结果的计算，以及许多其他需要延迟执行和节省内存的情况。</p></li></ol><h2 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h2><p><code>lambda</code> 是Python中的一个关键字，用于创建匿名函数（即没有函数名的函数）。 lambda 函数在简单的情况下可以用来替代定义常规函数的方式。</p><p>基本语法格式为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li><code>arguments</code> 是传递给 lambda 函数的参数，可以是零个或多个参数，用逗号分隔。</li><li><code>expression</code> 是 lambda 函数的主体，代表了函数要执行的操作，并且返回一个表达式的结果。</li></ul><p>以下是一些使用 lambda 函数的示例：</p><ol><li><p>简单的 lambda 函数：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">5</span>, <span class="number">3</span>))  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><p> 在上述示例中，我们定义了一个 lambda 函数 <code>add</code>，它接受两个参数 <code>x</code> 和 <code>y</code>，并返回它们的和。</p></li><li><p>作为高阶函数的参数：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers))</span><br><span class="line"><span class="built_in">print</span>(squared_numbers)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个例子中，我们使用了 <code>map</code> 函数和 lambda 函数来对列表中的每个元素进行平方操作。</p></li><li><p>作为排序函数的关键字：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;David&quot;</span>]</span><br><span class="line">sorted_names = <span class="built_in">sorted</span>(names, key=<span class="keyword">lambda</span> x: <span class="built_in">len</span>(x))</span><br><span class="line"><span class="built_in">print</span>(sorted_names)  <span class="comment"># 输出: [&#x27;Bob&#x27;, &#x27;Alice&#x27;, &#x27;David&#x27;, &#x27;Charlie&#x27;]</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个例子中，我们使用了 <code>sorted</code> 函数和 lambda 函数作为排序的关键字，按照名字的长度进行排序。</p><p> 需要注意的是，尽管 lambda 函数可以简化代码，但请注意适当使用。对于复杂的函数逻辑，建议使用常规的函数定义来提高代码的可读性和可维护性。</p><p> 在某些情况下，lambda 函数可能并不是最佳选择，例如需要在函数内部保存状态或执行多个语句的情况下。在这些情况下，还是应该使用常规的命名函数来实现。</p></li></ol><h2 id="with"><a href="#with" class="headerlink" title="with"></a>with</h2><p><code>with</code> 关键字常用于文件操作或资源管理中，它能够创建一个运行时上下文，并自动管理资源的初始化和释放。以下是一个文件操作的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;example.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>with</code> 关键字自动管理文件资源的打开和关闭，无需显式调用 <code>file.close()</code>。</p><h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><p><code>assert</code> 是Python中的一个关键字，用于编写断言语句。断言是一种用于在代码中检查条件是否满足的方式，如果断言条件为假，则会引发 <code>AssertionError</code> 异常。</p><p>基本语法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> condition, message</span><br></pre></td></tr></table></figure><ul><li><code>condition</code> 是一个布尔表达式，表示要检查的条件。</li><li><code>message</code> 是一个可选参数，用于在断言失败时提供一条错误消息。</li></ul><p>下面是几种常见的使用情景：</p><ol><li><p>检查函数参数：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">assert</span> b != <span class="number">0</span>, <span class="string">&quot;除数不能为0&quot;</span></span><br><span class="line">    <span class="keyword">return</span> a / b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 输出: 5.0</span></span><br><span class="line"><span class="built_in">print</span>(divide(<span class="number">10</span>, <span class="number">0</span>))  <span class="comment"># 引发 AssertionError: 除数不能为0</span></span><br></pre></td></tr></table></figure><p> 在上面的例子中，我们在 <code>divide</code> 函数内部使用断言来确保除数 <code>b</code> 不为零。如果除数是零，就会触发断言失败并抛出错误消息。</p></li><li><p>检查程序状态：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = -<span class="number">5</span></span><br><span class="line"><span class="keyword">assert</span> num &gt; <span class="number">0</span>, <span class="string">&quot;num必须大于0&quot;</span> <span class="comment"># 引发 AssertionError: num必须大于0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在此示例中，我们使用断言来检查变量 <code>num</code> 是否为正数。如果 <code>num</code> 不满足条件，将引发断言失败。</p></li><li><p>检查预期结果：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expected_result = <span class="number">42</span></span><br><span class="line">actual_result = <span class="number">40</span></span><br><span class="line"><span class="keyword">assert</span> actual_result == expected_result, <span class="string">f&quot;预期结果为<span class="subst">&#123;expected_result&#125;</span>，实际结果为<span class="subst">&#123;actual_result&#125;</span>&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在这个示例中，我们使用断言来检查实际结果与预期结果是否相等。如果结果不匹配，断言将失败并提供相关的错误消息。</p></li></ol><p>注意事项：</p><ul><li>断言语句在生产环境中应谨慎使用，主要用于开发和调试阶段。</li><li>断言不应该用于处理预期可能发生的错误或异常情况。适当的错误处理机制应在实际代码中实现。</li></ul><p><code>assert</code> 语句是一种有用的调试工具，它可以帮助您发现代码中的错误和逻辑问题。但请记住，在生产环境中，确保代码的正确性是您的责任，应使用适当的错误处理机制来处理各种异常情况。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串操作大全</title>
      <link href="/posts/3294.html"/>
      <url>/posts/3294.html</url>
      
        <content type="html"><![CDATA[<p>在Python中，字符串是一种常用的数据类型，具有丰富的功能和操作方法。本篇将探讨Python中字符串的一些常用方法，包括字符串的创建、拼接、格式化、截取等操作，希望能够帮助大家更好地运用字符串处理相关的问题。</p><h2 id="字符串的创建"><a href="#字符串的创建" class="headerlink" title="字符串的创建"></a>字符串的创建</h2><p>首先，让我们看看如何创建字符串。在Python中，可以使用单引号、双引号或三重引号来创建字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用单引号</span></span><br><span class="line">str1 = <span class="string">&#x27;Hello, Python!&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用双引号</span></span><br><span class="line">str2 = <span class="string">&quot;Hello, Python!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用三重引号创建多行字符串</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;Hello,</span></span><br><span class="line"><span class="string">Python!&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p>字符串拼接是常见的操作之一，Python提供了多种方式来连接字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用加号进行字符串拼接</span></span><br><span class="line">result1 = <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot; &quot;</span> + <span class="string">&quot;World&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用format方法格式化字符串</span></span><br><span class="line">result2 = <span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用f-string进行字符串插值</span></span><br><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">result3 = <span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><p>除了拼接字符串，Python还提供了多种格式化字符串的方式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用百分号占位符</span></span><br><span class="line">age = <span class="number">25</span></span><br><span class="line">result1 = <span class="string">&quot;I am %d years old&quot;</span> % age</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用format方法进行格式化</span></span><br><span class="line">result2 = <span class="string">&quot;My favorite color is &#123;0&#125;&quot;</span>.<span class="built_in">format</span>(<span class="string">&quot;blue&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用f-string进行格式化</span></span><br><span class="line">name = <span class="string">&quot;Bob&quot;</span></span><br><span class="line">age = <span class="number">30</span></span><br><span class="line">result3 = <span class="string">f&quot;His name is <span class="subst">&#123;name&#125;</span>, and he is <span class="subst">&#123;age&#125;</span> years old&quot;</span></span><br></pre></td></tr></table></figure><h2 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h2><p>对于字符串的截取也是经常会遇到的操作，Python中可以使用下标来截取子串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">result = str1[<span class="number">7</span>:]  <span class="comment"># 截取从第七个字符到末尾的子串</span></span><br></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a><code>replace()</code></h3><p><code>replace()</code> 函数用于替换字符串中的指定子串为新的子串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">new_str = str1.replace(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;Hi&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_str)  <span class="comment"># 输出: Hi, World!</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>replace()</code> 函数将字符串中的 “Hello” 替换为 “Hi”。</p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>还可以使用 <code>re</code> 模块中的函数结合正则表达式进行字符串替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;Hello, Python!&quot;</span></span><br><span class="line">new_str = re.sub(<span class="string">r&#x27;[aeiou]&#x27;</span>, <span class="string">&#x27;*&#x27;</span>, str1)</span><br><span class="line"><span class="built_in">print</span>(new_str)  <span class="comment"># 输出: &quot;H*ll*, Pyth*n!&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>re.sub()</code> 函数使用正则表达式 <code>[aeiou]</code> 匹配字符串中的元音字母，并将其替换为星号。</p><h3 id="translate"><a href="#translate" class="headerlink" title="translate()"></a><code>translate()</code></h3><p><code>translate()</code> 函数可以根据指定的字符映射表进行字符替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello, Python!&quot;</span></span><br><span class="line">table = str1.maketrans(<span class="string">&quot;aeiou&quot;</span>, <span class="string">&quot;12345&quot;</span>)</span><br><span class="line">new_str = str1.translate(table)</span><br><span class="line"><span class="built_in">print</span>(new_str)  <span class="comment"># 输出: H2ll4, Pyth4n!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>translate()</code> 函数使用 <code>maketrans()</code> 方法创建一个字符映射表，然后将字符串中的元音字母替换为数字。</p><h2 id="剔除指定字符"><a href="#剔除指定字符" class="headerlink" title="剔除指定字符"></a>剔除指定字符</h2><h3 id="strip-lstrip-rstrip"><a href="#strip-lstrip-rstrip" class="headerlink" title="strip(), lstrip(), rstrip()"></a><code>strip()</code>, <code>lstrip()</code>, <code>rstrip()</code></h3><p><code>strip()</code> 函数用于去除字符串首尾的指定字符，默认去除空格。<code>lstrip()</code> 和 <code>rstrip()</code> 函数分别用于去除字符串左侧和右侧的指定字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;   Hello, World!   &quot;</span></span><br><span class="line">new_str = str1.strip()</span><br><span class="line"><span class="built_in">print</span>(new_str)  <span class="comment"># 输出: &quot;Hello, World!&quot;</span></span><br><span class="line"></span><br><span class="line">str1 = <span class="string">&quot;-------Hello, World!-------&quot;</span></span><br><span class="line">new_str = str1.lstrip(<span class="string">&quot;-&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_str)  <span class="comment"># 输出: &quot;Hello, World!-------&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>strip()</code> 函数去除了字符串首尾的空格，而 <code>strip(&quot;-&quot;)</code> 去除了字符串左右两侧的连字符。</p><h2 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h2><p>此外，Python字符串还具有许多其他常用方法，比如查找子串、替换子串、转换大小写等操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找子串</span></span><br><span class="line">str1 = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">index = str1.index(<span class="string">&quot;World&quot;</span>)  <span class="comment"># 返回子串的索引</span></span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大小写转换</span></span><br><span class="line">upper_str = str1.upper()</span><br><span class="line">lower_str = str1.lower()</span><br><span class="line"><span class="built_in">print</span>(upper_str, <span class="string">&#x27;-&#x27;</span>, lower_str)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>time：玩转时间魔法</title>
      <link href="/posts/4274.html"/>
      <url>/posts/4274.html</url>
      
        <content type="html"><![CDATA[<h2 id="time模块简介"><a href="#time模块简介" class="headerlink" title="time模块简介"></a>time模块简介</h2><p>time模块是Python标准库中的核心模块之一，它提供了丰富的函数和方法，用于对时间进行操作和管理。无论是计时、延时、时间戳转换，还是时间格式化，time模块都能满足你的需求。</p><h2 id="常用方法举例说明"><a href="#常用方法举例说明" class="headerlink" title="常用方法举例说明"></a>常用方法举例说明</h2><h3 id="获取当前时间戳-time"><a href="#获取当前时间戳-time" class="headerlink" title="获取当前时间戳 - time()"></a>获取当前时间戳 - time()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">current_timestamp = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间戳：&quot;</span>, current_timestamp)</span><br></pre></td></tr></table></figure><h3 id="将时间戳转换为时间元组-localtime"><a href="#将时间戳转换为时间元组-localtime" class="headerlink" title="将时间戳转换为时间元组 - localtime()"></a>将时间戳转换为时间元组 - localtime()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time_tuple = time.localtime(time.time())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前时间元组：&quot;</span>, time_tuple)</span><br></pre></td></tr></table></figure><h3 id="将时间元组转换为可读性更强的字符串格式-strftime"><a href="#将时间元组转换为可读性更强的字符串格式-strftime" class="headerlink" title="将时间元组转换为可读性更强的字符串格式 - strftime()"></a>将时间元组转换为可读性更强的字符串格式 - strftime()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;格式化后的时间：&quot;</span>, formatted_time)</span><br></pre></td></tr></table></figure><h3 id="让程序休眠指定的时间-sleep"><a href="#让程序休眠指定的时间-sleep" class="headerlink" title="让程序休眠指定的时间 - sleep()"></a>让程序休眠指定的时间 - sleep()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序开始执行&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 程序休眠5秒</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序执行结束&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="计算程序执行时间-perf-counter"><a href="#计算程序执行时间-perf-counter" class="headerlink" title="计算程序执行时间 - perf_counter()"></a>计算程序执行时间 - perf_counter()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序开始执行&quot;</span>)</span><br><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 程序休眠5秒</span></span><br><span class="line">end_time = time.perf_counter()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序执行结束，共用时：%.2f秒&quot;</span> % (end_time - start_time))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Python和Selenium打造你的Web自动化之旅</title>
      <link href="/posts/21220.html"/>
      <url>/posts/21220.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Selenium？"><a href="#什么是Selenium？" class="headerlink" title="什么是Selenium？"></a>什么是Selenium？</h2><p>Selenium是一个开源的Web应用程序测试框架，它可以使用多种编程语言（包括Python）来模拟用户与浏览器的交互。它提供了丰富的功能，包括启动浏览器会话、导航到URL、查找和操作页面元素等。</p><h2 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h2><p>在使用Selenium之前，我们需要保证正确安装和配置所需的软件和驱动程序。以下是必要的步骤：</p><ol><li><p>安装Python：由于Selenium是一个Python模块，首先需要安装Python。您可以从<a href="https://www.python.org/downloads/">Python官方网站</a>下载并安装适合您操作系统的版本。</p></li><li><p>安装Selenium模块：使用Python的包管理器（如pip）安装Selenium模块。在命令行中执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install selenium</span><br></pre></td></tr></table></figure></li><li><p>下载浏览器驱动程序：为了使用Selenium控制浏览器，我们需要下载相应的浏览器驱动程序，并将其添加到系统的PATH环境变量中。以下是常用浏览器驱动程序的下载链接：</p><ul><li><a href="https://registry.npmmirror.com/binary.html?path=chromedriver/">Chrome驱动程序（114及以下）</a></li><li><a href="https://googlechromelabs.github.io/chrome-for-testing/">Chrome驱动程序（最新版本）</a></li><li><a href="https://github.com/mozilla/geckodriver/releases">Firefox驱动程序</a></li><li><a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver/">Edge驱动程序</a></li></ul><p>注意：下载相应版本的驱动程序，并确保与所使用的浏览器版本匹配。</p></li><li><p>配置Selenium使用的浏览器驱动程序：在Python代码中，我们需要指定Selenium使用哪个浏览器驱动程序。以下是一个示例代码，展示如何配置Chrome浏览器驱动程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 指定Chrome驱动程序路径</span></span><br><span class="line"> chromedriver_path = <span class="string">r&quot;C:\Users\Administrator\AppData\Local\Google\Chrome\Application\chromedriver.exe&quot;</span></span><br><span class="line"> <span class="comment"># 启动浏览器</span></span><br><span class="line"> driver = webdriver.Chrome()</span><br><span class="line"> <span class="comment"># 窗口最大化</span></span><br><span class="line"> driver.maximize_window()</span><br><span class="line"> <span class="comment"># 访问网址</span></span><br><span class="line"> driver.get(<span class="string">&quot;https://baidu.com/&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意：请根据实际驱动程序的路径进行配置。</p></li></ol><h2 id="常用方法举例"><a href="#常用方法举例" class="headerlink" title="常用方法举例"></a>常用方法举例</h2><h3 id="查找页面元素"><a href="#查找页面元素" class="headerlink" title="查找页面元素"></a>查找页面元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过XPath查找元素</span></span><br><span class="line">input_element = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过CSS Selector查找元素</span></span><br><span class="line">button = driver.find_element_by_css_selector(<span class="string">&#x27;#su&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过class查找元素</span></span><br><span class="line"><span class="comment"># 如果class中带空格请切换其他方式 或者 选择唯一的class</span></span><br><span class="line">button1 = driver.find_element_by_class_name(<span class="string">&#x27;s_btn&#x27;</span>)</span><br><span class="line"><span class="comment"># 通过ID查找元素</span></span><br><span class="line">button2 = driver.find_element_by_id(<span class="string">&#x27;su&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="操作页面元素"><a href="#操作页面元素" class="headerlink" title="操作页面元素"></a>操作页面元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">input_element = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;kw&quot;]&#x27;</span>)</span><br><span class="line"><span class="comment"># 操作输入框并输入文字</span></span><br><span class="line">input_element.send_keys(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟键盘操作（按下回车键）</span></span><br><span class="line"><span class="comment"># from selenium.webdriver.common.keys import Keys</span></span><br><span class="line"><span class="comment"># input_element.send_keys(Keys.ENTER)</span></span><br><span class="line"></span><br><span class="line">button = driver.find_element_by_css_selector(<span class="string">&#x27;#su&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击按钮</span></span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure><h3 id="等待页面加载"><a href="#等待页面加载" class="headerlink" title="等待页面加载"></a>等待页面加载</h3><p>在Selenium中，等待网页加载完成是非常重要的，以确保在执行后续操作之前，页面的所有元素已经完全加载。以下是几种常用的等待网页加载的处理方式：</p><ol><li><p>强制等待：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)  <span class="comment"># 等待5秒钟</span></span><br></pre></td></tr></table></figure><p> 这种方式是最简单粗暴的等待方式，但不推荐在实际使用中过多地使用，因为它没有考虑到页面加载速度的变化和异步加载的情况。</p></li><li><p>隐式等待：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序开始执行：&quot;</span>, formatted_time)</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.cheneyblog.com&quot;</span>)</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;隐士等待开始：&quot;</span>, formatted_time)</span><br><span class="line">driver.implicitly_wait(<span class="number">10</span>)  <span class="comment"># 设置隐式等待时间为10秒</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;blog-info&quot;]/a/img&#x27;</span>)</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;找到对于标签：&quot;</span>, formatted_time)</span><br><span class="line">driver.close()</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序结束：&quot;</span>, formatted_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 隐式等待会在查找元素时等待一定的时间，如果元素存在则立即返回，如果超过了设定的等待时间，仍没有找到元素，则会抛出异常。<br> 缺点：一旦设置了隐式等待，则它存在整个 WebDriver 对象实例的声明周期中，它将会在寻找每个element的时候都进行等待，这样会增加整个测试执行的时间。</p></li><li><p>显式等待：</p><p> 显式等待是一种更灵活、更高级的等待方式，可以在指定条件满足或超时之前持续等待。它使用 <code>ExpectedConditions</code> 类来定义等待条件。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序开始执行：&quot;</span>, formatted_time)</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(<span class="string">&quot;https://www.cheneyblog.com&quot;</span>)</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;显示等待开始：&quot;</span>, formatted_time)</span><br><span class="line"><span class="comment"># 设置最长等待时间为10秒</span></span><br><span class="line">wait = WebDriverWait(driver, <span class="number">10</span>)</span><br><span class="line">driver.maximize_window()</span><br><span class="line"><span class="comment"># 等待元素可见</span></span><br><span class="line">element = wait.until(EC.visibility_of_element_located((By.XPATH, <span class="string">&#x27;//*[@id=&quot;blog-info&quot;]/a/img&#x27;</span>)))</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;找到对于标签：&quot;</span>, formatted_time)</span><br><span class="line">driver.close()</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, time.localtime())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;程序结束：&quot;</span>, formatted_time)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 在上面的代码中，我们使用 <code>WebDriverWait</code> 类来指定等待时间，并将其传递给 <code>until</code> 方法。在 <code>until</code> 方法中，我们使用 <code>ExpectedConditions</code> 类中的 <code>visibility_of_element_located</code> 方法来定义等待条件，即等待元素可见。</p><p> 使用显式等待可以进行更精细的控制，例如等待元素可用、可点击、存在等等，可以根据项目需求进行灵活设置。</p><table><thead><tr><th>条件名称</th><th>描述</th></tr></thead><tbody><tr><td><code>title_is</code></td><td>根据页面的标题判断等待条件是否成立。</td></tr><tr><td><code>title_contains</code></td><td>根据页面的标题是否包含指定的字符串判断等待条件是否成立。</td></tr><tr><td><code>presence_of_element_located</code></td><td>根据元素定位器是否在DOM中出现判断等待条件是否成立。</td></tr><tr><td><code>visibility_of_element_located</code></td><td>根据元素定位器是否在DOM中可见判断等待条件是否成立。</td></tr><tr><td><code>visibility_of</code></td><td>根据元素是否可见判断等待条件是否成立。</td></tr><tr><td><code>text_to_be_present_in_element</code></td><td>根据元素中是否包含指定文本判断等待条件是否成立。</td></tr><tr><td><code>text_to_be_present_in_element_value</code></td><td>根据元素的value属性中是否包含指定文本判断等待条件是否成立。</td></tr><tr><td><code>frame_to_be_available_and_switch_to_it</code></td><td>根据frame是否可用判断等待条件是否成立，并在切换到frame。</td></tr><tr><td><code>element_to_be_clickable</code></td><td>根据元素是否可点击判断等待条件是否成立。</td></tr><tr><td><code>element_selection_state_to_be</code></td><td>根据元素选择状态是否满足指定条件判断等待条件是否成立。</td></tr><tr><td><code>element_located_selection_state_to_be</code></td><td>根据元素选择状态是否满足指定条件判断等待条件是否成立。</td></tr><tr><td><code>alert_is_present</code></td><td>判断页面上是否存在alert弹窗。</td></tr></tbody></table></li></ol><p>这些判断条件可以根据实际需求来选择使用，例如等待页面标题、元素的出现、元素可见性、元素文本包含等等。通过合理使用这些等待条件，可以确保在执行后续操作之前，页面或元素已经加载或满足特定条件，提高测试或自动化任务的稳定性和准确性。</p><blockquote><p>所有等待都是等页面加载完成(浏览器标签左上角圈圈不再转)才开始执行，当页面某些 js无法加载，但是想找的element已经出来了，它还是不会执行下面的代码，直到页面加载完成，才会执行等待。</p></blockquote><h3 id="标签页切换"><a href="#标签页切换" class="headerlink" title="标签页切换"></a>标签页切换</h3><h4 id="1-获取当前窗口句柄"><a href="#1-获取当前窗口句柄" class="headerlink" title="1. 获取当前窗口句柄"></a>1. 获取当前窗口句柄</h4><p>在切换标签页之前，首先需要获取当前窗口的句柄，也就是窗口的唯一标识。可以通过<code>current_window_handle</code>属性来获取当前窗口句柄：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">current_window_handle = driver.current_window_handle</span><br></pre></td></tr></table></figure><h4 id="2-打开新的标签页"><a href="#2-打开新的标签页" class="headerlink" title="2. 打开新的标签页"></a>2. 打开新的标签页</h4><p>可以通过执行JavaScript来实现在新标签页中打开一个链接：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.execute_script(<span class="string">&quot;window.open(&#x27;http://www.example.com&#x27;,&#x27;_blank&#x27;);&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="3-切换到新打开的窗口"><a href="#3-切换到新打开的窗口" class="headerlink" title="3. 切换到新打开的窗口"></a>3. 切换到新打开的窗口</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取所有窗口句柄</span></span><br><span class="line">all_window_handles = driver.window_handles</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新打开的窗口</span></span><br><span class="line">new_window_handle = [handle <span class="keyword">for</span> handle <span class="keyword">in</span> all_window_handles <span class="keyword">if</span> handle != current_window_handle][<span class="number">0</span>]</span><br><span class="line">driver.switch_to.window(new_window_handle)</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"><span class="comment"># 打开百度</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment"># 获取百度窗口的句柄</span></span><br><span class="line">current_window_handle = driver.current_window_handle</span><br><span class="line"><span class="comment"># 新的标签页中打开淘宝</span></span><br><span class="line">driver.execute_script(<span class="string">&quot;window.open(&#x27;http://www.taobao.com&#x27;,&#x27;_blank&#x27;);&quot;</span>)</span><br><span class="line"><span class="comment"># 获取所有窗口句柄</span></span><br><span class="line">all_window_handles = driver.window_handles</span><br><span class="line"><span class="comment"># 切换到淘宝窗口</span></span><br><span class="line">new_window_handle = [handle <span class="keyword">for</span> handle <span class="keyword">in</span> all_window_handles <span class="keyword">if</span> handle != current_window_handle][<span class="number">0</span>]</span><br><span class="line">driver.switch_to.window(new_window_handle)</span><br><span class="line"></span><br><span class="line">input_element = WebDriverWait(driver, <span class="number">10</span>).until(EC.visibility_of_element_located((By.XPATH, <span class="string">&#x27;//*[@id=&quot;q&quot;]&#x27;</span>)))</span><br><span class="line"><span class="comment"># 操作输入框并输入文字</span></span><br><span class="line">input_element.send_keys(<span class="string">&#x27;键盘&#x27;</span>)</span><br><span class="line"></span><br><span class="line">button = driver.find_element_by_css_selector(<span class="string">&#x27;#J_TSearchForm &gt; div.search-button &gt; button&#x27;</span>)</span><br><span class="line"><span class="comment"># 点击搜索</span></span><br><span class="line">button.click()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们首先打开百度页面并获取当前窗口句柄，然后在新的标签页中打开淘宝页面，接着切换到新打开的淘宝标签页，并在淘宝标签页中搜索键盘。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XPath表达式：精准定位文档节点</title>
      <link href="/posts/53891.html"/>
      <url>/posts/53891.html</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>XML是一种常见的数据交换格式，在Web开发中，我们经常需要解析和操作XML数据。XPath作为一种强大的查询语言，可以帮助我们以简洁、精确的方式定位和操作XML文档中的节点。本文将详细介绍XPath的常用方法，并通过生动的示例让你轻松掌握XPath的精髓。</p><h2 id="XPath-基础语法"><a href="#XPath-基础语法" class="headerlink" title="XPath 基础语法"></a>XPath 基础语法</h2><p>XPath使用一种路径表达式（Path Expression）来定位XML文档中的节点。下面是XPath的基本语法：</p><ul><li><code>/</code>：从根节点开始选取。例如：<code>/bookstore</code>，表示选取根节点下的<code>bookstore</code>节点。</li><li><code>//</code>：从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。例如：<code>//book</code>，表示选取文档中的所有<code>book</code>节点。</li><li><code>.</code>：选取当前节点。例如：<code>./title</code>，表示选取当前节点下的<code>title</code>节点。</li><li><code>..</code>：选取当前节点的父节点。例如：<code>../author</code>，表示选取当前节点的父节点下的<code>author</code>节点。</li><li><code>@</code>：选取属性。例如：<code>//@lang</code>，表示选取文档中的所有<code>lang</code>属性。</li></ul><p>接下来，我们将通过示例来演示这些基本语法的用法。</p><h2 id="例子1：选取节点"><a href="#例子1：选取节点" class="headerlink" title="例子1：选取节点"></a>例子1：选取节点</h2><p>假设我们有以下XML文档：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;fiction&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>J.K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;fiction&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>The Hobbit<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>J.R.R. Tolkien<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要选取<code>bookstore</code>节点下的第一个<code>book</code>节点，可以使用以下XPath表达式：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bookstore/book[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>这里的<code>/</code>表示从根节点开始查找，<code>bookstore</code>匹配根节点下的<code>bookstore</code>节点，而<code>book</code>则是它的子节点。使用<code>[1]</code>表示选取第一个匹配的<code>book</code>节点。</p><h2 id="例子2：使用条件选择节点"><a href="#例子2：使用条件选择节点" class="headerlink" title="例子2：使用条件选择节点"></a>例子2：使用条件选择节点</h2><p>下面的XML文档中，我们要选取<code>category</code>为<code>fiction</code>的<code>book</code>节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;fiction&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>J.K. Rowling<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span> <span class="attr">category</span>=<span class="string">&quot;non-fiction&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span>Programming 101<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用以下XPath表达式：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bookstore/book[@category=<span class="string">&#x27;fiction&#x27;</span>]</span><br></pre></td></tr></table></figure><p>这里的<code>[@category=&#39;fiction&#39;]</code>表示选取<code>category</code>属性值等于<code>fiction</code>的<code>book</code>节点。</p><h2 id="例子3：选取多个节点"><a href="#例子3：选取多个节点" class="headerlink" title="例子3：选取多个节点"></a>例子3：选取多个节点</h2><p>在下面的示例中，我们要选取<code>price</code>节点值大于<code>10</code>的<code>book</code>节点：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bookstore</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Book 1<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>12<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Book 2<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>8<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Book 3<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">price</span>&gt;</span>15<span class="tag">&lt;/<span class="name">price</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bookstore</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以使用以下XPath表达式：</p><figure class="highlight xpath"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bookstore/book[price &gt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>这里使用了条件表达式<code>[price &gt; 10]</code>来选取<code>price</code>节点值大于<code>10</code>的<code>book</code>节点。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyQuery：轻松搞定网页解析和数据提取</title>
      <link href="/posts/56711.html"/>
      <url>/posts/56711.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>PyQuery是Python中的HTML/XML解析库，其灵感来自于jQuery。它提供了一种更加Pythonic的方式来操作文档，使得解析和提取数据变得简单而高效。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，确保你已经安装了PyQuery模块。你可以使用pip命令来安装：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pyquery</span><br></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>以下是使用PyQuery解析HTML文档的基本步骤：</p><ol><li><p>导入PyQuery模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br></pre></td></tr></table></figure></li><li><p>创建PyQuery对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">doc = pq(html_doc)</span><br></pre></td></tr></table></figure><p>其中，<code>html_doc</code>是你要解析的HTML文档。</p></li><li><p>使用PyQuery对象进行提取数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择元素</span></span><br><span class="line">element = doc(<span class="string">&#x27;tag&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素文本</span></span><br><span class="line">text = element.text()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取元素属性</span></span><br><span class="line">attribute_value = element.attr(<span class="string">&#x27;attribute&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你还可以使用类似jQuery的选择器语法来选择元素、查找子元素、过滤元素等，非常灵活方便。</p></li></ol><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>假设我们想从一个网页中提取出所有的图片链接和它们的描述文字。下面是使用PyQuery模块实现的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 &quot;</span></span><br><span class="line">                  <span class="string">&quot;Safari/537.36 Edg/120.0.0.0&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送HTTP请求，获取网页内容</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://book.douban.com/&#x27;</span>, headers=header)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;test.html&quot;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(response.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建PyQuery对象</span></span><br><span class="line">doc = pq(filename=<span class="string">&quot;test.html&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有图片链接和描述文字</span></span><br><span class="line">books = []</span><br><span class="line">book_list = doc(<span class="string">&#x27;.more-meta&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> book_list.items():</span><br><span class="line">    title = item(<span class="string">&#x27;.title&#x27;</span>).text()</span><br><span class="line">    author = item(<span class="string">&#x27;.author&#x27;</span>).text()</span><br><span class="line">    year = item(<span class="string">&#x27;.year&#x27;</span>).text()</span><br><span class="line">    publisher = item(<span class="string">&#x27;.publisher&#x27;</span>).text()</span><br><span class="line">    abstract = item(<span class="string">&#x27;.abstract&#x27;</span>).text()</span><br><span class="line">    book_dict = &#123;<span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;author&quot;</span>: author, <span class="string">&quot;year&quot;</span>: year, <span class="string">&quot;publisher&quot;</span>: publisher, <span class="string">&quot;abstract&quot;</span>: abstract&#125;</span><br><span class="line">    books.append(book_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> book <span class="keyword">in</span> books:</span><br><span class="line">    <span class="built_in">print</span>(book)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;散步：罗伯特·瓦尔泽中短篇小说集&#x27;, &#x27;author&#x27;: &#x27;[瑞士]罗伯特·瓦尔泽&#x27;, &#x27;year&#x27;: &#x27;2023-11&#x27;, &#x27;publisher&#x27;: &#x27;广西师范大学出版社&#x27;, &#x27;abstract&#x27;: &#x27;【编辑推荐】 ⭐现代德语文学奠基人罗伯特·瓦尔泽中短篇小说集，精心编选，全新呈现！ 他被誉为 “错过了时间的散步者”“细微之处的洞见者”“命运如雪的诗人”； 他是被埋没的天才作家，一生坚持不懈地为小人物著书立传； 他与穆齐尔、卡夫卡齐名，影响深远，被追认为现代德语文学奠基人。 罗伯特·瓦尔泽——“柏林三部曲”+精选故事集，德语直译，全新译本携手出版！ ...&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;女人味的昨天、今天和明天：宫本百合子随笔集&#x27;, &#x27;author&#x27;: &#x27;[日]宫本百合子&#x27;, &#x27;year&#x27;: &#x27;2023-11&#x27;, &#x27;publisher&#x27;: &#x27;贵州人民出版社&#x27;, &#x27;abstract&#x27;: &#x27;亚洲女性主义先驱，近百年前坚决抵制男凝 “日本的波伏娃”，东亚版《第二性》 刨根问底“女人味”的前世今生，重走女性主义来时路 为古今东西被曲解、被规训的女人们正名 🌊 编辑推荐： 阻碍女性的，正是被创造出来的“女人味” 《伊利亚特》《蒙娜丽莎》《傲慢与偏见》《源氏物语》《我是猫》…… 女人是如何被塑造的，她们的觉醒又是如何一再被打断的？ “我们”不再是观...&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;拉莫莱特之吻：有关文化史的思考&#x27;, &#x27;author&#x27;: &#x27;(美) 罗伯特·达恩顿&#x27;, &#x27;year&#x27;: &#x27;2024-1&#x27;, &#x27;publisher&#x27;: &#x27;上海教育出版社&#x27;, &#x27;abstract&#x27;: &#x27;想象怎么能是历史呢？ 历史学家要进入已逝的世界，光靠方法理论那一套是不行的，还需要大胆想象。 本书有四个目的：第一，是要显示过去如何作为暗流存在于当下；第二，是要通过个案来分析媒体的作用；第三，借本书的写作过程来昭示媒体研究中的历史向度；第四，在这些讨论的基础上探讨宏观历史以及与历史相关的其他人文领域。&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;国家与学术的地方互动：四川大学国立化进程（1925-1939）（修订本）&#x27;, &#x27;author&#x27;: &#x27;王东杰&#x27;, &#x27;year&#x27;: &#x27;2023-11&#x27;, &#x27;publisher&#x27;: &#x27;四川人民出版社&#x27;, &#x27;abstract&#x27;: &#x27;本书是集中讨论中国现代大学与国家关系的优秀作品。本书最重要的特色是从“基层”入手，着重反映地方经验，从而深化了我们在中国民族主义问题上的认知和理解。从方法论上，书稿也体现出作者将历史学和人类学加以结合的跨学科研究的努力。此书立论具体而充实，背后所反映的问题极大。其取材丰富，不仅充分利用留存档案，更以报刊、文集等各类文献互相比证。其见识不受...&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上代码，我们成功地从网页中提取了所有图片链接和它们的描述文字。PyQuery模块的灵活性和强大功能使得数据提取变得十分便捷。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解剖HTML的魔幻术：揭秘BeautifulSoup模块的元素操控艺术</title>
      <link href="/posts/35834.html"/>
      <url>/posts/35834.html</url>
      
        <content type="html"><![CDATA[<p>近年来，网络爬虫在数据分析和网站开发等领域得到了广泛的应用。Python是一种流行的编程语言，具有强大的网络爬虫能力。在Python中，可以使用beautifulSoup模块从网站中获取有用的信息，这里我们介绍一些常用的方法。</p><h2 id="安装beautifulSoup"><a href="#安装beautifulSoup" class="headerlink" title="安装beautifulSoup"></a>安装beautifulSoup</h2><p>首先，需要在本地安装beautifulSoup。打开终端或者命令提示符窗口，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install beautifulsoup4</span><br></pre></td></tr></table></figure><h2 id="解释器对比"><a href="#解释器对比" class="headerlink" title="解释器对比"></a>解释器对比</h2><p>下表列出了Python中BeautifulSoup4模块的主要解释器以及它们的使用方法、优点和缺点：</p><table><thead><tr><th>解释器</th><th>使用方法</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>lxml</td><td>使用 <code>BeautifulSoup(markup, &#39;lxml&#39;)</code> 调用</td><td>非常快速、高效</td><td>需要安装额外的C库</td></tr><tr><td>html.parser</td><td>使用 <code>BeautifulSoup(markup, &#39;html.parser&#39;)</code> 调用</td><td>默认情况下即可使用，无需额外安装</td><td>解析速度相对较慢，不够灵活</td></tr><tr><td>html5lib</td><td>使用 <code>BeautifulSoup(markup, &#39;html5lib&#39;)</code> 调用</td><td>创建一个完整的HTML文档模型</td><td>解析速度较慢，消耗内存较多，不够高效</td></tr></tbody></table><p>注意：上述使用方法中的 <code>markup</code> 参数代表要解析的HTML文档。</p><p>请注意，BeautifulSoup4模块的默认解析器取决于你的安装情况和Python版本。在大多数情况下，lxml和html.parser是最常用的解析器。</p><p>对于选择解析器，需要根据你的具体使用需求来进行选择。如果速度是你关注的重点，那么lxml解析器是一个不错的选择。如果使用方便性和兼容性是首要考虑因素，则可以选择html.parser解析器。如果需要解析不完整或有损的HTML文档，以及构建完整的文档模型，那么html5lib解析器是一个好的选择。</p><h2 id="对象种类"><a href="#对象种类" class="headerlink" title="对象种类"></a>对象种类</h2><p>BeautifulSoup4模块中的主要对象种类包括 <code>BeautifulSoup</code> 对象、<code>Tag</code> 对象、<code>NavigableString</code> 对象和 <code>Comment</code> 对象。下面我将详细介绍每种对象并整理它们的使用方法：</p><ol><li><p><code>BeautifulSoup</code> 对象：</p><ul><li>介绍：<code>BeautifulSoup</code> 对象表示整个解析的文档，并提供了许多方法和属性来遍历和搜索文档中的元素和内容。</li><li>使用方法：<ul><li>创建 <code>BeautifulSoup</code> 对象: 使用 <code>BeautifulSoup(markup, parser)</code> 来创建对象，其中 <code>markup</code> 是要解析的文档，<code>parser</code> 是解析器类型。</li><li>方法和属性：可以使用 <code>find()</code>、<code>find_all()</code>、<code>select()</code> 等方法来查找文档中的元素，使用 <code>prettify()</code> 方法美化输出文档结构，使用各种属性来访问文档信息。</li></ul></li></ul></li><li><p><code>Tag</code> 对象：</p><ul><li>介绍：<code>Tag</code> 对象表示 HTML 或 XML 文档中的标签，包含了标签的名称和属性，以及标签内的子标签和文本内容。</li><li>使用方法：<ul><li>创建 <code>Tag</code> 对象: 通常是通过 <code>find()</code>、<code>find_all()</code> 等方法来获取，也可以使用 <code>new_tag()</code> 来创建新的标签对象。</li><li>方法和属性：可以使用 <code>name</code> 属性获取标签名称，使用 <code>[&#39;attr&#39;]</code> 或 <code>attrs</code> 属性获取标签的属性，使用 <code>find()</code>、<code>find_all()</code> 方法在标签内查找子标签，使用 <code>text</code> 属性获取标签内的文字内容，使用 <code>append()</code>、<code>insert()</code> 等方法插入新的标签等。</li></ul></li></ul></li><li><p><code>NavigableString</code> 对象：</p><ul><li>介绍：<code>NavigableString</code> 对象表示解析文档中的字符串内容，是对字符串的包装，具有额外的属性和方法。</li><li>使用方法：<ul><li>创建 <code>NavigableString</code> 对象: 通常是通过获取标签的 <code>string</code> 属性来获得。</li><li>方法和属性：可以使用 <code>string</code> 属性获取字符串内容，使用 <code>replace_with()</code> 方法替换字符串内容，使用 <code>strip()</code>、<code>split()</code> 等方法处理字符串。</li></ul></li></ul></li><li><p><code>Comment</code> 对象：</p><ul><li>介绍：<code>Comment</code> 对象表示HTML或XML文档中的注释，是对注释内容的包装。</li><li>使用方法：<ul><li>创建 <code>Comment</code> 对象: 通常是通过获取注释内容后得到的。</li><li>方法和属性：可以使用 <code>string</code> 属性获取注释内容，也可以使用 <code>replace_with()</code> 方法替换注释内容。</li></ul></li></ul></li></ol><p>以上是BeautifulSoup4模块中主要对象种类的详细介绍和使用方法。通过灵活运用这些对象及其方法，可以方便地处理和操作HTML/XML文档，从中获取所需的数据或进行特定的操作。</p><h2 id="用法详解"><a href="#用法详解" class="headerlink" title="用法详解"></a>用法详解</h2><h3 id="获取网页"><a href="#获取网页" class="headerlink" title="获取网页"></a>获取网页</h3><p>使用requests模块获取网页：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">url = <span class="string">&quot;http://www.cheneyblog.com/&quot;</span></span><br><span class="line">response = requests.get(url)</span><br><span class="line">html = response.text</span><br></pre></td></tr></table></figure><p>这里我们用 <code>www.cheneyblog.com</code> 作为一个示例网站。</p><h3 id="解析HTML"><a href="#解析HTML" class="headerlink" title="解析HTML"></a>解析HTML</h3><p>我们可以使用beautifulSoup模块来解析HTML代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html, <span class="string">&quot;html.parser&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="查找标签"><a href="#查找标签" class="headerlink" title="查找标签"></a>查找标签</h3><p>我们可以寻找网页中特定的标签，如<code>&lt;title&gt;</code>或者<code>&lt;p&gt;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title = soup.title</span><br></pre></td></tr></table></figure><p>我们还可以获取标签的文本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title_text = title.text</span><br></pre></td></tr></table></figure><h3 id="查找所有的标签"><a href="#查找所有的标签" class="headerlink" title="查找所有的标签"></a>查找所有的标签</h3><p>如果希望获取一个页面中的所有特定标签，可以使用 <code>find_all()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">all_items = soup.find_all(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="comment"># &lt;a href=&quot;/archives/&quot;&gt;</span></span><br><span class="line"><span class="comment">#     &lt;div class=&quot;headline&quot;&gt;文章&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#     &lt;div class=&quot;length-num&quot;&gt;98&lt;/div&gt;</span></span><br><span class="line"><span class="comment"># &lt;/a&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以像以下的方式获取其中一个标签的文本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">item_text = all_items[<span class="number">0</span>].text</span><br><span class="line"><span class="comment"># 文章</span></span><br><span class="line"><span class="comment"># 98</span></span><br></pre></td></tr></table></figure><h3 id="通过类名查找标签"><a href="#通过类名查找标签" class="headerlink" title="通过类名查找标签"></a>通过类名查找标签</h3><p>有时候，网站中的标签都没有ID或者没有唯一标识。这时候，可以利用class名字来查找所有的标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all_items = soup.find_all(<span class="string">&#x27;ul&#x27;</span>, class_=<span class="string">&quot;menus_item_child&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(all_items[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;ul class=&quot;menus_item_child&quot;&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li&gt;&lt;a class=&quot;site-page child&quot; href=&quot;/categories/HtmlCss&quot;&gt;&lt;i</span></span><br><span class="line"><span class="comment">#             class=&quot;fa-fw fa fa-area-chart&quot;&gt;&lt;/i&gt;&lt;span&gt; Html/Css&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"># &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><p>我们还可以根据其它属性进行查找，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">all_items = soup.find_all(<span class="string">&#x27;ul&#x27;</span>, attrs=&#123;<span class="string">&quot;class&quot;</span>: <span class="string">&quot;card-category-list&quot;</span>, <span class="string">&quot;id&quot;</span>: <span class="string">&quot;aside-cat-list&quot;</span>&#125;)</span><br><span class="line"><span class="comment"># &lt;ul class=&quot;card-category-list&quot; id=&quot;aside-cat-list&quot;&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Digitalize/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Digitalize&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;1&lt;/span&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="comment">#     &lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Docker/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Docker&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;3&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Hexo/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Hexo&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;1&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/HtmlCss/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;HtmlCss&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;1&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Internet/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Internet&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;1&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Java/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Java&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;15&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Oracle/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Oracle&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;43&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;card-category-list-item&quot;&gt;&lt;a class=&quot;card-category-list-link&quot; href=&quot;/categories/Python/&quot;&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;card-category-list-name&quot;&gt;Python&lt;/span&gt;&lt;span class=&quot;card-category-list-count&quot;&gt;14&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"># &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h2><p>假设我们想从一个网页中提取出所有的新闻标题和链接。下面是使用BeautifulSoup模块实现的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">header = &#123;</span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 &quot;</span></span><br><span class="line">                  <span class="string">&quot;Safari/537.36 Edg/120.0.0.0&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送HTTP请求，获取网页内容</span></span><br><span class="line">response = requests.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>, headers=header)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建BeautifulSoup对象</span></span><br><span class="line">soup = BeautifulSoup(response.text, <span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有新闻标题和链接</span></span><br><span class="line">news_list = soup.find(<span class="string">&#x27;ul&#x27;</span>, class_=<span class="string">&#x27;s-hotsearch-content&#x27;</span>)</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># &lt;ul class=&quot;s-hotsearch-content&quot; id=&quot;hotsearch-content-wrapper&quot;&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item odd&quot; data-index=&quot;0&quot;&gt;&lt;a class=&quot;title-content c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                      href=&quot;https://www.baidu.com/s?wd=%E7%94%A8%E5%A5%BD%E2%80%9C%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E2%80%9D%E8%BF%99%E5%85%B3%E9%94%AE%E4%B8%80%E6%8B%9B&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                      target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: ;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot0&quot; style=&quot;display: none;&quot;&gt;0&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;用好“改革开放”这关键一招&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small&quot;&gt;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item even&quot; data-index=&quot;3&quot;&gt;&lt;a class=&quot;title-content c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                       href=&quot;https://www.baidu.com/s?wd=%E7%BE%8E%E4%B8%BD%E4%B9%A1%E6%9D%91+%E5%B9%B8%E7%A6%8F%E7%94%9F%E6%B4%BB&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                       target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: none;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot3&quot; style=&quot;display: ;&quot;&gt;3&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;美丽乡村 幸福生活&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small&quot;&gt;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item odd&quot; data-index=&quot;1&quot;&gt;&lt;a class=&quot;title-content c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                      href=&quot;https://www.baidu.com/s?wd=%E4%B8%BB%E6%8C%81%E4%BA%BA%E9%9F%B3%E4%B9%90%E4%BC%9A%E6%B1%82%E5%A9%9A%E8%A7%82%E4%BC%97%E9%BD%90%E5%96%8A%E9%80%80%E7%A5%A8&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                      target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: none;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot1&quot; style=&quot;display: ;&quot;&gt;1&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;主持人音乐会求婚观众齐喊退票&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small&quot;&gt;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item even&quot; data-index=&quot;4&quot;&gt;&lt;a class=&quot;title-content c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                       href=&quot;https://www.baidu.com/s?wd=%E5%A5%B3%E5%AD%A9%E7%94%A8%E7%A7%91%E7%9B%AE%E4%B8%89%E8%B7%B3%E7%BB%B3+%E8%8E%B7%E7%9C%81%E7%BA%A7%E6%AF%94%E8%B5%9B%E7%AC%AC1%E5%90%8D&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                       target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: none;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot4&quot; style=&quot;display: ;&quot;&gt;4&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;女孩用科目三跳绳 获省级比赛第1名&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small&quot;&gt;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item odd&quot; data-index=&quot;2&quot;&gt;&lt;a class=&quot;title-content c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                      href=&quot;https://www.baidu.com/s?wd=%E7%94%B7%E5%AD%90%E5%86%AC%E9%92%93%E5%A4%B1%E8%81%94+%E9%81%97%E4%BD%93%E5%9C%A8%E5%86%B0%E7%BC%9D%E4%B8%AD%E8%A2%AB%E5%8F%91%E7%8E%B0&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                      target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: none;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: none;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot2&quot; style=&quot;display: ;&quot;&gt;2&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;男子冬钓失联 遗体在冰缝中被发现&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small&quot;&gt;&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment">#     &lt;li class=&quot;hotsearch-item even&quot; data-index=&quot;5&quot;&gt;&lt;a class=&quot;title-content tag-width c-link c-font-medium c-line-clamp1&quot;</span></span><br><span class="line"><span class="comment">#                                                       href=&quot;https://www.baidu.com/s?wd=%E6%A0%BC%E5%8A%9B&amp;amp;sa=fyb_n_homepage&amp;amp;rsv_dl=fyb_n_homepage&amp;amp;from=super&amp;amp;cl=3&amp;amp;tn=baidutop10&amp;amp;fr=top1000&amp;amp;rsv_idx=2&amp;amp;hisfilter=1&quot;</span></span><br><span class="line"><span class="comment">#                                                       target=&quot;_blank&quot;&gt;</span></span><br><span class="line"><span class="comment">#         &lt;div class=&quot;title-content-noindex&quot; style=&quot;display: ;&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="comment">#         &lt;i class=&quot;c-icon title-content-top-icon c-color-red c-gap-right-small&quot; style=&quot;display: none;&quot;&gt;&lt;/i&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-index c-index-single c-index-single-hot-100&quot; style=&quot;display: none;&quot;&gt;-100&lt;/span&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-title&quot;&gt;格力电器年终好物推荐&lt;/span&gt;&lt;/a&gt;&lt;span</span></span><br><span class="line"><span class="comment">#             class=&quot;title-content-mark ie-vertical c-text c-gap-left-small c-text-business&quot;&gt;商&lt;/span&gt;&lt;/li&gt;</span></span><br><span class="line"><span class="comment"># &lt;/ul&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">news = []</span><br><span class="line"><span class="comment"># 打印新闻标题和链接</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> news_list.find_all(<span class="string">&#x27;li&#x27;</span>):</span><br><span class="line">    title = li.find(<span class="string">&#x27;span&#x27;</span>, class_=<span class="string">&#x27;title-content-title&#x27;</span>).get_text()</span><br><span class="line">    url = li.find(<span class="string">&#x27;a&#x27;</span>).get(<span class="string">&#x27;href&#x27;</span>)</span><br><span class="line">    new_dict = &#123;<span class="string">&quot;title&quot;</span>: title, <span class="string">&quot;url&quot;</span>: url&#125;</span><br><span class="line">    news.append(new_dict)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> new <span class="keyword">in</span> news:</span><br><span class="line">    <span class="built_in">print</span>(new)</span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;用好“改革开放”这关键一招&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E7%94%A8%E5%A5%BD%E2%80%9C%E6%94%B9%E9%9D%A9%E5%BC%80%E6%94%BE%E2%80%9D%E8%BF%99%E5%85%B3%E9%94%AE%E4%B8%80%E6%8B%9B&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;美丽乡村 幸福生活&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E7%BE%8E%E4%B8%BD%E4%B9%A1%E6%9D%91+%E5%B9%B8%E7%A6%8F%E7%94%9F%E6%B4%BB&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;男子冬钓失联 遗体在冰缝中被发现&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E7%94%B7%E5%AD%90%E5%86%AC%E9%92%93%E5%A4%B1%E8%81%94+%E9%81%97%E4%BD%93%E5%9C%A8%E5%86%B0%E7%BC%9D%E4%B8%AD%E8%A2%AB%E5%8F%91%E7%8E%B0&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;李家超：基本法第23条明年内实施&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E6%9D%8E%E5%AE%B6%E8%B6%85%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%B3%95%E7%AC%AC23%E6%9D%A1%E6%98%8E%E5%B9%B4%E5%86%85%E5%AE%9E%E6%96%BD&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;女孩用科目三跳绳 获省级比赛第1名&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E5%A5%B3%E5%AD%A9%E7%94%A8%E7%A7%91%E7%9B%AE%E4%B8%89%E8%B7%B3%E7%BB%B3+%E8%8E%B7%E7%9C%81%E7%BA%A7%E6%AF%94%E8%B5%9B%E7%AC%AC1%E5%90%8D&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;title&#x27;: &#x27;山东两幼师出租房内遇害&#x27;, &#x27;url&#x27;: &#x27;https://www.baidu.com/s?wd=%E5%B1%B1%E4%B8%9C%E4%B8%A4%E5%B9%BC%E5%B8%88%E5%87%BA%E7%A7%9F%E6%88%BF%E5%86%85%E9%81%87%E5%AE%B3&amp;sa=fyb_n_homepage&amp;rsv_dl=fyb_n_homepage&amp;from=super&amp;cl=3&amp;tn=baidutop10&amp;fr=top1000&amp;rsv_idx=2&amp;hisfilter=1&#x27;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上代码，我们成功地从网页中提取了百度热搜的标题和链接。这只是使用BeautifulSoup的一小部分功能，它还可以帮助你解析复杂的HTML结构、处理表单数据、处理XML文档等。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Token：数字世界的魔法密匙</title>
      <link href="/posts/9494.html"/>
      <url>/posts/9494.html</url>
      
        <content type="html"><![CDATA[<p>在当今数字化的世界中，我们经常听到 “Token” 这个词。它似乎有着魔法般的力量，可以连接我们与各种数字资产之间的关系。那么，Token究竟是什么？它是如何发挥作用的呢？让我们一起来揭开Token的奇妙之处吧！</p><h2 id="什么是Token？"><a href="#什么是Token？" class="headerlink" title="什么是Token？"></a>什么是Token？</h2><p>在技术领域，Token指的是一种代表了某种权益或价值的数字化凭证。它可以是一串字符、数字或者其他形式的数据。Token可以用来代表数字资产、身份认证、权限控制等各种场景。</p><h2 id="Token的工作原理"><a href="#Token的工作原理" class="headerlink" title="Token的工作原理"></a>Token的工作原理</h2><p>Token的工作原理可以类比为现实世界中的钥匙。以身份认证为例，当你登录一个网站时，系统会颁发一个身份认证的Token给你。这个Token相当于一个数字化的身份凭证，它包含了你的身份信息。每当你进行某些需要认证的操作时，你只需出示这个Token，系统就能验证你的身份。</p><h2 id="常见的Token类型"><a href="#常见的Token类型" class="headerlink" title="常见的Token类型"></a>常见的Token类型</h2><p>在数字世界中，我们经常遇到不同类型的Token。以下是几种常见的Token类型：</p><ol><li>访问令牌（Access Token）：用于在不同系统之间进行身份验证和授权控制。</li><li>身份令牌（ID Token）：包含用户的身份信息，例如姓名、电子邮件等。</li><li>密钥令牌（API Key）：用于访问API接口，保证权限和安全性。</li><li>加密令牌（Encrypt Token）：用于加密和解密敏感信息。</li></ol><h2 id="为什么Token如此重要？"><a href="#为什么Token如此重要？" class="headerlink" title="为什么Token如此重要？"></a>为什么Token如此重要？</h2><p>Token在数字世界中扮演着非常重要的角色，它具有以下几个优势：</p><ol><li><strong>安全性</strong>：Token可以提供安全的身份验证和授权机制，以保护用户和系统的安全。</li><li><strong>灵活性</strong>：Token可以在不同的系统和平台之间进行使用和传递，无需重复登录或认证。</li><li><strong>可扩展性</strong>：Token可以用于各种不同的场景和用途，包括金融交易、物联网等领域。</li></ol><h2 id="Token的应用"><a href="#Token的应用" class="headerlink" title="Token的应用"></a>Token的应用</h2><ol><li><p>用户身份认证：在需要用户登录才能进行访问或操作的场景中，通常会在用户登录成功后为其颁发一个Token。当用户进行其他请求时，需要在请求中携带这个Token，服务器可以通过验证Token来确认用户的身份。</p></li><li><p>API访问授权：当应用程序需要调用某个API接口时，服务器可能会要求提供有效的Token才能完成授权。这样可以确保只有被授权的应用程序能够访问受保护的API资源。</p></li><li><p>安全敏感操作：在进行一些安全敏感的操作时，比如修改个人信息、进行支付等，服务器会要求用户在请求中提供有效的Token作为身份验证，确保操作的合法性和安全性。</p></li><li><p>访问受限资源：当访问某些受限资源时，服务器可能会要求提供有效的Token以证明用户有访问此资源的权限。这样可以对资源进行细粒度的访问控制。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>揭秘Web响应背后的神秘面纱</title>
      <link href="/posts/4273.html"/>
      <url>/posts/4273.html</url>
      
        <content type="html"><![CDATA[<h2 id="Web响应是什么？"><a href="#Web响应是什么？" class="headerlink" title="Web响应是什么？"></a>Web响应是什么？</h2><p>Web响应是服务器对客户端发起的Web请求所做出的回应。它包含了来自服务器的数据，以及一些元数据，用于描述响应的信息。</p><h2 id="响应的基本结构"><a href="#响应的基本结构" class="headerlink" title="响应的基本结构"></a>响应的基本结构</h2><p>一个Web响应由以下几个部分组成：</p><ol><li>状态行：描述了响应的状态码和对应的状态信息。</li><li>头部信息：包含响应的元数据，如响应的日期、内容类型等。</li><li>主体：包含了响应的实际数据，可以是HTML、JSON、图片等。</li></ol><h2 id="常见的状态码"><a href="#常见的状态码" class="headerlink" title="常见的状态码"></a>常见的状态码</h2><p>服务器在响应中使用HTTP状态码来表示请求的处理结果。下面是一些常见的状态码：</p><ul><li>200 OK：请求成功。</li><li>301 Moved Permanently：请求的资源已永久移动到新的位置。</li><li>404 Not Found：请求的资源未找到。</li><li>500 Internal Server Error：服务器内部错误。</li></ul><table><thead><tr><th>分 类</th><th>分类描述</th></tr></thead><tbody><tr><td>1**</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2**</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3**</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4**</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><p>响应头提供了关于响应的元数据信息。常见的响应头包括：</p><ul><li>Content-Type：指定响应主体的媒体类型，以便客户端正确解析数据。</li><li>Content-Length：指定响应主体的长度，以字节为单位。</li><li>Cache-Control：指定响应主体的缓存策略，如缓存时间、是否可以缓存等。</li></ul><p>下面就以访问博客园的HTTP请求进行分析，首先是浏览器发出请求，服务器响应头数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cache-control: public,max-age=60</span><br><span class="line">content-encoding: gzip</span><br><span class="line">content-type: text/html; charset=utf-8</span><br><span class="line"><span class="built_in">date</span>: Tue, 19 Dec 2023 08:08:45 GMT</span><br><span class="line">status: 200</span><br><span class="line">strict-transport-security: max-age=2592000; includeSubDomains; preload</span><br><span class="line">vary: Accept-Encoding</span><br></pre></td></tr></table></figure><ul><li><code>cache-control</code>: 指定了响应应该如何被缓存。在这个响应头中，cache-control 的值是 public,max-age=60，表示响应可以被公共缓存（如浏览器缓存），并且缓存可以保存多长时间（60 秒）。</li><li><code>content-encoding</code>: 指定了响应的内容编码方式。在这个响应头中，content-encoding 的值是 gzip，表示响应内容已经被压缩过，使用了 gzip 压缩算法进行压缩。</li><li><code>content-type</code>: 指定了响应的 MIME 类型和字符集。在这个响应头中，content-type 的值是 text/html; charset=utf-8，表示响应内容是 HTML 文本格式，并使用了 UTF-8 字符集。</li><li><code>date</code>: 指定了响应发送的日期和时间。在这个响应头中，date 的值是 Tue, 19 Dec 2023 08:08:45 GMT，表示响应是在 2023 年 12 月 19 日 08:08:45 发送的，使用了 GMT 标准时间。</li><li><code>status</code>: 指定了 HTTP 响应的状态码。在这个响应头中，status 的值是 200，表示请求成功。</li><li><code>strict-transport-security</code>: 指定了使用 HTTPS 安全传输协议的一些相关信息。在这个响应头中，strict-transport-security 的值是 max-age=2592000; includeSubDomains; preload，表示网站支持 HSTS（HTTP Strict-Transport-Security）安全传输协议，且在浏览器中预加载。max-age 表示 HSTS 策略的缓存时间（2592000 秒或 30 天），includeSubDomains 表示子域名也应该使用 HTTPS，preload 表示将网站添加到预加载列表。</li><li><code>vary</code>: 指定了代理服务器对请求响应的缓存策略。在这个响应头中，vary 的值是 Accept-Encoding，表示代理服务器应该根据请求头中的 Accept-Encoding 的值来确定是否使用缓存。</li></ul><h2 id="响应主体"><a href="#响应主体" class="headerlink" title="响应主体"></a>响应主体</h2><p>响应主体包含了服务器返回给客户端的数据。数据可以是HTML文档、JSON数据、图片等等。响应主体的内容类型由响应头中的Content-Type字段指定。</p><h2 id="响应的错误处理"><a href="#响应的错误处理" class="headerlink" title="响应的错误处理"></a>响应的错误处理</h2><p>在Web开发中，处理响应的错误非常重要。当服务器返回错误响应时，客户端应该能够正确地处理和展示错误信息。一些常见的做法包括合理的错误状态码、清晰明了的错误信息和适当的错误处理逻辑。</p><h2 id="响应的优化"><a href="#响应的优化" class="headerlink" title="响应的优化"></a>响应的优化</h2><p>为了提供更好的用户体验，优化Web响应是很重要的。一些优化策略包括使用压缩算法减少响应大小、使用缓存策略减少无效请求、并行下载资源等等。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web请求：展开数字世界的魔法之门</title>
      <link href="/posts/25853.html"/>
      <url>/posts/25853.html</url>
      
        <content type="html"><![CDATA[<p>在数字化的时代，互联网已经成为我们生活中不可或缺的一部分。而要与互联网进行有效的交互，Web请求成为连接用户和网络世界的关键纽带。无论是浏览网页、发送电子邮件还是下载文件，无一例外都离不开那神秘而强大的Web请求。</p><h2 id="什么是Web请求？"><a href="#什么是Web请求？" class="headerlink" title="什么是Web请求？"></a>什么是Web请求？</h2><p>Web请求是指通过HTTP（超文本传输协议）协议，从计算机向远程服务器请求数据的过程。每当你在浏览器中输入网址、提交表单或者点击链接，都会发起一个Web请求。</p><p>简单来说，Web请求就是一个网络客户端（通常是你的浏览器）向网络服务器发送的一条信息。这个信息包含了你想要获取的资源的相关信息，比如请求的类型（GET、POST等）和资源的URL地址。</p><h2 id="Web请求的流程"><a href="#Web请求的流程" class="headerlink" title="Web请求的流程"></a>Web请求的流程</h2><p>下面是一个典型的Web请求流程：</p><ol><li>用户在浏览器中输入URL或者点击链接。</li><li>浏览器解析URL，并将其转换为对应的IP地址。</li><li>浏览器向目标服务器的IP地址发送请求信息。</li><li>目标服务器接收到请求信息，并根据URL找到对应的资源。</li><li>服务器将请求的资源作为响应信息返回给浏览器。</li><li>浏览器接收并解析响应信息，并将其呈现给用户。</li></ol><p>在这个过程中，Web请求涉及到多个角色：浏览器、服务器、HTTP协议和网络传输等。每个角色都扮演着至关重要的角色，确保用户能够顺畅地访问互联网。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>一个Web请求由以下几个部分组成：</p><ol><li>URL（Uniform Resource Locator）：请求的目标资源的地址。</li><li>HTTP方法：描述对目标资源执行的操作类型。常见的HTTP方法包括GET、POST、PUT、DELETE等。</li><li>头部信息：包含请求的元数据，如请求的主机、用户代理等。</li><li>主体（可选）：用于传输请求的数据，常用于POST请求。</li></ol><h2 id="Web请求的类型"><a href="#Web请求的类型" class="headerlink" title="Web请求的类型"></a>Web请求的类型</h2><p>HTTP 协议定义了一些请求方式（也称为 HTTP 方法），用于告知服务器要执行的操作类型。常见的 HTTP 请求方式有以下几种：</p><ol><li><p><strong>GET</strong>：获取资源。使用 GET 请求，客户端请求服务器返回某个资源（如 HTML 页面、图像、视频等），服务器会返回相应的资源，GET 请求可以通过 URL 或请求头中的参数，向服务器传递少量数据。GET 请求是幂等的，也就是说，在同一个 URL 上多次发出相同的 GET 请求，其结果不会发生变化。</p></li><li><p><strong>POST</strong>：提交数据。使用 POST 请求，客户端向服务器提交数据，如表单中填写的数据等。POST 请求将请求数据包含在请求体中，因此可以传递大量数据，而不受 URL 长度限制。POST 请求不是幂等的，也就是说，重复提交相同数据的 POST 请求，可能会产生多个资源或状态变化。</p></li><li><p><strong>PUT</strong>：更新资源。使用 PUT 请求，客户端向服务器发送新的数据，用来替换服务器上的资源。PUT 请求是幂等的，也就是说，多次发送相同的 PUT 请求，其结果相同。</p></li><li><p><strong>DELETE</strong>：删除资源。使用 DELETE 请求，客户端请求服务器删除某个资源。DELETE 请求也是幂等的，多次发送相同的 DELETE 请求，其结果相同。</p></li><li><p><strong>HEAD</strong>：获取资源元数据。使用 HEAD 请求，客户端请求服务器返回某个资源的元数据，如资源类型、修改时间等，但不返回具体的资源内容。</p></li><li><p><strong>OPTIONS</strong>：获取服务器支持的请求方式。使用 OPTIONS 请求，客户端请求服务器返回当前 URL 所支持的 HTTP 请求方式。</p></li><li><p><strong>CONNECT</strong>：建立连接。使用 CONNECT 请求，客户端请求与服务器建立一条 TCP/IP 连接，用于代理服务器或 SSL 加密等。</p></li><li><p><strong>TRACE</strong>：追踪请求。使用 TRACE 请求，服务器会将客户端发送的请求内容返回给客户端，用于调试和检测网络请求是否正常。</p></li></ol><p>这些请求方式为我们发送 HTTP 请求到服务器提供了丰富的方式，以满足不同场景的需求。需要注意的是，不同的请求方式对应不同的语法和语义约定，因此在编写 HTTP 请求时，需要根据请求方式选择相应的请求头和请求体内容。</p><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><p>通过浏览器访问博客园首页时，使用F12打开开发者工具，里面可以监控整个HTTP访问的过程。下面就以访问博客园的HTTP请求进行分析，首先是浏览器发出请求，请求头的数据如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:authority: www.cnblogs.com</span><br><span class="line">:method: GET</span><br><span class="line">:path: /</span><br><span class="line">:scheme: https</span><br><span class="line">accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span><br><span class="line">accept-encoding: gzip, deflate, br</span><br><span class="line">accept-language: zh-CN,zh;q=0.9</span><br><span class="line">cache-control: max-age=0</span><br><span class="line">cookie: _ga_7DSFGJNPL4=GS1.1.1699336048.2.0.1699336049.0.0.0; _ga=GA1.1.946932356.1696821681; .AspNetCore.Antiforgery.b8-pDmTq1XM=CfDJ8DZoAyJmInJHoSwqM1IbzdTYmSrFex3_eSmOeB0ifu8em1SVPoE12nffMKjQiGQBkPiI-_aYd_jqiMAotiOSj1EHSlE7Y3_L6kJ08zQMKEDayneTjoKjjBpdPf-rfsJV8RAGiFhBYLS_YIHoewjbZOM; Hm_lvt_866c9be12d4a814454792b1fd0fed295=1702051797,1702365230,1702436386,1702951775; __gads=ID=ff5d159b06459e07:T=1697078651:RT=1702951776:S=ALNI_Mar2tKO0P3FWB88CYZbdMWrSwN_BQ; __gpi=UID=00000c5cea925d49:T=1697078651:RT=1702951776:S=ALNI_MYh5QqGj_hpgDdMpnls7yl3NMUkFA; Hm_lpvt_866c9be12d4a814454792b1fd0fed295=1702973310; _ga_M95P3TTWJZ=GS1.1.1702973304.34.1.1702973310.0.0.0</span><br><span class="line">sec-fetch-dest: document</span><br><span class="line">sec-fetch-mode: navigate</span><br><span class="line">sec-fetch-site: none</span><br><span class="line">sec-fetch-user: ?1</span><br><span class="line">upgrade-insecure-requests: 1</span><br><span class="line">user-agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36</span><br></pre></td></tr></table></figure><p>以下是每个请求头中各部分的含义：</p><ul><li><code>:authority</code>: 请求 URL 域名部分，即主机名和端口号（如果有）。在此请求中，:authority 是 &lt;<a href="http://www.cnblogs.com&gt;/">www.cnblogs.com&gt;</a></li><li><code>:method</code>: 请求方法，即 HTTP 方法。在此请求中，:method 是 GET 表示该请求是获取资源的请求。</li><li><code>:path</code>: 请求 URL 路径部分。在此请求中，:path 是 /，表示请求的是根目录。</li><li><code>:scheme</code>: 指定了用于访问请求 URL 的协议（即 http 或 https）。在此请求中，:scheme 是 https。</li><li><code>accept</code>: 指定了客户端可以接收的 MIME 类型。在此请求中，客户端接受多种类型的媒体格式，根据权重从高到低依次为 text/html,application/xhtml+xml,application/xml,image/avif,image/webp,image/apng,<em>/</em>;q=0.8,application/signed-exchange;v=b3;q=0.9。</li><li><code>accept-encoding</code>: 指定了客户端可以接受的压缩编码类型。在此请求中，客户端可以接受的压缩编码类型是 gzip、deflate 和 br。</li><li><code>accept-language</code>: 指定了客户端可以接受的语言类型。在此请求中，客户端可以接受的语言类型为中文（简体）（权重为 1）和其他语言（权重为 0.9）。</li><li><code>cache-control</code>: 控制浏览器是否缓存响应以及缓存的方式。在此请求中，cache-control 是 max-age=0，表示不缓存响应。</li><li><code>cookie</code>: 向服务器发送已保存的 cookie 数据。在此请求中，包含多个 cookie 值。</li><li><code>sec-fetch-dest</code>: 指定了请求的目标类型。在此请求中，sec-fetch-dest 是 document，表示请求的是一个 HTML 文档。</li><li><code>sec-fetch-mode</code>: 指定了请求模式。在此请求中，sec-fetch-mode 是 navigate，表示这是一个导航请求，通常是用户通过点击链接或输入地址栏来发起的请求。</li><li><code>sec-fetch-site</code>: 指定请求的来源站点类型。在此请求中，sec-fetch-site 是 none，表示请求没有来源站点。</li><li><code>sec-fetch-user</code>: 指定了用户类型，以及是否能将用户凭据（如 cookie 和 HTTP 认证）发送到服务器。在此请求中，sec-fetch-user 是 ?1，表示可以将用户凭据发送到服务器。</li><li><code>upgrade-insecure-requests</code>: 指示客户端是否将所有 HTTP 请求自动升级到 HTTPS。在此请求中，升级所有请求（值为 1）以便使用 HTTPS。</li><li><code>user-agent</code>: 客户端使用的浏览器类型和版本。在此请求中，User-Agent 是 Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.198 Safari/537.36，表示客户端是使用 Chrome 86 浏览器（在 Windows 10 上）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Web请求是连接用户与互联网之间的关键步骤。通过Web请求，我们能够从服务器获取所需资源，并与互联网实现无缝的交互。了解Web请求的工作原理和类型，能帮助我们更好地理解互联网的运作方式，并开发出更优秀、更高效的Web应用程序。</p><p>无论你是普通用户、开发者还是网络管理员，学习理解Web请求的基础知识，能让你更好地利用互联网的资源，使生活变得更加便利和丰富多彩。让我们珍惜Web请求这个奇妙的通道，体验数字化世界带来的无限魅力吧！</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>requests：轻松战胜网络请求</title>
      <link href="/posts/33051.html"/>
      <url>/posts/33051.html</url>
      
        <content type="html"><![CDATA[<h2 id="突破网络边界：了解requests模块的基本概念"><a href="#突破网络边界：了解requests模块的基本概念" class="headerlink" title="突破网络边界：了解requests模块的基本概念"></a>突破网络边界：了解requests模块的基本概念</h2><p>在我们开始使用requests模块之前，让我们先了解一下它的基本概念。requests模块是一个简洁而高效的HTTP库，可用于发送各种HTTP请求，并处理响应数据。它提供了简单且直观的接口，让我们能够轻松地进行GET、POST、PUT、DELETE等各种类型的请求。</p><h2 id="发起挑战：动手实践requests模块"><a href="#发起挑战：动手实践requests模块" class="headerlink" title="发起挑战：动手实践requests模块"></a>发起挑战：动手实践requests模块</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">response = requests.get(<span class="string">&quot;https://jsonplaceholder.typicode.com/posts/1&quot;</span>)</span><br><span class="line"><span class="comment"># 获取状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line"><span class="comment"># 获取网页内容</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line">data = response.json()</span><br><span class="line"><span class="comment"># 获取请求中的title字段</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;title&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;----------------&quot;</span>)</span><br><span class="line"><span class="comment"># 获取请求中的boby字段</span></span><br><span class="line"><span class="built_in">print</span>(data[<span class="string">&quot;body&quot;</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用requests模块发起了一个GET请求，获取了一个来自JSON Placeholder API的示例数据。我们使用 <code>requests.get()</code> 方法，并传入需要获取数据的URL参数。然后，我们通过 <code>response.json()</code> 方法来解析响应的JSON数据。</p><p>最后，我们打印出了获取到的数据中的 “title” 和 “body” 字段。</p><h4 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h4><p>在<code>requests</code>库中，可以通过<code>params</code>参数直接传递参数，<code>requests</code>库会自动处理参数并拼接到URL中。</p><p>下面是一个使用<code>params</code>参数的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">payload = &#123;</span><br><span class="line">    <span class="string">&#x27;tn&#x27;</span>: <span class="string">&#x27;15007414_15_dg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ie&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;requests&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com&#x27;</span></span><br><span class="line"></span><br><span class="line">r = requests.get(url, params=payload)</span><br><span class="line"><span class="built_in">print</span>(r.url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们直接将参数<code>params</code>传递给<code>requests.get()</code>方法的<code>params</code>参数中，<code>requests</code>库会自动将它们拼接到URL中，发送GET请求。</p><h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://httpbin.org/post&quot;</span></span><br><span class="line">files = &#123;<span class="string">&#x27;file&#x27;</span>: <span class="built_in">open</span>(<span class="string">r&quot;C:\Users\85031\Desktop\20190801101348861.jpg&quot;</span>, <span class="string">&#x27;rb&#x27;</span>)&#125;</span><br><span class="line"></span><br><span class="line">response = requests.post(url, files=files)</span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了要上传文件的URL地址（<code>url</code>），然后使用<code>open</code>函数打开要上传的文件，并将其赋值给<code>files</code>字典中的<code>&#39;file&#39;</code>键。请确保替换实际的文件名和路径。</p><p>接下来，我们使用<code>requests.post</code>方法发送一个POST请求，并传入URL和<code>files</code>参数。<code>files</code>参数指定文件的键值对，其中键为<code>&#39;file&#39;</code>，值为我们打开的文件对象。</p><p>最后，我们打印出服务器的响应内容（<code>response.text</code>），可以根据实际情况进行相应的处理。</p><h3 id="获取Cookies"><a href="#获取Cookies" class="headerlink" title="获取Cookies"></a>获取Cookies</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;https://www.baidu.com&quot;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line">cookies = response.cookies</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;cookie.name&#125;</span>: <span class="subst">&#123;cookie.value&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先定义了要请求的URL地址（<code>url</code>）。然后，我们使用<code>requests.get</code>方法发送一个GET请求，并将其赋值给<code>response</code>变量。</p><p>接下来，我们可以通过<code>response.cookies</code>访问返回的<code>Cookies</code>。可以通过<code>for</code>循环遍历<code>cookies</code>对象，获取每个<code>cookie</code>的名称和值。在示例中，我们简单地打印每个<code>cookie</code>的名称和值。</p><p>你可以根据实际情况，进一步处理或使用这些<code>cookies</code>，例如将它们传递给后续请求，以实现登录或保持会话等功能。</p><p>注意：在实际使用中，你可能需要对请求进行相应的设置、处理重定向或处理异常等。此示例仅展示了获取<code>cookies</code>的核心部分。</p><h3 id="维持会话"><a href="#维持会话" class="headerlink" title="维持会话"></a>维持会话</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个会话对象</span></span><br><span class="line">session = requests.Session()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起第一个请求</span></span><br><span class="line">session.get(<span class="string">&#x27;http://httpbin.org/cookies/set/number/52346&#x27;</span>)  <span class="comment"># 处理第一个请求的响应...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发起第二个请求</span></span><br><span class="line">response2 = session.get(<span class="string">&quot;http://httpbin.org/cookies&quot;</span>)</span><br><span class="line"><span class="comment"># 处理第二个请求的响应...</span></span><br><span class="line"><span class="built_in">print</span>(response2.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个<code>Session</code>对象，命名为<code>session</code>。然后，我们可以使用该对象，连续发起多个请求。</p><p>在第一个请求中，我们使用<code>session.get</code>方法，并传递URL并设置Cookie信息（例如<code>number</code>）。</p><p>在第二个请求中，我们使用相同的<code>session</code>对象再次调用<code>session.get</code>方法，并传递另一个URL。这样，请求将重用之前的会话信息和Cookie。</p><p>你可以根据实际需要，发起其他请求或使用不同的HTTP方法（如POST、PUT等）。无论多少请求，只要使用同一个<code>session</code>对象，会话状态和Cookie信息都将保持一致。</p><p>注意：在实际使用中，你可能需要处理异常、设置请求头、处理重定向等。此示例仅展示了会话维持的核心部分。</p><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>在Python的requests库中，默认情况下，对于重定向的请求，<code>requests</code>库会自动跟随重定向。这意味着，如果发起的请求得到一个重定向响应，<code>requests</code>库会自动发送一个新的请求，跟随重定向的链接。</p><p>以下是一个示例代码，演示如何在requests库中处理重定向：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://cheneyblog.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否重定向</span></span><br><span class="line"><span class="keyword">if</span> response.history:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Redirects:&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> redirect <span class="keyword">in</span> response.history:</span><br><span class="line">        <span class="built_in">print</span>(redirect.status_code, redirect.url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Final URL:&#x27;</span>, response.url)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response:&#x27;</span>, response.text[-<span class="number">50</span>:])</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们使用<code>requests.get()</code>方法发送一个GET请求到<code>url</code>。如果该请求经历了重定向，我们可以通过<code>response.history</code>属性来获取重定向的历史列表，包括每次重定向的状态码和URL。最终的URL可以通过<code>response.url</code>获取，并且返回的响应可以通过<code>response.text</code>来获取。</p><p>如果你想禁用重定向，你可以使用<code>allow_redirects</code>参数，并将其设置为<code>False</code>，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://cheneyblog.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url, allow_redirects=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Status Code:&#x27;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response:&#x27;</span>, response.text[-<span class="number">50</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ResponseURL:&#x27;</span>, response.url)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们将<code>allow_redirects</code>参数设置为<code>False</code>，这样就禁用了自动跟随重定向。这意味着，如果该请求得到一个重定向响应，<code>requests</code>库会返回重定向的响应，而不会自动发送新的请求。</p><h3 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h3><p>在Python的requests库中，你可以通过设置<code>timeout</code>参数来指定请求的超时时间。<code>timeout</code>参数用于设置连接和读取的超时时间，以秒为单位。</p><p>以下是一个示例代码，演示如何在requests库中设置超时时间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置连接超时时间为5秒，读取超时时间为5秒</span></span><br><span class="line">response = requests.get(url, timeout=(<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Status Code:&#x27;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response:&#x27;</span>, response.text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过在<code>requests.get()</code>方法中指定<code>timeout</code>参数，将连接超时时间和读取超时时间都设置为5秒。这意味着，如果连接或读取操作在5秒内没有完成，将会引发一个<code>requests.exceptions.Timeout</code>异常。</p><p>除了在<code>requests.get()</code>方法中设置<code>timeout</code>参数外，你还可以在全局范围内通过<code>requests</code>模块的<code>default_timeout</code>属性来设置默认的超时时间，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">requests.default_timeout = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://example.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Status Code:&#x27;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response:&#x27;</span>, response.text)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过将<code>requests.default_timeout</code>属性设置为5秒，来指定默认的超时时间。这样在后续的请求中，如果没有显式指定<code>timeout</code>参数，将会使用该默认的超时时间。</p><p>无论是全局设置还是针对特定请求设置超时时间，都可以帮助你控制请求的超时行为，以便更好地处理网络请求过程中可能出现的超时情况。</p><h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>在Python的requests库中，你可以通过设置 <code>proxies</code> 参数来指定代理服务器，从而在发送请求时使用代理。代理服务器可以帮助你隐藏真实的客户端地址，或者通过代理访问被封锁的资源。</p><p>以下是一个示例代码，演示如何在requests库中设置代理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://example.com&#x27;</span></span><br><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://&lt;proxy_ip&gt;:&lt;proxy_port&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://&lt;proxy_ip&gt;:&lt;proxy_port&gt;&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">response = requests.get(url, proxies=proxies)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Status Code:&#x27;</span>, response.status_code)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Response:&#x27;</span>, response.text)</span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过在 <code>requests.get()</code> 方法中指定 <code>proxies</code> 参数，将 HTTP 和 HTTPS 请求分别指定了代理服务器的地址。你需要将 <code>&lt;proxy_ip&gt;</code> 替换为代理服务器的 IP 地址，将 <code>&lt;proxy_port&gt;</code> 替换为代理服务器的端口号。</p><p>另外，如果你的代理服务器需要进行身份验证，你可以将代理的用户名和密码加入到<code>proxies</code>字典中，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxies = &#123;</span><br><span class="line">    <span class="string">&#x27;http&#x27;</span>: <span class="string">&#x27;http://username:password@&lt;proxy_ip&gt;:&lt;proxy_port&gt;&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https&#x27;</span>: <span class="string">&#x27;http://username:password@&lt;proxy_ip&gt;:&lt;proxy_port&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个示例中，我们在代理地址中包含了用户名和密码信息。</p><p>通过设置 <code>proxies</code> 参数，你可以方便地在 requests 库中使用代理服务器，以满足各种实际需求。</p><h2 id="突破极限：开启更高级的网络请求操作"><a href="#突破极限：开启更高级的网络请求操作" class="headerlink" title="突破极限：开启更高级的网络请求操作"></a>突破极限：开启更高级的网络请求操作</h2><p>requests模块不仅仅可以发送简单的GET请求，还提供了众多功能强大的方法，满足我们在网络请求中的各种需求。我们可以通过设置请求头、发送POST请求、上传文件、处理Cookies等等。同时，requests模块还具备异常处理、会话管理和重试机制等高级功能，让我们能够更好地控制网络请求过程。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asyncio：飞跃边界助你实现异步编程</title>
      <link href="/posts/54088.html"/>
      <url>/posts/54088.html</url>
      
        <content type="html"><![CDATA[<p>在如今高速发展的科技世界中，要想满足用户对高性能、高并发的需求，传统的同步编程模型已经变得力不从心。幸运的是，Python引入了协程（Coroutine）来解决这一问题。async模块作为Python 3.5版本引入的新特性，让协程编程变得更加简单和直观。</p><h2 id="跨越时空：了解协程与async模块的基本概念"><a href="#跨越时空：了解协程与async模块的基本概念" class="headerlink" title="跨越时空：了解协程与async模块的基本概念"></a>跨越时空：了解协程与async模块的基本概念</h2><p>在我们进入具体的协程编程实践之前，首先让我们了解一下协程与async模块的基本概念。协程是一种特殊的函数，可以在运行过程中被挂起和恢复，从而实现异步编程。协程之间可以互相通信和传递数据，而不需要像线程或进程那样进行显式的加锁和同步操作。</p><p>Python的async模块为协程编程提供了良好的支持。该模块中的关键字 <code>async</code> 和 <code>await</code> 让编写异步代码变得更加简单和直观。使用 <code>async</code> 关键字定义一个异步函数，并使用 <code>await</code> 关键字在该函数内部等待其他异步函数或协程对象的执行结果。</p><h2 id="我们的探险：动手实践异步编程"><a href="#我们的探险：动手实践异步编程" class="headerlink" title="我们的探险：动手实践异步编程"></a>我们的探险：动手实践异步编程</h2><p>在我们的探险旅程中，让我们通过一个精彩的示例来深入了解Python中的协程编程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Nice to meet you, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    tasks = [greet(<span class="string">&quot;Alice&quot;</span>), greet(<span class="string">&quot;Bob&quot;</span>)]</span><br><span class="line">    <span class="keyword">await</span> asyncio.gather(*tasks)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个异步函数：<code>greet(name)</code> 和 <code>main()</code>。<code>greet(name)</code> 函数用于打印问候语，然后等待1秒。<code>main()</code> 函数创建了两个协程对象，分别对应于 <code>greet(&quot;Alice&quot;)</code> 和 <code>greet(&quot;Bob&quot;)</code>。然后，使用 <code>asyncio.gather(*tasks)</code> 等待这两个协程对象的执行结果。</p><p>最后，我们使用 <code>asyncio.run(main())</code> 来运行主函数。<code>asyncio.run()</code> 是 Python 3.7 引入的新函数，用于方便地运行异步函数。</p><h2 id="抵达目的地：开启异步编程的无限可能"><a href="#抵达目的地：开启异步编程的无限可能" class="headerlink" title="抵达目的地：开启异步编程的无限可能"></a>抵达目的地：开启异步编程的无限可能</h2><p>Python的协程编程使得异步编程变得更加简单高效。通过使用 <code>async</code> 和 <code>await</code> 关键字，我们可以轻松地编写出具有高性能和高并发特性的异步代码。同时，Python标准库中的asyncio模块提供了丰富的工具和方法，方便我们管理和协调多个协程任务。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>threading：助你驰骋多线程</title>
      <link href="/posts/24310.html"/>
      <url>/posts/24310.html</url>
      
        <content type="html"><![CDATA[<p>随着计算机性能的飞速提升，运用多线程技术来提高程序性能和响应速度成为了不可忽视的趋势。Python作为一门简洁又强大的编程语言，自然也提供了一系列强大的多线程处理函数和工具。其中，threading模块就是Python官方提供的王牌多线程模块。</p><h2 id="经纬天地：了解threading模块的基本概念"><a href="#经纬天地：了解threading模块的基本概念" class="headerlink" title="经纬天地：了解threading模块的基本概念"></a>经纬天地：了解threading模块的基本概念</h2><p>在踏入多线程的灿烂世界之前，我们先来熟悉一下 threading 模块的基本概念。threading模块是Python标准库中的多线程处理模块，提供了一系列的函数和类，方便我们创建和管理线程实例。其中最重要的两个类分别是Thread类和Lock类。</p><ul><li><p><strong>Thread类</strong>：该类用于创建和管理线程实例。通过Thread类，我们可以指定一个入口函数，并以此为基础创建一个线程对象。Thread类的常用方法包括构造函数（用于创建线程实例）、start（启动线程实例）和join（等待线程实例结束）。</p></li><li><p><strong>Lock类</strong>：多线程编程中经常涉及共享资源的访问问题，为了避免数据竞争和错误结果，我们需要使用Lock类来保护共享资源。Lock类提供了acquire和release方法，用于保证同一时间只有一个线程可以访问共享资源。</p></li></ul><h2 id="我们的旅程：动手实践多线程编程"><a href="#我们的旅程：动手实践多线程编程" class="headerlink" title="我们的旅程：动手实践多线程编程"></a>我们的旅程：动手实践多线程编程</h2><p>让我们来通过一个精彩的实例，深入探索 Python threading 模块的魅力吧！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_num</span>():</span><br><span class="line">    <span class="keyword">global</span> total</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000000</span>):</span><br><span class="line">        lock.acquire()</span><br><span class="line">        total += <span class="number">1</span></span><br><span class="line">        lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = [threading.Thread(target=add_num) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(total)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，我们首先声明了一个 total 变量和一个 Lock 实例，用于保护共享资源。接着，我们定义了一个 add_num 函数，该函数的作用是将 1 加到 total 变量中一百万次。</p><p>在主程序中，我们创建了三个线程实例，并分别以 add_num 函数为目标函数进行初始化。然后，我们使用 start 方法启动这三个线程。接下来，我们使用 join 方法让主线程等待这三个线程全部执行完毕。最后，我们输出 total 的值，验证了多线程并发运行的正确性。</p><h2 id="抵达目的地：发现多线程编程的无尽机遇"><a href="#抵达目的地：发现多线程编程的无尽机遇" class="headerlink" title="抵达目的地：发现多线程编程的无尽机遇"></a>抵达目的地：发现多线程编程的无尽机遇</h2><p>Python threading模块为开发人员提供了一种简单而强大的方式来实现多线程编程。通过合理地应用线程锁和多线程技术，我们可以充分利用计算机的多核心能力，提高程序性能和响应速度。然而，多线程编程也存在一些潜在的问题，例如数据竞争和死锁。了解这些问题，并合理地应用线程锁等机制，将有助于编写出高效且稳定的多线程程序。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>multiprocessing:探索多进程并行计算的魔力</title>
      <link href="/posts/49271.html"/>
      <url>/posts/49271.html</url>
      
        <content type="html"><![CDATA[<p>在计算密集型任务中，利用多核处理器进行并行计算是提高程序效率的关键。Python的multiprocessing模块为我们提供了强大而简单的多进程操作工具，让我们一起来探索其魔力吧。</p><h2 id="创建并启动子进程"><a href="#创建并启动子进程" class="headerlink" title="创建并启动子进程"></a>创建并启动子进程</h2><p>通过multiprocessing模块，我们可以轻松地创建并启动子进程。以下是一个简单的使用范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;子进程（Process：&#123;&#125;）开始执行...父进程为（Process：&#123;&#125;）&quot;</span>.<span class="built_in">format</span>(os.getpid(), os.getppid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;主进程（Process：&#123;&#125;）开始执行...&quot;</span>.<span class="built_in">format</span>(os.getpid()))</span><br><span class="line">    process = multiprocessing.Process(target=worker)</span><br><span class="line">    process.start()</span><br><span class="line">    process.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，我们使用multiprocessing.Process类创建了一个子进程，并指定了其执行的函数。通过start()方法启动子进程，并通过join()方法等待子进程执行完毕。</p><h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><p>多个进程之间的数据交换和通信是一项关键任务。multiprocessing模块提供了多种机制来实现进程间通信，比如队列（Queue）、管道（Pipe）等。以下是一个使用队列进行进程间通信的范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">producer</span>(<span class="params">_queue</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        time.sleep(<span class="built_in">round</span>(random.random() * <span class="number">5</span>))</span><br><span class="line">        _queue.put(i)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;生产了数据:&quot;</span>, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">consumer</span>(<span class="params">_queue</span>):</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="built_in">round</span>(random.random() * <span class="number">3</span>))</span><br><span class="line">        data = _queue.get()</span><br><span class="line">        <span class="keyword">if</span> data <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;消费了数据:&quot;</span>, data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    queue = multiprocessing.Queue()</span><br><span class="line">    process1 = multiprocessing.Process(target=producer, args=(queue,))</span><br><span class="line">    process2 = multiprocessing.Process(target=consumer, args=(queue,))</span><br><span class="line">    process1.start()</span><br><span class="line">    process2.start()</span><br><span class="line">    process1.join()</span><br><span class="line">    process2.join()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上述示例中，我们通过multiprocessing.Queue创建了一个队列，用于在生产者进程和消费者进程之间传递数据。生产者进程通过put()方法向队列中放入数据，消费者进程通过get()方法从队列中获取数据。</p><h2 id="并行计算"><a href="#并行计算" class="headerlink" title="并行计算"></a>并行计算</h2><p>multiprocessing模块使得并行计算变得轻而易举。以下是一个简单的并行计算范例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">find_primes_within_n</span>(<span class="params">n</span>):</span><br><span class="line">    primes = []  <span class="comment"># 用于存放素数的列表</span></span><br><span class="line">    is_prime = [<span class="literal">True</span>] * (n + <span class="number">1</span>)  <span class="comment"># 初始化标记数组，初始时所有数都认为是素数</span></span><br><span class="line">    is_prime[<span class="number">0</span>], is_prime[<span class="number">1</span>] = <span class="literal">False</span>, <span class="literal">False</span>  <span class="comment"># 0和1不是素数</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):  <span class="comment"># 遍历2到n的所有数</span></span><br><span class="line">        <span class="keyword">if</span> is_prime[num]:  <span class="comment"># 如果当前数是素数</span></span><br><span class="line">            primes.append(num)  <span class="comment"># 将其加入素数列表</span></span><br><span class="line">            <span class="comment"># 将当前素数的倍数标记为非素数</span></span><br><span class="line">            <span class="keyword">for</span> multiple <span class="keyword">in</span> <span class="built_in">range</span>(num * num, n + <span class="number">1</span>, num):</span><br><span class="line">                is_prime[multiple] = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    numbers = [<span class="number">12213651</span>] * <span class="number">10</span></span><br><span class="line">    <span class="built_in">print</span>(numbers)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">        result.append(find_primes_within_n(number))</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;单进程运行时间&quot;</span>, end_time - start_time, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    pool = multiprocessing.Pool()</span><br><span class="line">    results = pool.<span class="built_in">map</span>(find_primes_within_n, numbers)</span><br><span class="line">    pool.close()</span><br><span class="line">    pool.join()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;多进程运行时间&quot;</span>, end_time - start_time, <span class="string">&quot;seconds&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的示例中，我们通过multiprocessing.Pool创建了一个进程池，并使用map()方法将任务分配给不同的子进程进行并行计算，最终得到了计算结果。</p><p>通过multiprocessing模块，我们可以更好地利用计算资源，加速程序的执行。让我们一起探索并发编程的奇妙世界，释放Python潜能，提升程序的计算效率。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re：天生适合匹配样式的神器</title>
      <link href="/posts/53007.html"/>
      <url>/posts/53007.html</url>
      
        <content type="html"><![CDATA[<p>在处理文本信息时，我们常常需要通过匹配特定的字符串来提取所需的数据。正则表达式是一种強大的字符串匹配工具，是处理和过滤文本信息的常用手段之一。在 Python 中，使用 re 模块可以轻松实现正则表达式的匹配操作。它给我们提供了一些强大的功能和语法，可以帮助快速开发出精简高效的代码。</p><h2 id="re模块的主要用途"><a href="#re模块的主要用途" class="headerlink" title="re模块的主要用途"></a>re模块的主要用途</h2><p>re 模块最主要的作用就是进行字符串的正则匹配。它可以非常灵活地支持使用正则表达式去进行匹配。其中，使用最多的四个方法是 <code>match</code>、<code>search</code>、<code>findall</code> 和 <code>sub</code> 。这些函数的基本用法如下：</p><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match()"></a>re.match()</h3><p>re.match() 函数主要用于从字符串的开头进行匹配，如果匹配成功，则返回一个Match对象，否则返回None。Match对象具有如下方法：</p><ul><li>group()：返回匹配到的字符串。</li><li>start()：返回匹配开始的位置。</li><li>end()：返回匹配结束的位置。</li><li>span()：返回一个元组，包含匹配开始和结束的位置。</li></ul><p>下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Hello, Python fans!&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">match_obj = re.<span class="keyword">match</span>(pattern, text)</span><br><span class="line"><span class="keyword">if</span> match_obj:</span><br><span class="line">    <span class="built_in">print</span>(match_obj.group())   <span class="comment"># 输出：Hello</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未匹配到任何字符串&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search()"></a>re.search()</h3><p>re.search() 函数在给定的文本中搜索一个正则表达式，实际上和re.match()几乎一样，所不同的是re.search()函数在字符串整个范围内进行搜索，而不只是字符串开始的部分。</p><p>下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Hello, Python fans!&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;Python&quot;</span></span><br><span class="line"></span><br><span class="line">match_obj = re.search(pattern, text)</span><br><span class="line"><span class="keyword">if</span> match_obj:</span><br><span class="line">    <span class="built_in">print</span>(match_obj.group())   <span class="comment"># 输出：Python</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;未匹配到任何字符串&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall()"></a>re.findall()</h3><p>re.findall() 函数找到文本中所有匹配正则表达式的部分，并以字符串列表的形式返回它们。如果正则表达式包含捕获组，那么返回的列表会包含每个组包含的字符串。</p><p>下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;John has 6 apples and 2 oranges&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;\d+&quot;</span></span><br><span class="line"></span><br><span class="line">result_list = re.findall(pattern, text)</span><br><span class="line"><span class="built_in">print</span>(result_list)   <span class="comment"># 输出: [&#x27;6&#x27;, &#x27;2&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="re-sub"><a href="#re-sub" class="headerlink" title="re.sub()"></a>re.sub()</h3><p>re.sub() 函数可以将匹配正则表达式的所有子字符串进行替换，并返回结果，可以使用它来处理文本的格式或者进行文本数据的特定处理。具体来说，该函数包括四个参数：pattern、repl、string、count，其中pattern表示需要进行匹配的正则表达式，repl表示需要替换的字符串，string表示需要进行操作的字符串，count表示需要替换的最大次数，它是可选参数，默认值为0。</p><p>示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;Python是一门多用途、高级编程语言。&quot;</span></span><br><span class="line">pattern = <span class="string">r&quot;高级编程语言&quot;</span></span><br><span class="line">replace_str = <span class="string">&quot;通用编程语言&quot;</span></span><br><span class="line"></span><br><span class="line">new_text = re.sub(pattern, replace_str, text)</span><br><span class="line"><span class="built_in">print</span>(new_text)   <span class="comment"># 输出：Python是一门多用途、通用编程语言。</span></span><br></pre></td></tr></table></figure><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>re 模块提供了一些标志（flags），用于修改正则表达式模式的行为。这些标志通常通过第三个可选参数（旧版本还有第四个参数）传递给 re.compile() 函数或 re 函数的匹配方法中。以下是 re 模块最常用的标志：</p><ul><li><p><strong>re.I / re.IGNORECASE</strong>: 忽略大小写匹配。这个标志告诉 re 模块在匹配时忽略大小写，例如，表达式 <code>[A-Z]</code> 能够匹配小写字母。</p></li><li><p><strong>re.M / re.MULTILINE</strong>: 多行匹配。 多行模式是一个标志，使得元字符 ‘^’ 和 ‘$’ 分别匹配整个字符串中每一行的开始和结束位置，而不是仅仅匹配整个字符串的开始和结束位置。</p></li><li><p><strong>re.S / re.DOTALL</strong>: 点号匹配全部字符。  默认模式下.点号匹配除 ‘\n’（换行符）之外的任何字符。当使用 re.S 或 re.DOTALL 标志时，点号将会匹配包括换行符在内的任何字符。</p></li><li><p><strong>re.L / re.LOCALE</strong>: 做本地化识别（locale-aware）匹配。 只在某些非英语环境下有意义。它可以为一些特殊字符（如\xYY序列）提供本地化映射。</p></li><li><p><strong>re.U / re.UNICODE</strong>: 使用 Unicode 规则进行匹配。 默认情况下，非 ASCII 字符将仅匹配本身。如果使用了这个标志，则能匹配 Unicode 字符。</p></li><li><p><strong>re.X / re.VERBOSE</strong>: Verbose模式。 该标志告诉 re 解释器忽略空白和注释。</p></li></ul><p>以下是一个示例，演示如何使用多个标志：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">text = <span class="string">&quot;&quot;&quot;Hello World</span></span><br><span class="line"><span class="string">This is a multiline string</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># re.I：忽略大小写</span></span><br><span class="line"><span class="comment"># re.S：匹配换行符</span></span><br><span class="line">pattern = <span class="string">r&quot;hello.*?string&quot;</span></span><br><span class="line"><span class="keyword">match</span> = re.search(pattern, text, re.I | re.S)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">match</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Match found:&quot;</span>, <span class="keyword">match</span>.group())</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;No match&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个示例中，我们通过使用<code>re.I</code>和<code>re.S</code>标志来忽略大小写和匹配换行符。我们可以通过将它们作为第三个参数传递给<code>re.search</code>函数来使用这些标志。该模式尝试匹配字符串中以 hello 开头、以 string 结尾的内容，而不区分大小写，同时在多个行中进行匹配。</p><h2 id="基本的正则表达式语法"><a href="#基本的正则表达式语法" class="headerlink" title="基本的正则表达式语法"></a>基本的正则表达式语法</h2><p>正则表达式可以包含各种字符，包括普通字符和特殊字符。其中，大多数普通字符表示自字母、数字和标点符号等，而特殊字符表示匹配一类特殊字符串的模式。下面是在 Python 中使用正则表达式的一些基本语法：</p><ul><li><code>.</code> ：通配符，代表能匹配任意单个字符（除了换行符）</li><li><code>^</code> ：匹配字符串的开头位置</li><li><code>$</code> ：匹配字符串的结尾位置</li><li><code>*</code> ：匹配0个或多个前一个字符</li><li><code>+</code> ：匹配1个或多个前一个字符</li><li><code>[]</code> ：代表能够匹配一组字符中的任意一个字符</li><li><code>[a-z]</code> ：可以匹配 a～z 中任意一个字母区分大小写。</li></ul><h2 id="re模块的一些实用技巧"><a href="#re模块的一些实用技巧" class="headerlink" title="re模块的一些实用技巧"></a>re模块的一些实用技巧</h2><p>在使用 re 模块的过程中，我们还可以使用一些技巧来提高使用效率。以下是一些常用的技巧：</p><ul><li>使用贪婪模式：尽量匹配到最后一项，匹配更多的字符。</li><li>匹配优先级：从左到右进行匹配，匹配到满足条件的字符后继续向右匹配下一个字符。</li><li>使用零宽断言：占用零字符，不会消耗字符，零宽断言可以使用 <code>(?=</code>) 和 <code>(?! )</code> 其中，<code>(?=)</code>表示正前向零宽断言和<code>(?! )</code>表示负前向零宽断言。</li><li>使用多行模式：一次性搜索多行文本。可以使用 <code>re.MULTILINE</code> 标志启用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shutil：高效操控文件和目录的魔法工具</title>
      <link href="/posts/55569.html"/>
      <url>/posts/55569.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在日常的编程工作中，我们常常需要处理文件和目录的操作，例如复制、移动、重命名等。而Python中的<code>shutil</code>模块则是处理这些任务的魔法工具。通过<code>shutil</code>模块，我们能够以简单而高效的方式操控文件和目录，为我们的编程工作带来便利和效率的提升。</p><h2 id="Shutil模块的功能"><a href="#Shutil模块的功能" class="headerlink" title="Shutil模块的功能"></a>Shutil模块的功能</h2><p><code>shutil</code>模块是Python中一个强大的标准库，提供了丰富的功能，包括但不限于：</p><ul><li>复制文件和目录</li><li>移动文件和目录</li><li>重命名文件和目录</li><li>删除文件和目录</li><li>创建目录和子目录</li><li>压缩和解压缩文件</li><li>监控目录变化</li><li>…</li></ul><p>无论是简单的文件操作，还是复杂的目录操作，<code>shutil</code>模块都能够帮助我们轻松应对。</p><h2 id="文件操作示例"><a href="#文件操作示例" class="headerlink" title="文件操作示例"></a>文件操作示例</h2><p>下面是一些使用<code>shutil</code>模块进行文件和目录操作的示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在source.txt</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isfile(<span class="string">&#x27;source.txt&#x27;</span>):</span><br><span class="line">    <span class="comment"># 没有则创建</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;source.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;Hello World!!&quot;</span>)</span><br><span class="line"><span class="comment"># 判断是否存在destination.txt</span></span><br><span class="line"><span class="keyword">if</span> os.path.isfile(<span class="string">&#x27;destination.txt&#x27;</span>):</span><br><span class="line">    <span class="comment"># 存在则删除文件</span></span><br><span class="line">    os.remove(<span class="string">&#x27;destination.txt&#x27;</span>)</span><br><span class="line"><span class="comment"># 示例1: 复制文件</span></span><br><span class="line">shutil.copy(<span class="string">&#x27;source.txt&#x27;</span>, <span class="string">&#x27;destination.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在source_folder</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.isdir(<span class="string">&#x27;./source_folder&#x27;</span>):</span><br><span class="line">    os.mkdir(<span class="string">&#x27;source_folder&#x27;</span>)</span><br><span class="line"><span class="comment"># 判断是否存在destination_folder</span></span><br><span class="line"><span class="keyword">if</span> os.path.isdir(<span class="string">&#x27;./destination_folder&#x27;</span>):</span><br><span class="line">    <span class="comment"># 级联删除文件夹</span></span><br><span class="line">    shutil.rmtree(<span class="string">&#x27;./destination_folder&#x27;</span>)</span><br><span class="line"><span class="comment"># 示例2: 复制目录</span></span><br><span class="line">shutil.copytree(<span class="string">&#x27;source_folder&#x27;</span>, <span class="string">&#x27;destination_folder&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例3: 移动文件</span></span><br><span class="line">shutil.move(<span class="string">&#x27;source.txt&#x27;</span>, <span class="string">&#x27;./destination_folder/destination.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例4: 重命名文件</span></span><br><span class="line">shutil.move(<span class="string">&#x27;destination.txt&#x27;</span>, <span class="string">&#x27;destination_bk.txt&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例5: 压缩文件</span></span><br><span class="line">shutil.make_archive(<span class="string">&#x27;archive&#x27;</span>, <span class="string">&#x27;zip&#x27;</span>, <span class="string">&#x27;./destination_folder&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.isdir(<span class="string">&#x27;./destination_folder1&#x27;</span>):</span><br><span class="line">    shutil.rmtree(<span class="string">&#x27;./destination_folder1&#x27;</span>)</span><br><span class="line"><span class="comment"># 示例8: 解压缩文件</span></span><br><span class="line">shutil.unpack_archive(<span class="string">&#x27;archive.zip&#x27;</span>, <span class="string">&#x27;destination_folder1&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过以上示例，我们可以看到<code>shutil</code>模块提供的简洁而强大的接口，能够轻松实现文件和目录的复制、移动、重命名、删除、创建、压缩、解压缩等操作。</p><p><strong>参考资料：</strong></p><ul><li><a href="https://docs.python.org/3/library/shutil.html">Python shutil模块文档</a></li><li><a href="https://www.python.org/">Python官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>io：文件操作的瑞士军刀</title>
      <link href="/posts/22313.html"/>
      <url>/posts/22313.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在 Python 中，文件的读写操作是我们经常会遇到的任务之一。而 IO 模块为我们提供了丰富的功能和灵活的接口，使得文件读写变得更加简单、高效。无论是处理文本文件，还是处理二进制文件，IO 模块都能满足我们的需求，并帮助我们完成各种文件操作任务。</p><h2 id="IO模块的功能"><a href="#IO模块的功能" class="headerlink" title="IO模块的功能"></a>IO模块的功能</h2><h3 id="文件读写操作"><a href="#文件读写操作" class="headerlink" title="文件读写操作"></a>文件读写操作</h3><ul><li>打开文件并获取文件对象</li><li>读取文件内容（文本或二进制）</li><li>写入数据到文件</li><li>关闭文件</li></ul><h3 id="文件对象的方法"><a href="#文件对象的方法" class="headerlink" title="文件对象的方法"></a>文件对象的方法</h3><ul><li><code>read(size=None)</code>：读取指定大小的数据</li><li><code>write(data)</code>：写入数据到文件</li><li><code>seek(offset, whence=0)</code>：移动文件指针</li><li><code>tell()</code>：返回文件指针的当前位置</li><li><code>close()</code>：关闭文件</li></ul><h3 id="文件打开模式"><a href="#文件打开模式" class="headerlink" title="文件打开模式"></a>文件打开模式</h3><ul><li><code>r</code>：只读模式</li><li><code>w</code>：写入模式</li><li><code>a</code>：追加模式</li><li><code>b</code>：二进制模式</li><li><code>+</code>：读写模式</li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是几个示例代码，展示了如何使用 IO 模块进行文件读写操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取文本文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;r&quot;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    content = file.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取二进制文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;image.jpg&quot;</span>, <span class="string">&quot;rb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    data = file.read()</span><br><span class="line">    <span class="comment"># 处理二进制数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据到文件file.txt</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;file.txt&quot;</span>, <span class="string">&quot;a&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="built_in">str</span>(data))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据到二进制文件image1.jpg  相当于复制</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;image1.jpg&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><ul><li><a href="https://docs.python.org/3/library/io.html">Python IO 模块文档</a></li><li><a href="https://www.python.org/">Python官方文档</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>os：探索文件和目录操作的利器</title>
      <link href="/posts/62812.html"/>
      <url>/posts/62812.html</url>
      
        <content type="html"><![CDATA[<p>在Python中，<code>os</code>模块是一个强大而又常用的模块，它提供了许多功能，用于操作操作系统的文件和目录结构。通过使用<code>os</code>模块，我们可以轻松地完成各种文件和目录的操作，包括创建、删除、重命名和移动等。</p><h2 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h2><p><code>os</code>模块提供了以下基本功能：</p><ul><li>获取和更改当前工作目录</li><li>执行系统命令</li><li>创建、删除、重命名和移动文件或目录</li><li>查看和更改文件属性</li><li>时间相关的功能，如获取和更改文件的最后访问时间和最后修改时间</li></ul><h2 id="获取和更改当前工作目录"><a href="#获取和更改当前工作目录" class="headerlink" title="获取和更改当前工作目录"></a>获取和更改当前工作目录</h2><p>我们可以使用<code>os.getcwd()</code>函数获取当前的工作目录，使用<code>os.chdir()</code>函数更改当前工作目录。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前目录</span></span><br><span class="line">current_path = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;当前工作目录：&quot;</span>, current_path)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到新目录</span></span><br><span class="line">os.chdir(<span class="string">r&quot;C:\Users\Administrator\Desktop&quot;</span>)</span><br><span class="line">new_path = os.getcwd()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;更改后的工作目录：&quot;</span>, new_path)</span><br></pre></td></tr></table></figure><h2 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h2><p>通过<code>os.system()</code>函数，我们可以在Python中执行操作系统命令。例如，在控制台中执行<code>dir</code>命令或创建一个新目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在控制台中执行dir命令</span></span><br><span class="line">os.system(<span class="string">&quot;dir&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在控制台中直接创建一个新目录</span></span><br><span class="line">os.system(<span class="string">&quot;mkdir NewDirectory&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="对文件和目录进行操作"><a href="#对文件和目录进行操作" class="headerlink" title="对文件和目录进行操作"></a>对文件和目录进行操作</h2><p><code>os</code>模块还提供了许多用于操作文件和目录的函数：</p><ul><li><code>os.mkdir()</code>：创建新目录</li><li><code>os.rmdir()</code>：删除目录</li><li><code>os.makedirs()</code>：创建多级目录</li><li><code>os.rename()</code>：重命名文件或目录</li><li><code>os.remove()</code>：删除文件</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新目录</span></span><br><span class="line">os.mkdir(<span class="string">&quot;NewDirectory&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在NewDirectory目录下创建新文件，写入一些数据</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;NewDirectory/test.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;This is a test.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重命名文件</span></span><br><span class="line">os.rename(<span class="string">&quot;NewDirectory/test.txt&quot;</span>, <span class="string">&quot;NewDirectory/new_test.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">os.remove(<span class="string">&quot;NewDirectory/new_test.txt&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除目录</span></span><br><span class="line">os.rmdir(<span class="string">&quot;NewDirectory&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="文件和目录属性操作"><a href="#文件和目录属性操作" class="headerlink" title="文件和目录属性操作"></a>文件和目录属性操作</h2><p><code>os</code>模块提供的<code>os.path</code>子模块，用于检查和更改文件或目录的属性：</p><ul><li><code>os.path.isfile(path)</code>：用于检查提供的路径是否为文件</li><li><code>os.path.isdir(path)</code>：用于检查提供的路径是否为目录</li><li><code>os.path.exists(path)</code>：用于检查提供的路径是否存在</li><li><code>os.listdir(path)</code>：用于获取指定目录下的文件和目录</li><li><code>os.path.isabs(path)</code>：用于检查提供的路径是否是绝对路径</li><li><code>os.path.split(path)</code>：用于分离提供路径的文件名（带后缀）和目录名</li><li><code>os.path.splitext(path)</code>：用于分离提供路径的文件名（不带后缀）和目录名</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查路径是否存在</span></span><br><span class="line">path = <span class="string">&quot;/Users/username/Documents/test.txt&quot;</span></span><br><span class="line"><span class="keyword">if</span> os.path.exists(path):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件存在&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;文件不存在&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前文件绝对路径</span></span><br><span class="line">path1 = os.path.abspath(__file__)</span><br><span class="line"><span class="comment"># 判断是否是绝对路径</span></span><br><span class="line"><span class="keyword">if</span> os.path.isabs(path1):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前文件的绝对路径为：&#x27;</span> + path1)</span><br><span class="line">    path2, file2 = os.path.split(path1)</span><br><span class="line">    <span class="keyword">if</span> os.path.isdir(path2):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;当前文件的目录为：&#x27;</span> + path2)</span><br><span class="line">    <span class="keyword">if</span> os.path.isfile(path1):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;当前文件的文件名为：&#x27;</span> + file2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>certifi：保障Python与Https服务器间的安全连接</title>
      <link href="/posts/50810.html"/>
      <url>/posts/50810.html</url>
      
        <content type="html"><![CDATA[<p>当涉及到使用 Python 发起 HTTPS 请求时，保证安全和验证服务器的身份是至关重要的。而 <code>certifi</code> 是一个非常有用的第三方库，它提供了一个包含 CA 证书的集合，用于验证 HTTPS 服务器的证书。本篇博客将会介绍 <code>certifi</code> 库的使用方法和原理。</p><h2 id="用-certifi-验证-HTTPS-服务器的身份"><a href="#用-certifi-验证-HTTPS-服务器的身份" class="headerlink" title="用 certifi 验证 HTTPS 服务器的身份"></a>用 certifi 验证 HTTPS 服务器的身份</h2><p>在 Python 中，我们通常使用 <code>requests</code>、<code>urllib</code> 或 <code>urllib3</code> 等库来发起 HTTP 请求。当我们尝试与一个使用 HTTPS 协议的服务器通信时，需要帐户安全性的基本保证。这就需要进行证书验证，以确保我们正在连接到正确的服务器，而不是被中间人攻击。</p><p><code>certifi</code> 库可以帮助我们处理这个验证过程。它提供了一个完整的 CA 证书集合，用于验证常见的公共 CA 颁发机构的证书。让我们来看看如何使用 <code>certifi</code> 进行 SSL/TLS 证书验证。</p><h2 id="安装-certifi"><a href="#安装-certifi" class="headerlink" title="安装 certifi"></a>安装 certifi</h2><p>首先，确保已在 Python 环境中安装 <code>certifi</code> 库。可以使用 pip 包管理器来安装它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install certifi</span><br></pre></td></tr></table></figure><h2 id="使用-certifi-进行证书验证"><a href="#使用-certifi-进行证书验证" class="headerlink" title="使用 certifi 进行证书验证"></a>使用 certifi 进行证书验证</h2><p>一旦我们安装了 <code>certifi</code> 库，就可以在代码中使用它来验证 HTTPS 服务器的证书。以下是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.cheneyblog.com&#x27;</span></span><br><span class="line"></span><br><span class="line">response = requests.get(url, verify=certifi.where())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Connection successful! Server identity verified.&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Failed to establish a secure connection.&#x27;</span>)</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了 <code>requests</code> 库来发起一个 GET 请求，并指定了我们要连接的 URL。在请求中，我们将 <code>verify</code> 参数设置为 <code>certifi.where()</code> 方法的返回值。<code>certifi.where()</code> 方法返回了一个标识 CA 证书路径的字符串。</p><p>当我们发起请求时，<code>requests</code> 库将使用 <code>certifi</code> 库提供的 CA 证书路径进行证书验证。如果服务器的证书能够通过验证，我们将获得一个状态码为 200 的响应，并打印出 “Connection successful! Server identity verified.” 的消息。否则，我们将得到一个失败的响应，并打印出 “Failed to establish a secure connection.” 的消息。</p><h2 id="为何使用-certifi"><a href="#为何使用-certifi" class="headerlink" title="为何使用 certifi"></a>为何使用 certifi</h2><p>使用 <code>certifi</code> 的一个主要优点是它提供了一个可靠的、更新的 CA 证书集合。这意味着任何新的 CA 证书颁发机构或吊销的证书都会及时地反映在 <code>certifi</code> 的集合中。这样，我们就可以确保与最新的 CA 证书集合保持同步，从而提高安全性。</p><p>除了 <code>requests</code> 库，还可以在其他发起 HTTP 请求的库中使用 <code>certifi</code> 进行证书验证，比如 <code>urllib</code> 和 <code>urllib3</code>。只需将 <code>verify</code> 参数设置为 <code>certifi.where()</code> 即可。</p><p>总结一下，<code>certifi</code> 是一个非常有用的第三方库，它为我们提供了一个可靠的 CA 证书集合，用于验证 HTTPS 服务器的证书。通过使用 <code>certifi</code>，我们可以确保与服务器建立安全的连接，从而避免安全漏洞和中间人攻击。在使用 Python 发起 HTTPS 请求时，强烈建议使用 <code>certifi</code> 来增强安全性。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>urllib3：使网络请求变得简单易懂</title>
      <link href="/posts/42010.html"/>
      <url>/posts/42010.html</url>
      
        <content type="html"><![CDATA[<p>在使用 Python 进行网络编程时，经常用到一些网络请求的操作。随着互联网应用的不断增多，从简单的 HTTP 请求到复杂的 RESTful 接口，需要用到的库也越来越多。其中，urllib3 库就是一个非常强大的 Python 第三方库，它能够帮助我们更加方便快捷地进行网络请求操作。</p><h2 id="什么是-urllib3？"><a href="#什么是-urllib3？" class="headerlink" title="什么是 urllib3？"></a>什么是 urllib3？</h2><p>urllib3 是 Python 的一个第三方库，它是 Python 标准库 urllib 和 httplib 的完美结合，并为它们提供了一些非常有用的功能扩展。</p><p>主要特点包括：</p><ul><li>连接池管理</li><li>请求重试</li><li>HTTP(S) 代理支持</li><li>支持文件上传</li><li>支持在线文件压缩</li><li>支持单位换算（比如将字节转成 MB）</li></ul><h2 id="安装-urllib3"><a href="#安装-urllib3" class="headerlink" title="安装 urllib3"></a>安装 urllib3</h2><p>安装 urllib3 可以通过 pip 进行安装，打开命令行并输入以下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install urllib3</span><br></pre></td></tr></table></figure><p>即可安装 urllib3。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="urlencode"><a href="#urlencode" class="headerlink" title="urlencode"></a><code>urlencode</code></h3><p>在<code>urllib3</code>中，<code>urlencode</code>是一个用于将字典或元组列表编码为URL查询字符串的工具函数。这个函数可以将提供的参数序列化为符合HTTP规范的URL编码格式。</p><p>使用<code>urlencode</code>函数，你可以将字典或元组列表编码为查询字符串，然后将其添加到URL中以向服务器发送GET请求或POST请求。</p><p>下面是<code>urllib3</code>中<code>urlencode</code>函数的使用示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">from</span> urllib3 <span class="keyword">import</span> PoolManager</span><br><span class="line"></span><br><span class="line">data = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>&#125;</span><br><span class="line">encoded_data = urlencode(data)</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://www.example.com/login?&#x27;</span> + encoded_data</span><br><span class="line"></span><br><span class="line">http = PoolManager()</span><br><span class="line">response = http.request(<span class="string">&#x27;GET&#x27;</span>, url)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(response.data)</span><br></pre></td></tr></table></figure><p>在上面的例子中，我们首先创建了一个名为<code>data</code>的字典，其中包含了用户名和密码的键值对。然后，我们使用<code>urlencode</code>函数将这个字典编码为URL查询字符串，并将其存储在<code>encoded_data</code>变量中。接下来，我们将这个编码后的查询字符串添加到URL中并发送GET请求。最后，我们打印服务器响应的内容。</p><p>请注意，<code>urlencode</code>函数在导入时是从<code>urllib.parse</code>模块中引入的，而不是直接从<code>urllib3</code>模块中引入。这是因为<code>urlencode</code>函数实际上是来自Python内置的标准库<code>urllib.parse</code>中的函数。</p><h2 id="如何使用-urllib3"><a href="#如何使用-urllib3" class="headerlink" title="如何使用 urllib3"></a>如何使用 urllib3</h2><h3 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h3><p>在使用 urllib3 发送 HTTP 请求时，需要创建一个 <code>PoolManager</code> 的对象，通过这个对象来完成请求。具体的代码实现如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">http = urllib3.PoolManager()</span><br><span class="line"></span><br><span class="line">response = http.request(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;www.baidu.com&quot;</span>)</span><br><span class="line"><span class="comment"># 状态码</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;状态码：&quot;</span> + <span class="built_in">str</span>(response.status))</span><br><span class="line"><span class="comment"># 响应头</span></span><br><span class="line">header = response.info()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;响应头信息如下&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> header.keys():</span><br><span class="line">    <span class="built_in">print</span>(key, <span class="string">&quot;:&quot;</span>, header.get(key))</span><br></pre></td></tr></table></figure><p>这段代码的作用是发送一个 GET 请求，请求百度的网址。执行后我们可以获得到 response 的信息，比如其状态码、响应头、响应体等等信息。</p><h3 id="POST-请求"><a href="#POST-请求" class="headerlink" title="POST 请求"></a>POST 请求</h3><p>发送 POST 请求时，需要使用到 <code>request()</code> 函数的 <code>body</code> 参数，该参数的内容为一个字符串，表示 POST 请求的数据。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"></span><br><span class="line">http = urllib3.PoolManager()</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;john&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;password&#x27;</span>: <span class="string">&#x27;pass&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">encoded_data = urllib3.encode_multipart_formdata(data)</span><br><span class="line"></span><br><span class="line">response = http.request(</span><br><span class="line">    <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;http://httpbin.org/post&#x27;</span>,</span><br><span class="line">    body=encoded_data[<span class="number">0</span>],</span><br><span class="line">    headers=&#123;<span class="string">&#x27;Content-Type&#x27;</span>: encoded_data[<span class="number">1</span>]&#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br></pre></td></tr></table></figure><h3 id="HTTPS-支持"><a href="#HTTPS-支持" class="headerlink" title="HTTPS 支持"></a>HTTPS 支持</h3><p><code>urllib3</code> 库通过 Certifi 库提供对 HTTPS 连接的支持。它处理了与 SSL/TLS 握手、证书验证和加密通信等相关的复杂细节，以提供简单易用的 HTTPS 客户端功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> certifi</span><br><span class="line"></span><br><span class="line">http = urllib3.PoolManager(ca_certs=certifi.where())</span><br><span class="line">response = http.request(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;https://baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.status)</span><br><span class="line"><span class="built_in">print</span>(response.data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure><h3 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h3><p>urllib3 使用连接池来管理 HTTP 请求时建立的连接，这样可以提高请求的效率，减少连接的建立和关闭的开销。如果你需要发送多个请求，就可以使用连接池来重用已经建立好的连接，并发出多个请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib3</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line">http = urllib3.PoolManager(num_pools=<span class="number">10</span>, maxsize=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_request</span>(<span class="params">_url</span>):</span><br><span class="line">    response = http.request(<span class="string">&#x27;GET&#x27;</span>, _url)</span><br><span class="line">    <span class="built_in">print</span>(response.status)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line">urls = [<span class="string">&#x27;https://www.baidu.com/&#x27;</span>, <span class="string">&#x27;https://www.cheneyblog.com/&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">    t = threading.Thread(target=send_request, args=(url,))</span><br><span class="line">    t.start()</span><br><span class="line">    threads.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">    t.join()</span><br></pre></td></tr></table></figure><p>这里创建了一个有 10 个连接池，每个连接池最多可以建立 3 个连接的 <code>PoolManager</code> 对象，通过多线程同时请求百度和 cheneyblog 的网站。可以看到，每个连接池最多只有 3 个连接，这样就可以有效地节约资源。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python-whois:轻松获取网站的WHOIS信息</title>
      <link href="/posts/63921.html"/>
      <url>/posts/63921.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是python-whois"><a href="#什么是python-whois" class="headerlink" title="什么是python-whois?"></a>什么是<code>python-whois</code>?</h2><p>首先，让我们来了解一下什么是WHOIS。WHOIS是一种能够查询域名注册相关信息的协议。它可以告诉我们一个域名的所有者、注册时间、过期时间以及注册商等等。而<code>python-whois</code>正是基于这个协议，提供了一个简便的方式来获取域名的WHOIS信息。</p><h2 id="安装python-whois"><a href="#安装python-whois" class="headerlink" title="安装python-whois"></a>安装<code>python-whois</code></h2><p>在开始使用<code>python-whois</code>之前，我们需要先安装它。打开终端，运行以下命令即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-whois</span><br></pre></td></tr></table></figure><p>安装完成后，我们就可以开始使用这个强大的工具了！</p><h2 id="如何使用python-whois"><a href="#如何使用python-whois" class="headerlink" title="如何使用python-whois"></a>如何使用<code>python-whois</code></h2><p>使用<code>python-whois</code>非常简单。只需几行代码，就能获取到想要的WHOIS信息。下面是一个示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> whois</span><br><span class="line"></span><br><span class="line">domain = <span class="string">&#x27;cheneyblog.com&#x27;</span></span><br><span class="line">info = whois.whois(domain)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure><p>这段代码首先导入了<code>whois</code>模块，然后我们指定了一个域名（例如”cheneyblog.com”），并调用了<code>whois.whois()</code>函数来获取该域名的WHOIS信息。最后，我们打印出了这些信息。</p><p>运行这段代码，你就能看到类似以下的输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;domain_name&quot;</span>: [   </span><br><span class="line">    <span class="string">&quot;CHENEYBLOG.COM&quot;</span>,</span><br><span class="line">    <span class="string">&quot;cheneyblog.com&quot;</span> </span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;registrar&quot;</span>: <span class="string">&quot;DNSPod, Inc.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;whois_server&quot;</span>: <span class="string">&quot;whois.dnspod.com&quot;</span>,</span><br><span class="line">  <span class="string">&quot;referral_url&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;updated_date&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;2023-09-04 04:25:41&quot;</span>,</span><br><span class="line">    <span class="string">&quot;2023-09-04 12:25:41&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;creation_date&quot;</span>: <span class="string">&quot;2023-04-02 18:19:39&quot;</span>,</span><br><span class="line">  <span class="string">&quot;expiration_date&quot;</span>: <span class="string">&quot;2025-04-02 18:19:39&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name_servers&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;CLAY.DNSPOD.NET&quot;</span>,</span><br><span class="line">    <span class="string">&quot;COSINE.DNSPOD.NET&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;status&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;ok https://icann.org/epp#ok&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ok https://www.icann.org/epp#ok&quot;</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;emails&quot;</span>: <span class="string">&quot;abuse@dnspod.com&quot;</span>,</span><br><span class="line">  <span class="string">&quot;dnssec&quot;</span>: <span class="string">&quot;unsigned&quot;</span>,</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;REDACTED FOR PRIVACY&quot;</span>,</span><br><span class="line">  <span class="string">&quot;org&quot;</span>: <span class="string">&quot;REDACTED FOR PRIVACY&quot;</span>,</span><br><span class="line">  <span class="string">&quot;address&quot;</span>: <span class="string">&quot;REDACTED FOR PRIVACY&quot;</span>,</span><br><span class="line">  <span class="string">&quot;city&quot;</span>: <span class="string">&quot;REDACTED FOR PRIVACY&quot;</span>,</span><br><span class="line">  <span class="string">&quot;state&quot;</span>: null,</span><br><span class="line">  <span class="string">&quot;registrant_postal_code&quot;</span>: <span class="string">&quot;REDACTED FOR PRIVACY&quot;</span>,</span><br><span class="line">  <span class="string">&quot;country&quot;</span>: <span class="string">&quot;CN&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="python-whois的优势"><a href="#python-whois的优势" class="headerlink" title="python-whois的优势"></a><code>python-whois</code>的优势</h2><p>相比起手动查询WHOIS信息，使用<code>python-whois</code>有许多优势。首先，它非常方便快捷，只需几行代码就能获得所需的信息。其次，它能够以结构化的方式返回信息，便于我们后续的处理和分析。最重要的是，<code>python-whois</code>支持国际化域名（IDN），能够正确解析和处理这些特殊的域名。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cookie与Session：互联网世界的甜点与记忆法</title>
      <link href="/posts/63189.html"/>
      <url>/posts/63189.html</url>
      
        <content type="html"><![CDATA[<p>当今互联网世界中，我们经常会听到Cookie和Session这两个名词，它们在实现用户认证、数据存储等方面发挥着重要作用。那么，Cookie和Session究竟是什么呢？让我为你一一解答。</p><h2 id="Cookie和Session是什么？"><a href="#Cookie和Session是什么？" class="headerlink" title="Cookie和Session是什么？"></a>Cookie和Session是什么？</h2><p>在互联网浏览器与服务器之间进行通信时，Cookie和Session被用来跟踪用户的身份和状态。简而言之，Cookie是存储在用户计算机上的一小段数据，而Session则是存储在服务器端的数据结构。</p><h3 id="Cookie：浏览器端的小甜点"><a href="#Cookie：浏览器端的小甜点" class="headerlink" title="Cookie：浏览器端的小甜点"></a>Cookie：浏览器端的小甜点</h3><p>Cookie就像是浏览器端的小甜点，每当你访问一个网页时，服务器都会通过HTTP响应头中的Set-Cookie字段将Cookie发送给你的浏览器。浏览器会保存这些Cookie，并在你下一次访问同一网站时将它们发送回服务器。</p><p>Cookie的工作方式：服务器给每个Session分配一个唯一的JSESSIONID,并通过Cookie发送给客户端。当客户端发起新的请求的时候，将在Cookie头中携带这个JSESSIONID。这样服务器能够找到这个客户端对应的Session。</p><p>Cookie可以存储用户的身份信息、偏好设置等数据。例如，当你登录某个网站时，服务器会发送一个包含你的用户ID的Cookie给你，以便在你下次访问时能够识别你的身份。</p><h3 id="Session：服务器端的记事本"><a href="#Session：服务器端的记事本" class="headerlink" title="Session：服务器端的记事本"></a>Session：服务器端的记事本</h3><p>与Cookie不同，Session是存储在服务器端的数据结构。当你访问一个使用Session的网站时，服务器会为你创建一个唯一的Session ID，并将它发送给你的浏览器。浏览器会将这个Session ID保存起来，并在你访问其他页面时将它发送回服务器。</p><p>服务器使用Session ID来查找与之相关联的Session数据。Session可以用于存储用户的登录状态、购物车内容等信息。每个用户都拥有一个唯一的Session，并且服务器会在一定时间内保持这个Session的有效期。</p><h2 id="Cookie和Session的使用场景"><a href="#Cookie和Session的使用场景" class="headerlink" title="Cookie和Session的使用场景"></a>Cookie和Session的使用场景</h2><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie通常用于以下几个场景：</p><ul><li><p>用户身份认证：服务器可以通过Cookie来识别用户身份，实现登录功能。</p></li><li><p>记住用户偏好：例如，用户可以选择记住语言设置，下次访问时网站会根据Cookie中的设置自动切换语言。</p></li><li><p>广告跟踪：广告商可以使用Cookie来追踪用户在不同网站上的浏览记录，从而提供个性化的广告展现。</p></li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session通常用于以下几个场景：</p><ul><li><p>购物车功能：当用户选择商品并加入购物车时，服务器可以将商品信息存储在Session中，方便用户在结账时查看和编辑购物车内容。</p></li><li><p>用户登录状态管理：服务器可以使用Session来跟踪用户的登录状态，确保用户在一定时间内的访问都被认为是已登录状态。</p></li><li><p>敏感数据存储：由于Session数据存储在服务器端，因此可以保存一些敏感数据，如用户的个人信息。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cookie和Session在互联网中扮演着重要的角色。Cookie存储在浏览器端，用于跟踪用户的身份和偏好设置；而Session存储在服务器端，用于存储用户的状态和敏感数据。它们的应用场景各有不同，但都是为了提供更好的用户体验和功能支持。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>子查询展开：揭秘Oracle的“嵌套奇迹”</title>
      <link href="/posts/51875.html"/>
      <url>/posts/51875.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是子查询展开？"><a href="#什么是子查询展开？" class="headerlink" title="什么是子查询展开？"></a>什么是子查询展开？</h2><p>子查询展开是一种查询优化技术，它可以将一个包含子查询的查询语句转换为等效的、不包含子查询的查询语句，从而提高查询的执行效率。<br>子查询展开的具体含义是将子查询中的SQL语句嵌入到外部查询语句中，从而构成一个新的查询语句。这个新的查询语句会使用到原子查询中用到的表，条件和操作符等，从而达到与原子查询相同的功能。<br>子查询展开可以将复杂的逻辑转换为更简单、更高效的查询计划，并减少多次访问数据库的次数。</p><h2 id="为什么要使用子查询展开？"><a href="#为什么要使用子查询展开？" class="headerlink" title="为什么要使用子查询展开？"></a>为什么要使用子查询展开？</h2><p>好了，我们知道什么是子查询展开了，接下来让我们来探讨一下为什么要使用子查询展开。<br>因为如果原SQL不做子查询展开，那么通常情况下该子查询就会在其执行计划的最后一步才被执行，并且会走FILTER类型的执行计划，这也就意味着对于外部查询所在结果集中的每一条记录，该子查询都会被当作一个独立的执行单元来执行一次，外部查询所在的结果集有多少条记录，该子查询就会被执行多少次。<br>子查询展开后优化器就会有其他更多、更高效的执行路径(比如哈希连接)可以选择。使用子查询展开也就大大提高查询性能，尤其是当子查询中的数据量较大时。相比于执行多条独立的查询语句，将子查询展开后，可以减少数据库对物理存储的访问次数，从而减少I/O开销，使查询更加高效。</p><h2 id="子查询展开的执行计划分类举例"><a href="#子查询展开的执行计划分类举例" class="headerlink" title="子查询展开的执行计划分类举例"></a>子查询展开的执行计划分类举例</h2><p>现在，让我给你举个例子，来说明子查询展开对应的执行计划分类。考虑以下这个查询语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.cust_first_name, t.cust_last_name</span><br><span class="line">  <span class="keyword">from</span> CUSTOMERS t</span><br><span class="line"> <span class="keyword">where</span> t.customer_id <span class="keyword">in</span> (<span class="keyword">select</span> <span class="comment">/*+ no_unnest*/</span></span><br><span class="line">                          s.cust_id</span><br><span class="line">                           <span class="keyword">from</span> sales s</span><br><span class="line">                          <span class="keyword">where</span> s.amount_sold <span class="operator">&gt;</span> <span class="number">700</span>)</span><br></pre></td></tr></table></figure><p>这个查询语句中使用了一个子查询来获取sales表中amount_sold&gt;700的cust_id。在执行计划中，Oracle会走FILTER类型的执行计划，如下所示：</p><p><img src="https://www.cdn.cheneyblog.com//blog/202312031032868.png" alt="image-20231203103214190"></p><p>  NO_UNNEST Hint使优化器不对该子查询进行展开</p><p>当做子查询展开时，Oracle会把那些外部where条件为“EXISTS”、“IN”或“=ANY”的子查询转换为对应的半连接(SemiJoin)。使得查询性能更高效。</p><p><img src="https://www.cdn.cheneyblog.com//blog/202312031033204.png" alt="image-20231203103339122"></p><blockquote><p>如果连接字段的值存在不重复的情况，比如有唯一索引，那么该SQL在子查询展开时也可以改写成内连接</p></blockquote><p>当做子查询展开时，Oracle经常会把那些外部where条件为“NO EXISTS”、“NOT IN”或“&lt;&gt;ALL”的子查询转换为对应的反连接(AntiJoin)。</p><p><img src="https://www.cdn.cheneyblog.com//blog/202312031059289.png" alt="image-20231203105925213"></p><p>当子查询中存在表连接时，只能子查询内部先做表连接，然后再通主查询进行半连接或反连接，这时Oracle会对子查询生成一个内嵌视图，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.cust_first_name, t.cust_last_name</span><br><span class="line">  <span class="keyword">from</span> CUSTOMERS t</span><br><span class="line"> <span class="keyword">where</span> t.customer_id <span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">       (<span class="keyword">select</span> s.cust_id</span><br><span class="line">          <span class="keyword">from</span> sales s, products p</span><br><span class="line">         <span class="keyword">where</span> s.prod_id <span class="operator">=</span> p.prod_id</span><br><span class="line">           <span class="keyword">and</span> s.amount_sold <span class="operator">&gt;</span> <span class="number">700</span>)</span><br></pre></td></tr></table></figure><p>对应执行计划如下：</p><p><img src="https://www.cdn.cheneyblog.com//blog/202312031106275.png" alt="image-20231203110605176"></p><h2 id="子查询展开的限制和注意事项"><a href="#子查询展开的限制和注意事项" class="headerlink" title="子查询展开的限制和注意事项"></a>子查询展开的限制和注意事项</h2><p>在使用子查询展开时，也需要注意一些限制和注意事项。</p><ol><li>子查询展开所对应的等价改写SQL和原SQL在语义上一定要是完全等价的。如果改写后的SQL和原SQL并不一定能保持语义上的完全等价，这种类型的子查询就不能做子查询展开。</li><li>对于不拆开子查询但是会把它转换为一个内嵌视图的子查询展开，只有当经过子查询展开后的等价改写SQL的成本值小于原SQL的成本值时，Oracle才会对目标SQL执行子查询展开。</li><li>这里需要注意的是，将子查询拆开，把该子查询中的表、视图从子查询中拿出来，然后和外部查询中的表、视图做表连接这种情况,即使是在Oracle 10g及其以后的版本中，Oracle也不会考虑子查询展开的成本，即Oracle此时会认为这种情形下子查询展开的效率始终比不展开的效率要高，而不管经过子查询展开后的等价改写SQL的成本值是否小于原SQL的成本值。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Builtwith模块：快速识别网站所用技术栈</title>
      <link href="/posts/19502.html"/>
      <url>/posts/19502.html</url>
      
        <content type="html"><![CDATA[<p>在当今互联网时代，各种网站与应用层出不穷，而它们的背后所用的技术栈也千差万别。而对于开发者而言，了解一个网站所用的技术栈可以更好地研究其实现逻辑，提高开发效率。在Python中，我们可以使用builtwith模块来快速地识别一个网站所用的技术栈，本文将介绍该模块的用法和功能。</p><ol><li><p>安装builtwith模块<br> 在使用builtwith模块之前，需要安装该模块。可以使用以下命令进行安装：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install builtwith</span><br></pre></td></tr></table></figure></li><li><p>引入builtwith模块<br> 安装完成后，在Python代码中需进行引入：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtwith</span><br></pre></td></tr></table></figure></li><li><p>检测网站所用技术栈<br> 使用builtwith模块可以快速地检测一个网站所用的技术栈。可以使用以下代码进行检测：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = builtwith.builtwith(<span class="string">&#x27;https://www.google.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p> 上述代码执行后会返回一个字典对象，包含了该网站所用的各种技术栈信息。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;javascript-frameworks&#x27;</span>: [<span class="string">&#x27;Prototype&#x27;</span>, <span class="string">&#x27;RequireJS&#x27;</span>, <span class="string">&#x27;jQuery&#x27;</span>]&#125;</span><br></pre></td></tr></table></figure></li><li><p>检测多个网站所用技术栈<br> 如果想要批量检测多个网站的技术栈，可以使用<code>for</code>循环来实现。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">websites = [<span class="string">&#x27;http://www.baidu.com/&#x27;</span>, <span class="string">&#x27;https://www.cheneyblog.com/&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> website <span class="keyword">in</span> websites:</span><br><span class="line">    result = builtwith.builtwith(website)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;技术栈信息 - <span class="subst">&#123;website&#125;</span>: <span class="subst">&#123;result&#125;</span>\n&quot;</span>)</span><br></pre></td></tr></table></figure><p> 上述代码返回结果如下，每个字典对象表示一个网站使用的技术栈。</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">技术栈信息 - http://www.baidu.com/: &#123;<span class="string">&#x27;javascript-frameworks&#x27;</span>: [<span class="string">&#x27;Prototype&#x27;</span>, <span class="string">&#x27;RequireJS&#x27;</span>, <span class="string">&#x27;jQuery&#x27;</span>]&#125;</span><br><span class="line"></span><br><span class="line">技术栈信息 - https://www.cheneyblog.com/: &#123;<span class="string">&#x27;javascript-frameworks&#x27;</span>: [<span class="string">&#x27;Vue.js&#x27;</span>, <span class="string">&#x27;jQuery&#x27;</span>]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>总结：<br>builtwith模块是Python中用于识别网站所用技术栈的工具，可以快速地帮助开发者了解一个网站的实现细节。通过使用该模块，我们可以快速获取一个网站使用的技术栈及版本信息，提高开发效率。如果你是一位Web开发者，builtwith模块绝对是你必不可少的工具之一。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>random模块：生成随机数的利器</title>
      <link href="/posts/14008.html"/>
      <url>/posts/14008.html</url>
      
        <content type="html"><![CDATA[<p>随机数在计算机编程中扮演着重要的角色，无论是游戏开发、密码学还是模拟等领域，随机性都是必不可少的。在Python中，我们可以使用random模块来生成各种类型的随机数，本文将介绍该模块的用法和功能。</p><ol><li><p>引入random模块<br> 要使用random模块，首先需要在程序中引入它。可以使用以下代码：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br></pre></td></tr></table></figure></li><li><p>生成随机整数<br> random模块中有一个常用的函数是randint(a, b)，用于生成一个在指定范围内的随机整数，包括a和b。例如，要生成一个1到10之间的随机整数，可以使用以下代码：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure></li><li><p>生成随机浮点数<br> 如果需要生成随机的浮点数，可以使用random模块的uniform(a, b)函数。该函数会返回一个在a和b之间的随机浮点数。示例如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = random.uniform(<span class="number">1.0</span>, <span class="number">5.0</span>)</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure><p> <code>random.random()</code> 用于生成一个范围在 [0.0, 1.0) 之间的随机浮点数。这个函数可以在很多情况下用于生成随机数，比如模拟实验、加密算法、游戏开发等各种应用。这个函数生成的随机数服从均匀分布，可以用于需要随机性的各种场合。例如，我们可以使用它来生成随机的初始化参数、模拟随机事件、或者进行概率建模等。</p></li><li><p>随机选择列表元素<br> 有时我们需要从列表中随机选择一个元素，可以使用random模块的choice()函数。该函数接受一个列表作为参数，并返回其中随机选择的一个元素。示例代码如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>, <span class="string">&#x27;grape&#x27;</span>]</span><br><span class="line">random_fruit = random.choice(fruits)</span><br><span class="line"><span class="built_in">print</span>(random_fruit)</span><br></pre></td></tr></table></figure></li><li><p>随机打乱列表顺序<br> 如果需要随机打乱列表的顺序，可以使用random模块的shuffle()函数。该函数会修改原列表，并将其顺序随机打乱。示例代码如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cards = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>]</span><br><span class="line">random.shuffle(cards)</span><br><span class="line"><span class="built_in">print</span>(cards)</span><br></pre></td></tr></table></figure></li><li><p>生成随机种子<br> 在某些情况下，我们需要使用相同的随机数序列。为了实现这一点，可以使用random模块的seed()函数来设置随机种子。示例代码如下：</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">random.seed(<span class="number">123</span>)</span><br><span class="line">num1 = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">random.seed(<span class="number">123</span>)</span><br><span class="line">num2 = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(num1)  <span class="comment"># 输出相同的随机数</span></span><br><span class="line"><span class="built_in">print</span>(num2)</span><br></pre></td></tr></table></figure></li></ol><p>以上只是random模块提供的一些基本功能，实际上它还有很多其他实用的函数，如生成随机字母、随机抽样等。通过灵活运用random模块，我们可以轻松地在Python中实现各种随机性需求。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Oracle优化器中的查询转换操作</title>
      <link href="/posts/15852.html"/>
      <url>/posts/15852.html</url>
      
        <content type="html"><![CDATA[<p>摘要：本文将详细介绍Oracle数据库优化器中的查询转换操作。查询转换是优化器在执行查询计划选择过程中的关键步骤之一，它可以通过重写和改变查询语句的结构，提供更高效的执行计划，从而优化查询性能。本文将深入探讨Oracle优化器中的查询转换技术，包括谓词下推、子查询转换、视图合并等常见的转换操作，并提供一些实用的示例。</p><h2 id="1-查询转换的背景和意义"><a href="#1-查询转换的背景和意义" class="headerlink" title="1. 查询转换的背景和意义"></a>1. 查询转换的背景和意义</h2><p>在查询执行过程中，Oracle优化器的任务是选择最佳的执行计划，以提供最优的查询性能。而查询转换作为其中的一项关键技术，它通过改变查询语句的结构，使得优化器能够更有效地评估和选择查询计划。查询转换可以用于优化查询的性能、简化查询的语法和逻辑，从而提高查询执行效率和可读性。</p><h2 id="2-常见的查询转换操作"><a href="#2-常见的查询转换操作" class="headerlink" title="2. 常见的查询转换操作"></a>2. 常见的查询转换操作</h2><h3 id="2-1-谓词下推（Predicate-Pushdown）"><a href="#2-1-谓词下推（Predicate-Pushdown）" class="headerlink" title="2.1 谓词下推（Predicate Pushdown）"></a>2.1 谓词下推（Predicate Pushdown）</h3><p>谓词下推是一种常见的查询转换操作，它将查询中的谓词条件（例如WHERE子句中的条件）尽早地应用于表之上。这种转换操作可以减少查询所需的数据量，提高查询性能。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 未进行谓词下推的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2) <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 进行谓词下推的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t1 <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t2 <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>  过滤谓词下推将限制条件(id=1)下推到内联视图的内部并产生了下面的查询。现在，这两张表不仅可以通过索引来访问，同时也保证了UNION集合运算符需要的排序操作所处理的记录尽可能少：</p><h3 id="2-2-子查询转换（Subquery-Unnesting）"><a href="#2-2-子查询转换（Subquery-Unnesting）" class="headerlink" title="2.2 子查询转换（Subquery Unnesting）"></a>2.2 子查询转换（Subquery Unnesting）</h3><p>子查询转换是指将子查询（嵌套在主查询中的查询语句）转换为等效的连接操作，以提高查询性能。优化器会尝试将子查询转换为连接查询，从而减少查询的复杂性和执行时间。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 子查询转换前的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="keyword">IN</span> (<span class="keyword">SELECT</span> department_id <span class="keyword">FROM</span> departments <span class="keyword">WHERE</span> location_id <span class="operator">=</span> <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子查询转换后的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> employees.<span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">JOIN</span> departments <span class="keyword">ON</span> employees.department_id <span class="operator">=</span> departments.department_id</span><br><span class="line">  <span class="keyword">WHERE</span> departments.location_id <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h3 id="2-3-视图合并（View-Merging）"><a href="#2-3-视图合并（View-Merging）" class="headerlink" title="2.3 视图合并（View Merging）"></a>2.3 视图合并（View Merging）</h3><p>视图合并是指将涉及到多个视图的查询转换为等效的单个查询，以减少查询的复杂性和执行时间。视图合并可以将多个视图的定义合并为一个查询，从而避免了查询中的冗余计算和表连接操作。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 视图合并前的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> t1.<span class="operator">*</span> <span class="keyword">FROM</span> t1, t2 <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.t1_id) t12,</span><br><span class="line">     (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t3 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">6</span>) t3</span><br><span class="line"><span class="keyword">WHERE</span> t12.id <span class="operator">=</span> t3.t1_id;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 视图合并后的查询</span></span><br><span class="line"><span class="keyword">SELECT</span> t1.<span class="operator">*</span>,t3.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> t1, t2,t3</span><br><span class="line"><span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t3.t1_id <span class="keyword">and</span> t1.id <span class="operator">=</span> t2.t1_id <span class="keyword">and</span> t3.id <span class="operator">&gt;</span> <span class="number">6</span>;</span><br></pre></td></tr></table></figure><h3 id="2-4-“或”扩张（Or-Expansion）"><a href="#2-4-“或”扩张（Or-Expansion）" class="headerlink" title="2.4 “或”扩张（Or Expansion）"></a>2.4 “或”扩张（Or Expansion）</h3><p>“或”扩张的目的是将查询的WHERE条件中包含分隔谓词的语句转化为使用一个或多个UNION ALL集合运算符的复合查询。通常情况下，每个分隔的谓词被转化成为一个单独的查询从而启用额外的索引访问路径。</p><p>示例1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 原SQL</span></span><br><span class="line"><span class="keyword">select</span> t.employee_id <span class="keyword">from</span> employees t <span class="keyword">where</span> t.department_id <span class="operator">=</span> <span class="number">10</span> <span class="keyword">or</span> t.job_id <span class="operator">=</span> <span class="string">&#x27;SH_CLERK&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询优化器会评估一次基于表扫描的成本是否高于两次单独的基于索引扫描的成本</span></span><br><span class="line"><span class="comment">-- 如果两次索引扫描的成本更低就会转换为以下查询</span></span><br><span class="line"><span class="comment">-- 添加lnnvl(n1=1)这个谓词是为了避免多重记录。lnnvl函数在作为参数传递的条件为FALSE或NULL时返回TRUE。因此，第二个组件查询只会在第一个组件查询未返回某条记录的情况下才返回这条记录：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t.employee_id <span class="keyword">from</span> employees t <span class="keyword">where</span> t.department_id <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> t.employee_id <span class="keyword">from</span> employees t <span class="keyword">where</span> t.job_id <span class="operator">=</span> <span class="string">&#x27;SH_CLERK&#x27;</span> <span class="keyword">and</span> lnnvl(t.department_id <span class="operator">=</span> <span class="number">10</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IPv4：互联网的&quot;小四&quot;们如何玩转世界</title>
      <link href="/posts/60895.html"/>
      <url>/posts/60895.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>IPv4（Internet Protocol Version 4）是互联网中最常用的一种地址格式，用于标识连接到互联网的设备。它属于IPv4协议族的一部分，用于寻址和路由数据包。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>IPv4地址根据范围的不同可分为以下五个类别：</p><ol><li>A类地址：范围从1.0.0.0到126.0.0.0，用于大规模网络，支持约1.67亿个主机。例如，10.0.0.1。</li><li>B类地址：范围从128.0.0.0到191.255.0.0，用于中等规模网络，支持约6.55万个主机。例如，172.16.0.1。</li><li>C类地址：范围从192.0.0.0到223.255.255.0，用于小规模网络，支持约254个主机。例如，192.168.0.1。</li><li>D类地址：范围从224.0.0.0到239.255.255.255，用于多播通信，不分配给单个设备。</li><li>E类地址：范围从240.0.0.0到255.255.255.255，保留未分配的地址空间，用于将来使用。</li></ol><h2 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h2><p>IPv4地址可以分为两部分：网络部分和主机部分。网络部分用于标识这个主机所在的网络，而主机部分用于标识这个主机在该网络中的唯一性。IPv4地址的网络部分和主机部分是根据子网掩码进行划分的。子网掩码指定了网络部分和主机部分的边界。</p><ol><li>网络地址：由IPv4地址的高位组成，用于识别设备所连接的网络。根据地址类别，网络地址的位数不同。<ul><li>A类地址的网络地址使用8位，如10.0.0.0。</li><li>B类地址的网络地址使用16位，如172.16.0.0。</li><li>C类地址的网络地址使用24位，如192.168.0.0。</li></ul></li><li>主机地址：由IPv4地址的低位组成，用于唯一标识网络中的设备。主机地址的位数取决于剩余的位数。<ul><li>A类地址的主机地址使用24位，支持约1677万个主机，如10.0.0.1。</li><li>B类地址的主机地址使用16位，支持约6.55万个主机，如172.16.0.1。</li><li>C类地址的主机地址使用8位，支持约254个主机，如192.168.0.1。</li></ul></li><li>子网掩码：作为一个32位的二进制数，用于划分IPv4地址的网络地址和主机地址。子网掩码的作用是确定哪些位用于网络地址，哪些位用于主机地址。它与IPv4地址进行逻辑AND运算以确定网络部分。例如，255.255.255.0的子网掩码将前24位用作网络地址。</li></ol><h2 id="公网IP和私网IP的划分"><a href="#公网IP和私网IP的划分" class="headerlink" title="公网IP和私网IP的划分"></a>公网IP和私网IP的划分</h2><ol><li>公网IP：公网IP地址用于直接连接到互联网的设备，用于全球范围内的通信。这些地址需要由互联网服务提供商（ISP）分配，以确保全球唯一性。例如，203.0.113.1是一个公网IP地址。</li><li>私网IP：私网IP地址用于内部网络中的设备，在局域网或内部通信中使用，不直接暴露在公共互联网上。私网IP地址范围在以下三个段内：</li></ol><ul><li>10.0.0.0至10.255.255.255（A类私网地址）</li><li>172.16.0.0至172.31.255.255（B类私网地址）</li><li>192.168.0.0至192.168.255.255（C类私网地址）</li></ul><p>私网IP地址对于内部网络是唯一的，但在公网中并不唯一。通过网络地址转换（NAT），私网IP可以转换为公网IP，以允许内部设备与互联网进行通信。这种转换允许使用较少的公网IP地址来连接大量的私网设备。</p><h2 id="NAT（网络地址转换）"><a href="#NAT（网络地址转换）" class="headerlink" title="NAT（网络地址转换）"></a>NAT（网络地址转换）</h2><p>NAT是一种技术，用于在私网和公网之间进行地址转换。它允许多个设备使用单个公网IP地址访问互联网。NAT会维护一个转换表，将私网IP和端口映射到公网IP和端口，以确保适当的数据转发。</p><p>举个例子，假设有一个公司内部局域网，使用私网IP地址范围为192.168.0.0/24。所有设备都能够访问互联网，但只有一个公网IP地址。通过使用NAT，路由器将私网IP和端口与公网IP和端口进行映射。当内部设备发送请求时，NAT将转换表中的信息用于正确的数据传输，使得互联网上的服务器能够正确响应数据包，最终实现设备与互联网的通信。</p><h2 id="CIDR（无类别域间路由选择）"><a href="#CIDR（无类别域间路由选择）" class="headerlink" title="CIDR（无类别域间路由选择）"></a>CIDR（无类别域间路由选择）</h2><p>CIDR是一种IP地址分配和路由选择方案，它允许更有效地利用IP地址空间。在传统的分类方式中，每个地址类别都有固定的网络地址和主机地址位数，导致地址浪费。而CIDR通过使用可变长度子网掩码（VLSM），允许将IP地址空间划分为较小的子网，以适应网络的实际需求。</p><p>CIDR表示法使用斜线后跟有子网掩码的网络前缀长度，例如：192.168.0.0/24。这表示前24位用于网络地址，剩余的8位用于主机地址。</p><p>CIDR的使用使得网络规划更加灵活，减少了地址的浪费，并提高了路由的效率。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IP地址：连接互联网的数字指纹</title>
      <link href="/posts/36427.html"/>
      <url>/posts/36427.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是IP地址？"><a href="#什么是IP地址？" class="headerlink" title="什么是IP地址？"></a>什么是IP地址？</h2><p>IP地址（Internet Protocol Address）是互联网中设备的数字标识。它是一系列由点分十进制或冒号分隔的数字所组成的标识符。IP地址有两个主要的版本：IPv4（Internet Protocol Version 4）和IPv6（Internet Protocol Version 6）。</p><h2 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h2><p>IPv4是目前最常用的IP地址版本。它由32位二进制数字组成，通常以四组分隔的十进制数表示，例如：192.168.1.1。这种格式使用了4个字节来表示一个IP地址，因此IPv4最多可以表示约42亿个唯一的地址。</p><p>然而，由于互联网的迅速发展，IPv4的地址空间已经面临枯竭的问题。这是因为IPv4的地址数量有限，无法满足全球范围内不断增长的设备连接需求。为了解决这个问题，IPv6被引入到互联网中。</p><h2 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h2><p>IPv6是IPv4的继任者，它采用128位二进制数字来表示IP地址，通常以八组分隔的十六进制数表示，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334。相比于IPv4，IPv6提供了巨大的地址空间，理论上可以支持近340万亿亿亿个唯一的地址。</p><p>IPv6除了扩大了地址空间外，还引入了更好的安全性、自动地址配置和简化的路由表等功能。然而，由于IPv6的采用过程需要互联网社区的共同努力，目前IPv6在实际应用中仍然相对较少。</p><h2 id="IP地址的作用"><a href="#IP地址的作用" class="headerlink" title="IP地址的作用"></a>IP地址的作用</h2><p>IP地址在互联网中起着至关重要的作用。它允许我们的设备能够与其他设备进行通信和交互。具体而言，IP地址的作用包括：</p><ol><li><p>设备识别：IP地址允许我们的设备在互联网上被准确地识别和定位。通过设备的IP地址，信息和数据可以精确地传递到目标设备。</p></li><li><p>网络通信：IP地址使得设备可以相互通信和交流。无论是发送电子邮件、浏览网页还是进行视频通话，IP地址都是这些通信和交流的基础。</p></li><li><p>路由和转发：路由器使用IP地址来决定如何将数据包转发到目标设备。它们通过查找目标设备的IP地址来确定数据包的最佳路径，确保数据能够快速而准确地到达目标设备。</p></li><li><p>安全性和隐私：IP地址在网络安全和隐私方面起着重要作用。通过IP地址，网络管理员可以监视和保护网络上的数据流量，并防止恶意攻击和入侵。</p></li></ol><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p>为了有效管理IP地址，网络管理员使用各种技术和策略。其中之一是动态主机配置协议（DHCP）。DHCP允许网络设备自动获取并配置IP地址，避免了手动设置每个设备的繁琐过程。DHCP服务器分配可用的IP地址给设备，并确保在网络上没有冲突。</p><p>另一个重要的技术是网络地址转换（NAT）。由于IPv4地址空间的限制，NAT使得多个设备可以共享一个公共IP地址。这在家庭网络和企业网络中非常常见，可以节省IP地址的使用和管理成本。</p><p>为了保护用户的隐私和网络安全，虚拟专用网络（VPN）被广泛使用。VPN可以隐藏用户设备的真实IP地址，通过将用户的网络流量通过加密通道路由到远程服务器，保护数据的安全性和隐私。</p><p>然而，IP地址的使用也引发了一些安全和隐私问题。例如，通过IP地址追踪和定位用户的位置信息，可能对用户的隐私造成侵犯。因此，个人和组织都需要意识到并采取相应的措施来保护自己的IP地址和网络安全。</p><p>随着互联网的不断发展和技术的进步，IP地址的应用也在不断演变。例如，物联网（IoT）的兴起使得更多设备需要连接到互联网，这进一步加大了对IP地址的需求。未来，IPv6的广泛部署将成为解决IPv4地址空间枯竭问题的关键，同时还需要探索更多的技术和策略来有效管理和保护IP地址。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络带宽解析：速度的背后隐藏着什么？</title>
      <link href="/posts/6511.html"/>
      <url>/posts/6511.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>网络带宽是指网络连接的最大数据传输速率。简单来说，它决定了在特定时间内能够通过网络传输的数据量。带宽通常以每秒传输的比特数（bps）来衡量，例如兆比特每秒（Mbps）或千兆比特每秒（Gbps）。想象一下，网络带宽好比水管，那么带宽越大，就相当于水管越宽，更多的信息可以同时通过。</p><h2 id="网络带宽的影响"><a href="#网络带宽的影响" class="headerlink" title="网络带宽的影响"></a>网络带宽的影响</h2><ol><li>网络速度：网络带宽直接决定了我们在网上的速度体验。较高的带宽意味着更高的传输速度，可以更快地加载网页、观看流畅的视频和下载大容量文件。</li><li>多任务处理：拥有更高的网络带宽还意味着能够更轻松地同时进行多个网络活动，如同时下载文件、观看直播和视频通话，而不会出现卡顿或缓冲的情况。</li><li>云服务和在线娱乐：随着云存储和在线游戏、流媒体服务的流行，较高的网络带宽变得尤为重要。它可以确保快速的数据传输，使我们能够顺畅地访问和享受这些服务。</li></ol><h2 id="提升网络速度的方法"><a href="#提升网络速度的方法" class="headerlink" title="提升网络速度的方法"></a>提升网络速度的方法</h2><ol><li>升级网络服务计划：如果您的网络带宽较低，可以考虑升级到更高速的服务计划。与您的网络服务提供商联系，了解他们提供的更高速度选项。</li><li>优化网络设置：确保您的路由器和网络设备设置正确并进行优化。例如，避免同时使用大量设备，将路由器放置在离您通常使用互联网的设备较近的地方，以减少信号衰减等。</li><li>使用有线连接：有线连接通常比无线连接更稳定和快速。将您的设备通过以太网线连接到路由器，可以提供更高的网络速度和更可靠的连接。</li><li>管理网络流量：优化您的网络使用，避免同时进行过多的网络活动。关闭不必要的应用程序和服务，可以为您的重要任务提供更多的带宽。</li><li>使用内容分发网络（CDN）：CDN会复制和存储互联网上的内容，并将其放置在离用户更近的服务器上。这可以加快内容的加载速度，减少延迟和提高用户体验。</li></ol>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle自适应游标共享流程测试实践</title>
      <link href="/posts/17267.html"/>
      <url>/posts/17267.html</url>
      
        <content type="html"><![CDATA[<h2 id="流程测试实践"><a href="#流程测试实践" class="headerlink" title="流程测试实践"></a>流程测试实践</h2><h3 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> V$VERSION;</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091328699.png" alt="环境信息"></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t1 <span class="keyword">as</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dba_objects; <span class="comment">--创建测试表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_t1 <span class="keyword">on</span> t1(object_type); <span class="comment">--创建单列索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> t.object_type, <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 t <span class="keyword">group</span> <span class="keyword">by</span> t.object_type; <span class="comment">--查看索引列数据分布情况</span></span><br></pre></td></tr></table></figure><ul><li>索引列数据分布</li></ul><p><img src="https://www.cdn.cheneyblog.com//blog/202311091341879.png" alt="索引列数据分布"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 收集直方图统计信息</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  dbms_stats.gather_table_stats(ownname          <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;SCOTT&#x27;</span>,</span><br><span class="line">                                tabname          <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;T1&#x27;</span>,</span><br><span class="line">                                estimate_percent <span class="operator">=</span><span class="operator">&gt;</span> <span class="number">100</span>,</span><br><span class="line">                                cascade          <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">true</span>,</span><br><span class="line">                                method_opt       <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;for all columns size auto&#x27;</span>,</span><br><span class="line">                                no_invalidate    <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- HISTOGRAM为FREQUENCY则表示已经存在直方图统计信息</span></span><br><span class="line"><span class="keyword">SELECT</span> t.HISTOGRAM, t.<span class="operator">*</span></span><br><span class="line">  <span class="keyword">FROM</span> DBA_TAB_COL_STATISTICS T</span><br><span class="line"> <span class="keyword">WHERE</span> T.TABLE_NAME <span class="operator">=</span> <span class="string">&#x27;T1&#x27;</span></span><br><span class="line">   <span class="keyword">AND</span> T.COLUMN_NAME <span class="operator">=</span> <span class="string">&#x27;OBJECT_TYPE&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091421231.png" alt="直方图统计信息"></p><h3 id="执行测试"><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h3><blockquote><p>以下测试请在命令窗口执行</p></blockquote><ol><li>首次执行,标记Bind Sensitive</li></ol><ul><li>脚本</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x varchar2(<span class="number">30</span>);</span><br><span class="line"><span class="keyword">exec</span> :x :<span class="operator">=</span> <span class="string">&#x27;CLUSTER&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 <span class="keyword">where</span> object_type <span class="operator">=</span> :x;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p>v$sqlarea</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;select count(1) from t1%&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091436971.png" alt="image-20231109143631901"></p><p>v$sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.PLAN_HASH_VALUE,t.CHILD_NUMBER,t.EXECUTIONS,t.BUFFER_GETS,t.IS_BIND_SENSITIVE,t.IS_BIND_AWARE,t.IS_SHAREABLE <span class="keyword">from</span> v$<span class="keyword">sql</span> t <span class="keyword">where</span> t.SQL_ID <span class="operator">=</span> <span class="string">&#x27;0tvhwm0fmzzvx&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091437954.png" alt="image-20231109143709879"></p><p>v$sql_cs_statistics</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> v$sql_cs_statistics t <span class="keyword">where</span> t.SQL_ID <span class="operator">=</span> <span class="string">&#x27;0tvhwm0fmzzvx&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091438772.png" alt="image-20231109143804652"></p><p>执行计划</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_cursor(<span class="string">&#x27;0tvhwm0fmzzvx&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;advanced&#x27;</span>));</span><br></pre></td></tr></table></figure><p><img src="https://www.cdn.cheneyblog.com//blog/202311091444141.png" alt="image-20231109144437061"></p><p>绑定变量</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091445637.png" alt="image-20231109144514513"></p><ul><li>分析</li></ul><p>目标SQL已被标记Bind Sensitive，但现在还未标记Bind Aware</p><ol start="2"><li>调整变量,重复执行，标记Bind Aware</li></ol><ul><li>脚本</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> :x :<span class="operator">=</span> <span class="string">&#x27;TABLE&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 <span class="keyword">where</span> object_type <span class="operator">=</span> :x; <span class="comment">--执行两次</span></span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p>v$sqlarea</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091513209.png" alt="image-20231109151313125"></p><p>v$sql</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091513167.png" alt="image-20231109151349098"></p><p>v$sql_cs_statistics</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091514071.png" alt="image-20231109151427989"></p><p>执行计划</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091514487.png" alt="image-20231109151456415"></p><p>绑定变量</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091515909.png" alt="image-20231109151525820"></p><p>v$sql_cs_selectivity</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091516406.png" alt="image-20231109151622317"></p><ul><li>分析</li></ul><p>调整变量后v$sql记录的统计信息（BUFFER_GETS）发生较大变化，且绑定变量为“TABLE”时执行了两次，故目标SQL重新硬解析生成了CHILD_NUMBER为1的执行计划，并将对应Child Cursor标记为了Bind Aware，v$sql_cs_selectivity试图也记录了对应的选择率</p><ul><li>拓展</li></ul><blockquote><p>v$sql_cs_selectivity 选择率计算逻辑</p><blockquote><p>Oracle首先计算做硬解析时(做了绑定变量窥探后)上述谓词条件的可选择率(这里将计算出来的可选择率记为S),然后将S上下浮动10%就得到了上述可选择率的范围，即可选择率范围的计算公式为[0.9<em>S,1.1</em>S]<br>另外，在目标列有Frequency类型直方图的前提条件下，如果对目标列施加等值查询条件，且该查询条件的输入值等于该列的某个实际值时，则该谓词条件的可选择率的计算公式为如下所示：<br>selectivity = BucketSize /NUM_ROWS<br>注释：<br>A 上述计算公式适用于启用了绑定变量窥探，目标列有Frequency类型的直方图，对目标列施加等值查询条件，且查询条件的输入值等于该列的某个实际值时的计算。<br>B NUM_ROWS表示目标列所在表的记录数。<br>C BucketSize表示目标列的某个实际值所对应的记录数。</p></blockquote></blockquote><p><img src="https://www.cdn.cheneyblog.com//blog/202311091530279.png" alt="image-20231109153044206"></p><ol start="3"><li>切换不同参数，扩展执行计划对应的选择率范围</li></ol><ul><li>脚本</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> :x :<span class="operator">=</span> <span class="string">&#x27;SYNONYM&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 <span class="keyword">where</span> object_type <span class="operator">=</span> :x;</span><br><span class="line"><span class="keyword">exec</span> :x :<span class="operator">=</span> <span class="string">&#x27;CLUSTER&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 <span class="keyword">where</span> object_type <span class="operator">=</span> :x;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p>v$sqlarea</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091537369.png" alt="image-20231109153739280"></p><p>v$sql</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091538426.png" alt="image-20231109153804361"></p><p>v$sql_cs_statistics</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091538363.png" alt="image-20231109153847282"></p><p>执行计划</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091539042.png" alt="image-20231109153922967"></p><p>绑定变量</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091539240.png" alt="image-20231109153957160"></p><p>v$sql_cs_selectivity</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091647282.png" alt="image-20231109164745204"></p><ul><li>分析</li></ul><p>切换不同参数后，仍然进行的是硬解析，执行计划也相同（INDEX RANGE SCAN），且对应生成了CHILD_NUMBER为2,3的Child Cursor，但是会发现Oracle做了Cursor合并，CHILD_NUMBER为0,1的Child Cursor不再共享（v$sql.IS_SHAREABLE）将会被废弃，不再可用。另外，v$sql_cs_selectivity试图中会对该执行计划的选择率进行扩展，下限从0.036350变成了0.000012。</p><ol start="4"><li>根据绑定变量对应的可选择率，来决定目标SQL的执行时进行硬解析还是软解析/软软解析</li></ol><ul><li>脚本</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> :x :<span class="operator">=</span> <span class="string">&#x27;VIEW&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> t1 <span class="keyword">where</span> object_type <span class="operator">=</span> :x;</span><br></pre></td></tr></table></figure><ul><li>结果</li></ul><p>v$sqlarea</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091717664.png" alt="image-20231109171745546"></p><p>v$sql</p><p><img src="https://www.cdn.cheneyblog.com//blog/202311091719296.png" alt="image-20231109171901222"></p><ul><li>分析</li></ul><p>当切换到新的绑定变量值时，硬解析次数未增加，执行次数增加了，也未生成新的Child Cursor</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密Oracle魔力技术：自适应游标共享为你的查询速度注入强心剂！</title>
      <link href="/posts/39784.html"/>
      <url>/posts/39784.html</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在大型的企业级应用中，数据库查询操作是经常使用的重要环节。然而，当查询语句中存在绑定变量时，不同的绑定变量值可能导致执行计划的不一致，从而影响查询性能。为了解决这个问题，Oracle数据库引入了自适应游标共享（Adaptive Cursor Sharing，ACS）的技术，它能够自动调整执行计划，提高查询性能。本文将深入探讨Oracle自适应游标共享的原理和优势。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Oracle在11g中引入了自适应游标共享(Adaptive CursorSharing)。自适应游标共享可以在启用了绑定变量窥探的前提条件下，让目标SQL在其可能的多个执行计划之间“自适应”地做出选择，而不再像之前那样必须得刻板地沿用该SQL硬解析时所产生的解析树和执行计划。</p><p>那么什么叫“自适应”呢？Oracle会根据执行目标SQL时所对应的runtime统计信息(比如所耗费的逻辑读和CPU时间，对应结果集的行数等)的变化，以及当前传入的绑定变量输入值所在的谓词条件的可选择率，来综合判断是否需要触发目标SQL的硬解析动作。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li><p>标记Bind Sensitive</p><p> 所谓“Bind Sensitive”,就是指Oracle觉得某个含绑定变量的目标SQL的执行计划可能会随着所传入的绑定变量输入值的变化而变化。<br> 当满足如下三个条件时，目标SQL所对应的Child Cursor就会被Oracle标记为Bind Sensitive。</p><ul><li>启用了绑定变量窥探。</li><li>该SQL使用了绑定变量(不管是该SQL自带的绑定变量，还是开启常规游标共享后系统产生的绑定变量)。</li><li>该SQL使用的是不安全的谓词条件(例如范围查询，目标列上有直方图统计信息的等值查询等)。</li></ul></li><li><p>标记Bind Aware</p><p> 所谓“Bind Aware”,就是指Oracle已经确定某个含绑定变量的目标SQL的执行计划会随着所传入的绑定变量输入值的变化而变化。<br> 当满足如下两个条件时，目标SQL所对应的Child Cursor就会被Oracle标记为Bind Aware。</p><ul><li>该SQL所对应的Child Cursor在之前已经被标记为Bind Sensitive。</li><li>该SQL在接下来连续两次执行时，所对应的runtime统计信息与该SQL之前硬解析时所对应的runtime统计信息存在较大差异</li></ul></li></ol><blockquote><p>V$SQL中的列IS_BIND_SENSITIVE、IS_BIND_AWARE和IS_SHAREABLE分别用来表示Child Cursor是否是Bind Sensitive、Bind Aware和共享的。<br>V$SQL_CS_STATISTICS用于显示指定Child Cursor中存储的runtime统计信息。<br>V$SQL_CS_SELECTIVITY用于显示指定的、已经被标记为Bind Aware的Child Cursor中存储的含绑定变量的谓词条件所对应的可选择率的范围。</p></blockquote><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><ul><li><a href="https://cheneyblog.com//posts/17267.html">自适应游标共享流程实践</a></li></ul><h2 id="优势和特点"><a href="#优势和特点" class="headerlink" title="优势和特点"></a>优势和特点</h2><p>自适应游标共享技术带来了以下几个重要优势：</p><h3 id="改善查询性能"><a href="#改善查询性能" class="headerlink" title="改善查询性能"></a>改善查询性能</h3><p>自适应游标共享可以根据实际的绑定变量值自动选择最佳的执行计划，避免了由于绑定变量值的不同而导致的查询性能问题。无论是高选择性的绑定变量值还是低选择性的绑定变量值，都能够得到一个合适的执行计划，从而提高查询性能。</p><h3 id="节省资源"><a href="#节省资源" class="headerlink" title="节省资源"></a>节省资源</h3><p>传统的解决方案是为每个不同的绑定变量值生成一个独立的执行计划，导致执行计划的数量庞大，占用大量的内存和CPU资源。而自适应游标共享通过自动调整执行计划，可以避免生成过多的执行计划，从而节省系统资源。</p><h3 id="自适应性和灵活性"><a href="#自适应性和灵活性" class="headerlink" title="自适应性和灵活性"></a>自适应性和灵活性</h3><p>自适应游标共享技术具有自动检测和适应环境变化的能力。如果环境发生变化，比如某个绑定变量值的分布情况发生变化，Oracle可以根据新的执行情况来自动调整执行计划，以适应新的环境，保持查询性能的稳定性和一致性。</p><h2 id="实际应用"><a href="#实际应用" class="headerlink" title="实际应用"></a>实际应用</h2><p>自适应游标共享技术在实际应用中具有广泛的应用场景，特别是在复杂的查询环境中更加显著。它可以解决由于绑定变量值的不同而导致的查询性能问题，提高系统的稳定性和可用性。同时，它还可以减少对DBA的依赖，降低了开发和维护的成本。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker操作手册：从零开始掌握容器化技术</title>
      <link href="/posts/34865.html"/>
      <url>/posts/34865.html</url>
      
        <content type="html"><![CDATA[<h2 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>在开始学习Docker之前，首先需要安装Docker。根据你的操作系统平台，可以选择安装Docker Desktop（适用于Windows和macOS）或Docker Engine（适用于Linux）。在安装完成后，可以使用命令”docker version”验证安装是否成功。</p><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol><li><code>docker version</code>：查看Docker的版本信息。</li><li><code>docker info</code>：查看Docker的详细信息，包括版本、运行状态等。</li><li><code>docker help</code>：获取Docker命令的帮助文档和使用方法。</li><li><code>docker run &lt;image_name&gt;</code>：使用指定的镜像创建并启动一个新的容器实例。</li><li><code>docker ps</code>：列出当前正在运行的所有容器实例。</li><li><code>docker stop &lt;container_name or id&gt;</code>：停止指定的容器。</li><li><code>docker start &lt;container_name or id&gt;</code>：启动指定的容器。</li><li><code>docker rm &lt;container_name or id&gt;</code>：删除指定的容器实例。</li><li><code>docker images</code>：列出所有本地保存的镜像。</li><li><code>docker rmi &lt;image_name or id&gt;</code>：删除指定的镜像。</li><li><code>docker pull &lt;image_name&gt;</code>：从Docker Hub下载指定的镜像。</li></ol><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>Dockerfile是用于定义镜像构建过程的文本文件。通过编写Dockerfile，你可以定制化构建你的应用程序镜像。以下是Dockerfile的常用指令：</p><ol><li>FROM：指定基础镜像。</li><li>COPY：复制文件或目录到容器中。</li><li>RUN：在容器中执行命令。</li><li>EXPOSE：声明容器暴露的端口。</li><li>CMD：指定容器启动后执行的命令。</li></ol><h2 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h2><p>Docker Compose是用于定义和管理多容器应用程序的工具。通过编写docker-compose.yml文件，你可以定义应用程序所需的服务、网络和数据卷等。以下是docker-compose.yml文件的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">version: <span class="string">&#x27;3&#x27;</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - 8080:80</span><br><span class="line">  db:</span><br><span class="line">    image: mysql:latest</span><br><span class="line">    environment:</span><br><span class="line">      - MYSQL_ROOT_PASSWORD=password</span><br><span class="line">      - MYSQL_DATABASE=mydb</span><br></pre></td></tr></table></figure><h2 id="进阶命令"><a href="#进阶命令" class="headerlink" title="进阶命令"></a>进阶命令</h2><ol><li>docker build：根据Dockerfile构建自定义镜像。</li><li>docker commit：创建一个新的镜像，基于正在运行的容器。</li><li>docker push：将本地构建的镜像推送到Docker Hub或其他私有仓库。</li><li>docker network：管理Docker中的网络资源。</li><li>docker volume：管理Docker中的存储资源。</li><li>docker-compose up/down：根据docker-compose.yml文件启动或停止服务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探究Docker的工作原理：解密容器化技术</title>
      <link href="/posts/4571.html"/>
      <url>/posts/4571.html</url>
      
        <content type="html"><![CDATA[<h2 id="Docker的核心概念：镜像和容器"><a href="#Docker的核心概念：镜像和容器" class="headerlink" title="Docker的核心概念：镜像和容器"></a>Docker的核心概念：镜像和容器</h2><p>Docker的工作原理是基于容器化技术的。这里容器是指一个完整的运行时环境，包括所需的软件、库文件和配置等全部内容。Docker通过镜像（Image）来描述和存储容器的环境，镜像可以被看作是容器的模板。镜像是一个可执行的软件包，可以被用于创建新的Docker容器实例。容器是由Docker镜像创建的运行时实例，每个Docker容器都是独立的、相互隔离的，且有各自单独的文件系统。</p><h2 id="Docker的工作流程"><a href="#Docker的工作流程" class="headerlink" title="Docker的工作流程"></a>Docker的工作流程</h2><p>在理解Docker的工作原理之前，需要了解一下Docker的工作流程。</p><ol><li><p>创建Docker镜像<br>Docker镜像是一个可执行的软件包，包含应用程序的所有依赖项和运行时环境。开发者可以通过编写Dockerfile文件来定义Docker镜像中应该包含什么内容。在Dockerfile文件中，定义了容器的基础镜像、依赖项、程序文件和命令等相关信息。使用Docker build命令可以创建一个基于Dockerfile文件的镜像。</p></li><li><p>运行Docker容器<br>使用Docker run命令可以基于Docker镜像创建一个新的Docker容器实例，Docker容器可以在不同的环境中进行部署和运行。通过Docker run命令可以配置各种有关容器的信息，比如容器名称、所需的资源和容器运行的命令等。创建Docker容器时，Docker会使用Docker镜像中的文件系统，以及容器运行时环境来执行容器中运行的应用程序。</p></li><li><p>Docker容器的管理和扩展<br>Docker提供了管理和扩展容器的工具，比如Docker Compose、Kubernetes等。可以使用这些工具来自动化地部署、配置和管理多个Docker容器。Docker Compose和Kubernetes等工具可以将多个Docker容器放在一个集群中，实现容器的快速、简单和可靠的部署和扩展。</p></li></ol><h2 id="Docker的底层技术"><a href="#Docker的底层技术" class="headerlink" title="Docker的底层技术"></a>Docker的底层技术</h2><p>Docker在实现容器化技术的过程中，运用了很多底层技术，如命名空间、控制组、联合文件系统等。这些底层技术是保证Docker容器的隔离性、安全性和高效性的基础。</p><ol><li><p>命名空间<br>Docker使用命名空间来保证容器的隔离性，每个容器都拥有独立的命名空间。在命名空间中，容器所使用的文件系统、进程、网络接口等都是独立的。</p></li><li><p>控制组<br>控制组（cgroups）用来限制和管理应用程序运行时的资源使用情况，包括CPU、内存、I/O等。通过控制组可以实现对CPU和内存等资源的控制和管理，使得不同容器之间不会相互影响。</p></li><li><p>联合文件系统<br>联合文件系统（UnionFS）是一种将不同文件系统文件和目录按层级组织在一起的技术，为Docker节省了大量磁盘空间。Docker利用联合文件系统来创建和管理容器运行时所需的文件系统，这也是Docker提供快速、简单和可靠的容器化技术的重要基础。</p></li></ol><h2 id="Docker的优点和局限"><a href="#Docker的优点和局限" class="headerlink" title="Docker的优点和局限"></a>Docker的优点和局限</h2><p>Docker的优点是显而易见的，它提供了一个高度可移植、高效和隔离的运行时环境，使得应用程序可以在不同的环境中以一致的方式运行。此外，Docker还可以帮助开发者实现快速、简单和可靠的容器化部署，提高应用程序的运行效率和可靠性。</p><p>然而，Docker也有一些局限性。首先，Docker容器还不够轻量级，需要占用大量的磁盘空间和内存。其次，Docker容器的网络隔离还不够安全和灵活。此外，Docker的安全漏洞和容器管理问题也是Docker需要继续解决的问题之一。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker：现代应用容器化的革命</title>
      <link href="/posts/54371.html"/>
      <url>/posts/54371.html</url>
      
        <content type="html"><![CDATA[<h2 id="容器化的起源"><a href="#容器化的起源" class="headerlink" title="容器化的起源"></a>容器化的起源</h2><p>容器化的概念早在上世纪70年代就已经出现，当时的操作系统已经允许将进程隔离运行，但直到近年来，随着虚拟化技术的发展，容器化才开始受到广泛关注。而Docker，作为当今最流行的容器化平台，其起源可以追溯到2013年。</p><h2 id="Docker的诞生"><a href="#Docker的诞生" class="headerlink" title="Docker的诞生"></a>Docker的诞生</h2><p>Docker由DotCloud（现为Docker公司）的创始人Solomon Hykes于2013年创建。当时，他旨在解决自己在托管平台项目中遇到的挑战：快速、可靠地构建、发布和交付应用程序。他设计了一个开源工具，后来演变为Docker。</p><h2 id="Docker的核心概念"><a href="#Docker的核心概念" class="headerlink" title="Docker的核心概念"></a>Docker的核心概念</h2><p>Docker的核心概念是容器。容器是一个轻量级、可移植的软件单元，包含应用程序以及其依赖项和运行时环境。Docker利用操作系统级虚拟化技术，在宿主机上创建独立的容器，使应用程序能够在各种环境中以一致的方式运行。</p><h2 id="Docker的优势"><a href="#Docker的优势" class="headerlink" title="Docker的优势"></a>Docker的优势</h2><p>Docker带来了许多优势。首先，它提供了一种快速、可靠的应用程序交付机制，使开发人员能够轻松地在不同的环境中部署和运行应用程序。其次，Docker的容器化方法能够解决依赖管理和环境配置的问题，简化了部署过程。此外，Docker的可移植性和可扩展性，使得应用程序能够在不同的平台和云服务中无缝迁移和扩展。</p><h2 id="Docker对软件开发生态的影响"><a href="#Docker对软件开发生态的影响" class="headerlink" title="Docker对软件开发生态的影响"></a>Docker对软件开发生态的影响</h2><p>Docker成为了当今软件开发生态中不可或缺的工具。它为开发者提供了便捷的开发环境和交付流程，并推动了微服务架构和持续集成/持续交付（CI/CD）的广泛应用。Docker生态系统也得到了快速发展，丰富的容器镜像、容器编排工具和监控平台不断涌现，使得构建和管理容器化应用变得更加高效和灵活。</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>协议：链接互联网世界的规则与约定</title>
      <link href="/posts/62378.html"/>
      <url>/posts/62378.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是协议"><a href="#什么是协议" class="headerlink" title="什么是协议"></a>什么是协议</h2><p>在互联网通信中，协议是规定通信过程和数据交换格式的约定。它定义了通信双方之间的规则和方法，确保信息的准确传输和解析。协议规定了数据如何分割、编码、传输和解码，以及如何处理错误和确认传输的完整性。</p><h2 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h2><p>协议在互联网通信中发挥着重要作用：</p><ol><li>实现互通性：不同设备和系统可能使用不同的硬件、操作系统和通信技术，协议提供了一个共同的标准，使得它们能够相互交流和理解。</li><li>确保数据的可靠传输：协议采用各种技术和机制，如错误检测、数据分段、数据重传等，以确保数据能够在网络中可靠地传输。</li><li>管理网络流量：协议定义了数据的传输方式和流量控制机制，以保证网络的高效运行和资源的有效利用。</li><li>提供安全性保障：许多协议提供加密和认证等安全机制，确保数据的机密性、完整性和身份验证。</li></ol><h2 id="常见的互联网协议"><a href="#常见的互联网协议" class="headerlink" title="常见的互联网协议"></a>常见的互联网协议</h2><p>互联网上有众多的协议，在此，列举几个常见的互联网协议：</p><ol><li>TCP/IP协议：TCP/IP协议族是互联网通信的基石，它包括了IP、TCP、UDP、ICMP和DNS等协议，保证了数据的可靠传输、网络的可扩展性和互操作性。</li><li>HTTP协议：HTTP（超文本传输协议）用于客户端和服务器之间传输和解释网页等超文本资源，它是现代互联网应用的基础协议之一。</li><li>FTP协议：FTP（文件传输协议）用于在客户端和服务器之间传输文件，方便文件的上传和下载操作。</li><li>SMTP协议：SMTP（简单邮件传输协议）用于电子邮件的发送，确保邮件能够通过互联网传递到接收方。</li><li>SSL/TLS协议：SSL/TLS协议提供了加密和身份验证等安全机制，保护数据在网络中的传输过程。</li></ol><blockquote><p>结语：<br>协议在互联网通信中扮演着关键角色，它们确保信息的可靠传输、网络的互通和安全性的保障。通过协议的存在，不同设备和系统能够顺利地交换信息和进行通信。目前已经存在各种各样的互联网协议，不断发展和完善，以满足不断增长的互联网需求。作为用户，了解和熟悉常见的互联网协议，将有助于我们更好地使用互联网服务，并享受便利、高效、安全的互联网体验。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密互联网通信的关键：TCP/IP协议族</title>
      <link href="/posts/10760.html"/>
      <url>/posts/10760.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在当今数字化时代，互联网已经成为了人们生活中不可或缺的一部分。然而，要实现互联网的通信，我们需要依赖于一种庞大而强大的协议体系，其中最重要的就是TCP/IP协议族。本文将向您介绍TCP/IP协议族的重要性、成员以及其在互联网通信中的作用。</p><h2 id="TCP-IP协议族的重要性"><a href="#TCP-IP协议族的重要性" class="headerlink" title="TCP/IP协议族的重要性"></a>TCP/IP协议族的重要性</h2><p>TCP/IP协议族是一个基于TCP（传输控制协议）和IP（网际协议）的通信协议集合。它是实现互联网通信的基础，无论是网页浏览、文件传输、电子邮件还是其他各种互联网应用，都离不开TCP/IP协议族。它的设计目标是确保数据的可靠传输、网络的可扩展性和互操作性。</p><h2 id="TCP-IP协议族的成员"><a href="#TCP-IP协议族的成员" class="headerlink" title="TCP/IP协议族的成员"></a>TCP/IP协议族的成员</h2><p>TCP/IP协议族包含了多个重要的协议，每个协议都具有特定的功能和任务。以下是其中一些重要的成员：</p><ol><li><p>IP协议（Internet Protocol）：作为TCP/IP协议族的核心协议之一，IP协议负责为数据包提供唯一的地址，并根据这些地址转发数据包到目的地。它通过IP地址和子网掩码进行寻址和路由选择。</p></li><li><p>TCP协议（Transmission Control Protocol）：TCP协议是一种面向连接的传输协议，主要用于保证数据的可靠传输。它通过数据分段、序列号以及确认机制来确保数据的完整性、顺序性和可靠性。</p></li><li><p>UDP协议（User Datagram Protocol）：与TCP协议不同，UDP协议是一种无连接的传输协议。它提供了一种简单的数据传输机制，但不保证数据的可靠传输。因此，它常用于实时应用，如音频和视频流媒体。</p></li><li><p>ICMP协议（Internet Control Message Protocol）：ICMP协议负责传输网络中的控制消息和错误报告。它与IP协议配合工作，用于网络故障排查、网络状态监测等功能。</p></li><li><p>DNS协议（Domain Name System）：DNS协议用于将域名映射为相应的IP地址。它提供了域名解析的服务，使用户无需记住复杂的IP地址，只需使用易记的域名来访问互联网服务。</p></li></ol><h2 id="TCP-IP协议族在互联网通信中的作用"><a href="#TCP-IP协议族在互联网通信中的作用" class="headerlink" title="TCP/IP协议族在互联网通信中的作用"></a>TCP/IP协议族在互联网通信中的作用</h2><p>TCP/IP协议族在互联网通信中扮演着极为重要的角色。它通过IP协议实现了数据包在网络中的传输，通过TCP协议确保了数据的可靠性，而UDP协议则提供了高速的实时传输。此外，ICMP协议可以帮助我们排查网络故障，而DNS协议则使我们能够通过便捷的域名来访问服务。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>TCP/IP协议族是互联网通信的基石，它确保了数据的可靠传输、网络的可扩展性和互操作性。TCP/IP协议族在实现互联网通信中扮演着关键角色，使我们能够浏览网页、传输文件、进行在线通信，并享受各种互联网应用。随着互联网的发展，TCP/IP协议族不断演进和优化，以满足更大的地址空间、更高的网络带宽和处理能力的需求。然而，网络安全和性能问题仍需要持续关注和解决。总的来说，TCP/IP协议族是连接世界的通信基石，为我们创造了方便、快捷、安全的互联网体验。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速查询性能,探秘Oracle常量游标共享</title>
      <link href="/posts/54542.html"/>
      <url>/posts/54542.html</url>
      
        <content type="html"><![CDATA[<h2 id="为什么会有常量游标共享"><a href="#为什么会有常量游标共享" class="headerlink" title="为什么会有常量游标共享"></a>为什么会有常量游标共享</h2><p>在实际的数据库应用中，我们常常遇到相似的查询逻辑，但实际参数值有所差异的情况。传统的方式是为每个不同参数值编译不同的查询语句，这种重复劳动造成了资源的浪费和性能的下降。为了解决这个问题，Oracle引入了常量游标共享。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当开启了常规游标共享后，Oracle在实际解析目标SQL之前，会先用系统产生的绑定变量（”SYS_B_n”(n=0,1,2……)”）来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值，这样替换后实际执行的SQL就已经是使用了绑定变量的改写后的等价SQL,这样就可以做到既有效降低系统硬解析的数量又对应用透明。</p><h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><p>常量游标共享通过将查询中的实际参数替换为常量值，实现相同查询逻辑的共享。它解决了以下问题：</p><ol><li><p>减少了重复编译：常量游标共享避免了为每个不同参数值编译新的查询语句，减少了重复编译的开销和数据库的负载。</p></li><li><p>提高了内存利用率：共享执行计划的使用减少了存储执行计划所需的内存空间，释放了宝贵的内存资源，从而提升了整体的数据库性能。</p></li><li><p>加速了查询速度：重复使用共享的执行计划，减少了缓冲区中存储查询结果的次数，提高了查询速度，增强了系统的响应能力。</p></li></ol><h2 id="如何使用常量游标共享"><a href="#如何使用常量游标共享" class="headerlink" title="如何使用常量游标共享"></a>如何使用常量游标共享</h2><p>在Oracle数据库中，可以通过修改系统参数或会话参数的方式来配置常量游标共享。</p><ol><li><p>修改系统参数：通过修改<code>CURSOR_SHARING</code>参数来启用常量游标共享。可选的参数值如下：</p><ul><li><code>EXACT</code>：要求查询中所有参数与常量完全匹配才能共享游标。</li><li><code>SIMILAR</code>：只要查询中的实际参数与常量有相似的值（经过转换后），就可以共享游标。</li><li><code>FORCE</code>：强制使用常量游标共享，无论实际参数的值如何。</li></ul></li><li><p>修改会话参数：可以在会话级别上修改<code>CURSOR_SHARING</code>参数的值，仅对当前会话生效。例如：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> CURSOR_SHARING <span class="operator">=</span> <span class="keyword">SIMILAR</span>;</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol><li><p><code>EXACT</code>模式：<br>Oracle不会用系统产生的绑定变量来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值。</p></li><li><p><code>SIMILAR</code>模式：<br>Oracle会用系统产生的绑定变量来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值，  但Oracle只会对那些它认为是安全的谓词条件在替换后重用解析树和执行计划，对于它认为的不安全的谓词条件，即便用系统产生的绑定变量替换后的SQL文本是一模一样的，对于每一个不同的输入值，Oracle都会执行一次硬解析，即此时会出现一个Parent Cursor下挂一堆Child Cursor的现象，而这些Child Cursor中存储的解析树和执行计划很可能是一样的(注意，因为自适应游标共享的引入，这种行为不再适用于Oracle 11g及其后续的版本)。</p><blockquote><p>所谓“安全的谓词条件”,是指如果一个谓词条件所在的目标SQL的执行计划并不随该谓词条件的输入值的变化而变化，那么该谓词条件就是安全的。与之相反的是，如果目标SQL的执行计划可能会隨着谓词条件的输入值的不同而发生变化，那么该谓词条件就是一个不安全的谓词条件。<br>Oracle数据库中典型的不安全的谓词条件有范围查询(使用了&gt;、&gt;=、&lt;、&lt;=、between的谓词条件),使用了帶通配符(%)的LIKE,以及对有直方图统计信息的目标列施加的等值查询等(关于直方图统计信息，会在“第5章Oracle里的统计信息”中详细描述，这里不再赘述)。</p></blockquote></li><li><p><code>FORCE</code>模式：<br>不管是“安全的谓词条件”还是“不安全的谓词条件”,当CURSOR_SHARING的值为FORCE时，替换后同一类型的SQL总是会无条件地重用之前硬解析时的解析树和执行计划(注意，因为自适应游标共享的引入，这种行为不再适用于Oracle 11g及其后续的版本)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绑定变量窥探：提升SQL查询性能的利器</title>
      <link href="/posts/6732.html"/>
      <url>/posts/6732.html</url>
      
        <content type="html"><![CDATA[<div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>在Oracle数据库中，优化查询性能是每个数据库管理员和开发人员关注的焦点之一。而绑定变量窥探（Bind Peeking）作为一项重要的优化技术，可以帮助我们提升SQL查询的性能以及执行计划的选择。本文将深入解析Oracle绑定变量窥探，带您了解其原理、使用方法以及注意事项，助您在数据库优化的道路上取得更好的成果。</p></div><h2 id="什么是绑定变量窥探"><a href="#什么是绑定变量窥探" class="headerlink" title="什么是绑定变量窥探"></a>什么是绑定变量窥探</h2><p>绑定变量是SQL语句中使用的占位符，用于在执行时绑定实际的值。而绑定变量窥探是Oracle数据库中的一项优化技术，通过观察绑定变量的值来选择最佳的执行计划。它避免了SQL语句的重复编译，提高了数据库的性能和响应速度。</p><h2 id="绑定变量窥探的原理"><a href="#绑定变量窥探的原理" class="headerlink" title="绑定变量窥探的原理"></a>绑定变量窥探的原理</h2><p>在执行一条SQL语句时，Oracle会对绑定变量进行窥探，观察其值。根据绑定变量的值，Oracle会选择一个执行计划，该计划在当前查询的情况下被认为是最佳的。之后，Oracle会重复使用这个执行计划，避免重新编译SQL语句。</p><h2 id="绑定变量窥探的优点"><a href="#绑定变量窥探的优点" class="headerlink" title="绑定变量窥探的优点"></a>绑定变量窥探的优点</h2><ul><li>减少SQL语句的重复编译：绑定变量窥探可以显著降低SQL语句的重复编译次数，提升数据库的性能。</li><li>提高执行计划的选择：根据绑定变量的值，Oracle可以选择合适的执行计划，优化查询性能。</li></ul><h2 id="绑定变量窥探的限制和注意事项"><a href="#绑定变量窥探的限制和注意事项" class="headerlink" title="绑定变量窥探的限制和注意事项"></a>绑定变量窥探的限制和注意事项</h2><ul><li>数据分布的不均匀性：绑定变量窥探的选择依赖于绑定变量的值，如果数据分布不均匀，可能会选择到一个不适合当前查询的执行计划。</li><li>SQL语句多样性：对于多样性的SQL语句，绑定变量窥探可能无法有效选择最佳的执行计划。</li></ul><h2 id="如何使用绑定变量窥探"><a href="#如何使用绑定变量窥探" class="headerlink" title="如何使用绑定变量窥探"></a>如何使用绑定变量窥探</h2><p>在大多数情况下，Oracle会自动进行绑定变量窥探。但在一些特殊情况下，我们可以通过使用HINT或修改SESSION级别的优化参数来控制绑定变量窥探的行为。然而，这些方法需要谨慎使用，并且需要在特定的情况下进行评估和测试。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升 PL/SQL 执行效率的利器：绑定变量与批量绑定</title>
      <link href="/posts/10092.html"/>
      <url>/posts/10092.html</url>
      
        <content type="html"><![CDATA[<h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>绑定变量是一种通过使用占位符代替具体数值或变量来减少重复解析和编译 SQL 语句开销的技术。它在 PL/SQL 中有着广泛的应用。让我们通过一个普通的例子来说明绑定变量的用法。</p><p>假设我们需要查询特定员工的工资信息，并进行更新操作。传统的方法是在 SQL 语句中直接使用员工的 ID 和工资数值。然而，这种方式容易导致 SQL 注入攻击，并且每次执行 SQL 语句都需要重新解析和编译，浪费了系统资源和时间。</p><p>现在，我们使用绑定变量来改进代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  v_employee_id EMPLOYEES.EMPLOYEE_ID<span class="operator">%</span>TYPE :<span class="operator">=</span> <span class="number">100</span>; <span class="comment">-- 绑定变量</span></span><br><span class="line">  v_salary      EMPLOYEES.SALARY<span class="operator">%</span>TYPE;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> v_salary <span class="keyword">FROM</span> EMPLOYEES <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 执行其他 PL/SQL 逻辑或业务处理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> EMPLOYEES <span class="keyword">SET</span> salary <span class="operator">=</span> v_salary <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;工资更新成功&#x27;</span>);</span><br><span class="line">EXCEPTION</span><br><span class="line">  <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;出现错误: &#x27;</span> <span class="operator">||</span> SQLERRM);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>v_employee_id</code> 这个绑定变量来替代具体的员工 ID。通过使用绑定变量，我们可以带来以下好处：</p><ol><li><p>缓存重用：数据库可以重用已经编译好的执行计划，避免每次都重新解析和编译 SQL 语句，从而提高执行效率。</p></li><li><p>数据安全：绑定变量可以防止 SQL 注入攻击，确保数据的安全性和完整性。</p></li><li><p>减少网络传输：绑定变量只需要传输一次，而不需要每次都传输具体数值，减少了网络传输的开销，提高了读写数据的效率。</p></li></ol><p>除了普通的绑定变量，我们还可以使用批量绑定来优化大批量数据的处理。批量绑定是一种同时处理多个数据的技术，通过减少与数据库的交互次数来提高代码的执行效率。</p><h2 id="批量绑定"><a href="#批量绑定" class="headerlink" title="批量绑定"></a>批量绑定</h2><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>PL/SQL 是一种用于编写存储过程、触发器和函数等数据库程序的过程式编程语言，而 SQL 引擎则负责执行 SQL 查询和 DML（数据操作语言）语句。当在 PL/SQL 中执行 SQL 语句时，会涉及 PL/SQL 引擎和 SQL 引擎之间的上下文切换。频繁的上下文切换会增加系统的开销，降低性能。</p></div><p>批量绑定的使用是减少上下文切换的一种有效策略。绑定变量是指在 SQL 语句中使用占位符代替具体的数值或变量，这样可以减少重复解析和编译 SQL 语句的开销。</p><p>以下是一个批量绑定的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  TYPE emp_id_list <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> EMPLOYEES.EMPLOYEE_ID<span class="operator">%</span>TYPE INDEX <span class="keyword">BY</span> PLS_INTEGER;</span><br><span class="line">  TYPE sal_list <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> EMPLOYEES.SALARY<span class="operator">%</span>TYPE INDEX <span class="keyword">BY</span> PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  v_employee_ids emp_id_list;</span><br><span class="line">  v_salaries sal_list;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 初始化绑定变量</span></span><br><span class="line">  v_employee_ids(<span class="number">1</span>) :<span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  v_employee_ids(<span class="number">2</span>) :<span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">  v_employee_ids(<span class="number">3</span>) :<span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 查询员工的薪水</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> v_salaries</span><br><span class="line">  <span class="keyword">FROM</span> EMPLOYEES</span><br><span class="line">  <span class="keyword">WHERE</span> employee_id <span class="keyword">MEMBER</span> <span class="keyword">OF</span> v_employee_ids;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 更新员工薪水</span></span><br><span class="line">  FORALL i <span class="keyword">IN</span> v_employee_ids.FIRST .. v_employee_ids.LAST</span><br><span class="line">    <span class="keyword">UPDATE</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">SET</span> salary <span class="operator">=</span> v_salaries(i) <span class="operator">*</span> <span class="number">1.1</span> <span class="comment">-- 加薪 10%</span></span><br><span class="line">    <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_ids(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;薪资更新成功&#x27;</span>);</span><br><span class="line">EXCEPTION</span><br><span class="line">  <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;出现错误: &#x27;</span> <span class="operator">||</span> SQLERRM);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个类型为 <code>emp_id_list</code> 的批量绑定变量 <code>v_employee_ids</code>，并根据员工 ID 更新对应的薪水信息。通过批量绑定，我们可以在一次操作中同时处理多个数据，减少了与数据库的交互次数，提升了代码的执行效率。</p><blockquote><p>绑定变量和批量绑定是 PL/SQL 开发者必备的技能，它们能够显著提高代码的执行效率和系统性能。在实际开发中，根据具体场景的需求，灵活运用这两种技术，将为您的项目带来明显的优势。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绑定变量：优化查询性能的利器</title>
      <link href="/posts/30060.html"/>
      <url>/posts/30060.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>摘要：Oracle数据库中的绑定变量是提升查询性能和安全性的重要工具。本文将详细介绍绑定变量的含义、优势，解析绑定变量如何通过减少SQL解析开销和查询重编译次数来提升数据库查询效率的原理，并提供简单的用法举例，帮助读者更好地理解和应用绑定变量的优势。</p></div><h2 id="绑定变量的含义"><a href="#绑定变量的含义" class="headerlink" title="绑定变量的含义"></a>绑定变量的含义</h2><p>绑定变量是一种机制，将SQL语句中需要动态输入的参数或值与具体的参数值分离开来。它使用占位符来代表参数，通过此机制实现了SQL语句的重用、减少了SQL解析开销和查询重编译次数，进而提升了查询性能和安全性。</p><h2 id="绑定变量的优势"><a href="#绑定变量的优势" class="headerlink" title="绑定变量的优势"></a>绑定变量的优势</h2><ol><li>提升查询性能：绑定变量能够减少SQL解析开销和查询重编译次数。当使用绑定变量时，数据库可以重用已经解析过的SQL语句的执行计划，而无需重新解析和编译，从而显著提高查询性能。</li><li>增强安全性：通过将参数值与SQL语句分离，绑定变量可以有效避免SQL注入攻击。由于参数值不会直接拼接到SQL语句中，攻击者无法通过篡改参数值来执行恶意代码。</li><li>减少资源消耗：绑定变量避免了每次执行SQL语句都需要创建新的SQL语句的情况，从而减少了内存的消耗。</li></ol><h2 id="绑定变量提升查询效率的原理"><a href="#绑定变量提升查询效率的原理" class="headerlink" title="绑定变量提升查询效率的原理"></a>绑定变量提升查询效率的原理</h2><ol><li>SQL解析开销减少：数据库在解析SQL语句时，绑定变量的值为占位符，而不是具体的参数值。因此，当相同的SQL语句有不同的参数值时，数据库可以重用已经解析过的语法树和执行计划，避免了重复解析的开销。</li><li>查询重编译次数减少：使用绑定变量时，数据库不需要为每个不同的参数值重新编译SQL语句，而是将新的参数值与SQL语句进行绑定，从而避免了查询重编译的过程，提升了查询效率。</li></ol><h2 id="绑定变量的简单用法举例"><a href="#绑定变量的简单用法举例" class="headerlink" title="绑定变量的简单用法举例"></a>绑定变量的简单用法举例</h2><p>以下是几个绑定变量的简单用法示例：</p><ol><li><p>查询语句中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> :dept_id;</span><br></pre></td></tr></table></figure><p> 其中，<code>:dept_id</code> 是绑定变量，我们可以在执行查询之前为其提供实际的参数值。</p></li><li><p>插入语句中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (employee_id, first_name, last_name) <span class="keyword">VALUES</span> (:emp_id, :first_name, :last_name);</span><br></pre></td></tr></table></figure><p> 在执行插入操作之前，我们可以为绑定变量 <code>:emp_id</code>、<code>:first_name</code> 和 <code>:last_name</code> 提供实际的参数值。</p></li><li><p>在PL/SQL代码块中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  v_salary NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> v_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> :emp_id;</span><br><span class="line">  <span class="comment">-- 其他操作</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p> 在PL/SQL代码块中，我们可以使用绑定变量 <code>:emp_id</code> 来接收查询结果或传递参数。</p></li></ol><blockquote><p>绑定变量是Oracle数据库中提升查询性能和安全性的重要工具。它通过减少SQL解析开销和查询重编译次数的方式，显著提高了数据库的查询效率。通过正确应用绑定变量，开发人员可以优化查询操作并提升数据库性能。在实际应用中，我们应充分利用绑定变量的优势，并遵循最佳实践，以获得最佳的性能和安全性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探索Oracle数据库中的Session Cursor</title>
      <link href="/posts/55163.html"/>
      <url>/posts/55163.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Session Cursor是与会话（Session）相关联的游标，用于在数据库中执行SQL语句和处理查询结果集。它提供了一个可以在会话期间重用和共享的游标，用于多次执行相同或类似的SQL语句，以提高效率和性能。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>在Oracle数据库中，Session Cursor根据它们的来源和用途可以分为以下几种类型：</p><ol><li><p>隐式游标（Implicit Cursors）：隐式游标由Oracle数据库自动创建和管理，用于处理简单的SQL语句，如单条查询语句和DML语句。它们无需手动声明或关闭，数据库会自动处理隐式游标的生命周期。</p></li><li><p>显式游标（Explicit Cursors）：显式游标需要开发人员手动声明、使用和关闭。它们适用于处理复杂的SQL语句，允许在程序中对结果集进行更灵活的处理，同时也可以绑定变量和参数。</p></li><li><p>参考游标（Reference Cursors）：参考游标是一种特殊类型的游标，可以作为参数传递或作为函数返回值使用。它们通常在存储过程或函数中使用，允许在不同的会话之间共享游标结果集。</p></li></ol><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>Session Cursor具有一些常用的属性，可用于检查和处理游标的状态和结果，包括：</p><ol><li><p>FOUND：用于检查游标是否有可用的查询结果，返回TRUE或FALSE。</p></li><li><p>NOTFOUND：用于检查游标是否没有可用的查询结果，返回TRUE或FALSE。</p></li><li><p>ISOPEN：用于检查游标是否打开（Open），返回TRUE或FALSE。</p></li><li><p>ROWCOUNT：返回最后一个SELECT查询返回的行数，或者最后一个DML语句影响的行数。</p></li></ol><h2 id="使用方法举例"><a href="#使用方法举例" class="headerlink" title="使用方法举例"></a>使用方法举例</h2><p>以下是使用Session Cursor的一般方法举例，包括属性的使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    cursor_name SYS_REFCURSOR;</span><br><span class="line">    result_variable TABLE_NAME.COLUMN_NAME<span class="operator">%</span>TYPE;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">OPEN</span> cursor_name <span class="keyword">FOR</span> <span class="keyword">SELECT</span> COLUMN_NAME <span class="keyword">FROM</span> TABLE_NAME;</span><br><span class="line">    <span class="comment">-- 使用游标属性进行判断和处理结果</span></span><br><span class="line">    IF cursor_name<span class="operator">%</span>FOUND <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> result_variable;</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Result: &#x27;</span> <span class="operator">||</span> result_variable);</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;No result found.&#x27;</span>);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    IF cursor_name<span class="operator">%</span>ISOPEN <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">CLOSE</span> cursor_name;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>以上示例中，我们声明了一个显式游标”cursor_name”，然后打开游标、使用游标属性%FOUND来判断是否有查询结果，进而处理结果。最后，我们还使用了%ISOPEN属性来检查游标是否打开，并在需要时关闭游标。</p><blockquote><p>Session Cursor是Oracle数据库中一种重要的工具，用于执行SQL语句并处理查询结果集。通过了解其定义、分类、常用属性和使用方法举例，我们可以更好地利用Session Cursor提供的灵活性和高效性，优化数据库操作，并提高性能和开发效率。作为数据库开发人员和管理员，熟练掌握Session Cursor的概念和使用方法将为您的工作带来巨大的帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> OracleSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬解析、软解析和软软解析</title>
      <link href="/posts/22265.html"/>
      <url>/posts/22265.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在 Oracle 中，每条 SQL 语句在执行之前都需要经过解析（Parse），根据解析的过程可以分为 3 种类型：硬解析（Hard Parse）、软解析（Soft Parse）和软软解析（Soft Soft Parse），软软解析也叫快速解析（Fast Parse）。DDL 语句每次执行都需要进行硬解析，DML 语句和 SELECT 语句会根据情况选择是进行硬解析，还是进行软解析或者进行软软解析。</p><blockquote><p>判断硬解析和软解析的依据在于 sga 中的 share cursor 的缓存情况<br>判断软解析和软软解析的依据在于 pga 中的 session cursor 是否可以重用</p></blockquote><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://cheneyblog.com//posts/22532.html">【Oracle】Oracle Cursor（游标）</a></p><h2 id="SQL-执行过程"><a href="#SQL-执行过程" class="headerlink" title="SQL 执行过程"></a>SQL 执行过程</h2><p>&emsp;&emsp;客户端进程将 SQL 语句通过监听器发送到 Oracle, 触发一个 Server process 生成，来对该客户进行服务。Server process 得到 SQL 语句之后，对 SQL 语句进行 Hash 运算，然后根据 Hash 值先到当前会话的 PGA 中查找是否存在匹配的缓存会话游标（Session Cursor），如果 PGA 中不存在则到 library cache 中查找是否存在匹配的父游标（Parent Cursor）和子游标（Child Cursor），如果都不存在则重新开始解析目标 SQL，选择最优执行计划，执行 SQL 并将结果返回给客户端。<br><img src="https://www.cdn.cheneyblog.com/blog/202309221612022.png" alt="SQL 执行过程"></p><h2 id="硬解析"><a href="#硬解析" class="headerlink" title="硬解析"></a>硬解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找不到匹配的缓存会话游标，在 SGA 的库缓存（Library Cache）中没有找到匹配的父游标或是找到了匹配的父游标没有找到对应子游标。那么 oracle 就会重新开始解析该目标 SQL，那么 Oracle 就会新生成一个会话游标和一对共享游标（即父游标和子游标）解析目标 SQL，这种方式我们称之为硬解析。</p><h3 id="硬解析执行步骤"><a href="#硬解析执行步骤" class="headerlink" title="硬解析执行步骤"></a>硬解析执行步骤</h3><ol><li>语法检查</li><li>权限与对象检查</li><li>优化器生成多个执行计划</li><li>选择最优的执行计划</li><li>将执行计划，SQL 文本等装载进 library cache 中的 heap 中</li></ol><h2 id="软解析"><a href="#软解析" class="headerlink" title="软解析"></a>软解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找不到匹配的缓存会话游标，但在库缓存中找到了匹配的父游标和子游标，那么 Oracle 会新生成一个会话游标并重用刚刚找到的父游标和子游标，直接调用解析树和执行计划解析目标 SQL，这种方式我们称之为软解析。</p><h2 id="软软解析"><a href="#软软解析" class="headerlink" title="软软解析"></a>软软解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找到了匹配的缓存会话游标，那么此时 Oracle 就不再需要新生成一个会话游标，并且也不再需要像软解析那样得去 SGA 的库缓存中查找匹配的父游标了，因为 Oracle 此时可以重用找到的匹配会话游标，并且可以通过这个会话游标直接访问到该 SQL 对应的父游标获取解析树和执行计划解析目标 SQL，这种方式我们称之为软软解析。</p><pre><code>软软解析的必要条件：1. 参数session_cached_cursors的值是大于02. 同一个session中执行过三次以上目标SQL</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><table><thead><tr><th>类型</th><th>硬解析</th><th>软解析</th><th>软软解析</th></tr></thead><tbody><tr><td>优缺点</td><td>硬解析可能会导致 Shared Pool Latch 争用，会消耗大量 CPU 资源以及 SGA 资源，OLTP 系统硬解析是万恶之源</td><td>软解析也可能会导致库缓存相关 Latch 的争用，但持有次数少时间短</td><td>省去了 Open 一个新游标和 Close 一个现有会话游标消耗的资源和时间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> OracleSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cursor（游标）</title>
      <link href="/posts/22532.html"/>
      <url>/posts/22532.html</url>
      
        <content type="html"><![CDATA[<pre><code>Cursour(游标)是Oracle数据库中解析SQL和执行SQL的载体。</code></pre><h2 id="Shared-Cursor"><a href="#Shared-Cursor" class="headerlink" title="Shared Cursor"></a>Shared Cursor</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Shared Cursor 是指缓存在库缓存里 SQL 语句和匿名 PL/SQL 对应的 SQL 文本、解析树、目标 SQL 涉及的对象、目标 SQL 中的绑定变量及 SQL 的执行计划等信息。</p><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>Shared Cursor 又细分为 Parent Cursor（父游标）和 Child Cursor（子游标）两种。<code>V$SQLAREA</code> 可查看 Parent Cursor，<code>V$SQL</code> 可查看 Child Cursor（CHILD_NUMBER 值从 0 开始）。Parent Cursor 和 Child Cursor 均已库缓存对象句柄的方式缓存在库缓存中，Namespace 为 CRSR。</p><h3 id="父子游标的区别和联系"><a href="#父子游标的区别和联系" class="headerlink" title="父子游标的区别和联系"></a>父子游标的区别和联系</h3><ol><li>目标 SQL 的 SQL 文本存储在 Parent Cursor 所对应库缓存对象句柄的 Name 属性中，Child Cursor 的 Name 属性为空；</li><li>目标 SQL 的解析树和执行规则会存储在 Child Cursor 对应库缓存对象句柄的 Heap 6 中；</li><li>Parent Cursor 的 Heap 0 中存储了该父游标对应的所有子游标库缓存对象句柄地址。</li></ol><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>由于不同目标 SQL 的文本对应的哈希值可能相同，且同一个目标 SQL 也可能存在多份不同的解析树和执行计划。为了尽量减少对应 Hash Bucket 中库缓存对象句柄链表的长度，同时减少 Oracle 检索库缓存对象句柄链表所消耗的时间和工作量，Oracle 父子游标并存的结构一直延续至今。</p><h2 id="Session-Cursor"><a href="#Session-Cursor" class="headerlink" title="Session Cursor"></a>Session Cursor</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Session Cursor 是解析和执行 SQL 的载体，Session Cursor 也是以哈希表的方式缓存起来，只不过是缓存在 PGA 中。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>Session Cursor 和 Session 一一对应，不同的 Session 的 Session Cursor 之间没法共享</li><li>Session Cursor 有生命周期，在使用过程中都至少会经历一次 Open、Parse、Bind、Execute、Fetch 和 Close 中的一个或多个阶段</li><li>Session Cursor 也是以哈希表的方式缓存在 PGA 中，Oracle 会同样根据哈希运算来存储和访问当前 Session 对应 PGA 中 Session Cursor</li><li>一个 Session Cursor 对应一个 Shared Cursor，一个 Shared Cursor 可以同时对应多个 Session Cursor</li><li>一个 Session Cursor 能够被缓存在 PGA 中的必要条件是该 Session Cursor 所对应的 SQL 解析和执行次数要超过 3 次</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>解析和执行目标 SQL</li><li>Oracle 依靠 Session Cursor 将目标 SQL 所涉及的数据从 Buffer Cache 的对应数据块读到 PGA，然后 PGA 做后续处理（排序、表连接）</li></ul><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>OPEN_CURSORS</td><td>设定单个 Session 中同时以 Open 状态并存的 Session Cursor 的总数</td></tr><tr><td>SESSION_CACHED_CURSORS</td><td>设定单个 Session 中能够以 Soft Closed 状态并存的 Session Cursor 总数</td></tr><tr><td>CURSOR_SPACE_FOR_TIME</td><td>Oracle 11gR1 之前的版本用来减少库缓存相关 Latch 争用，副作用是增加 Shared Pool 压力</td></tr></tbody></table><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>隐式游标（Implicit Cursor）</li><li>显式游标（Explicit Cursor）</li><li>参考游标（Ref Cursor）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> OracleSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星球资源</title>
      <link href="/posts/28703.html"/>
      <url>/posts/28703.html</url>
      
        <content type="html"><![CDATA[<h2 id="特邀嘉宾"><a href="#特邀嘉宾" class="headerlink" title="特邀嘉宾"></a>特邀嘉宾</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>理解SSL证书：构建安全可信的Web通信环境</title>
      <link href="/posts/34621.html"/>
      <url>/posts/34621.html</url>
      
        <content type="html"><![CDATA[<h2 id="SSL证书的作用"><a href="#SSL证书的作用" class="headerlink" title="SSL证书的作用"></a>SSL证书的作用</h2><p>SSL证书有以下重要作用：</p><ul><li>网站身份验证：SSL证书由权威的证书颁发机构（CA）签发，用于验证网站的真实性和合法性。用户可以通过浏览器对证书的验证结果来判断网站的可信度。</li><li>数据传输加密：SSL证书使用加密技术，将传输的数据进行加密，防止第三方窃取和篡改敏感信息。</li><li>数据传输完整性保护：SSL证书使用消息摘要和数字签名等技术，确保传输过程中数据的完整性，防止数据被篡改。</li></ul><h2 id="SSL证书的原理"><a href="#SSL证书的原理" class="headerlink" title="SSL证书的原理"></a>SSL证书的原理</h2><p>SSL证书采用公钥加密技术，涉及以下几个关键组件：</p><ul><li>公钥：SSL证书中包含网站的公钥，用于加密传输数据。</li><li>私钥：私钥是与公钥对应的解密密钥，由网站的服务器保管。只有拥有私钥的服务器才能解密加密的数据。</li><li>数字签名：CA使用自己的私钥对证书进行签名，确保证书的真实性和完整性。验证证书时，可以使用CA的公钥来验证签名，从而判断证书的有效性。</li></ul><h2 id="SSL证书的部署"><a href="#SSL证书的部署" class="headerlink" title="SSL证书的部署"></a>SSL证书的部署</h2><p>SSL证书部署包括以下步骤：</p><ul><li>选择证书类型：根据实际需求选择适合的SSL证书类型，如域名验证证书、组织验证证书或扩展验证证书。</li><li>生成证书请求：在服务器上生成证书请求文件（CSR），包含相关信息，如域名、组织信息等。</li><li>购买SSL证书：将CSR文件提交给CA，购买SSL证书，并通过身份验证流程获得证书。</li><li>安装和配置证书：将获得的SSL证书安装在服务器上，并进行相应的配置，以启用HTTPS协议和加密通信。</li><li>定期更新证书：SSL证书的有效期通常为1年或更长，确保定期更新证书以保障持续的安全通信。</li></ul>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解HTTP与HTTPS：保障Web通信安全的重要技术</title>
      <link href="/posts/26748.html"/>
      <url>/posts/26748.html</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h2><p>HTTP是Web通信的基础协议，用于客户端（如浏览器）与服务器之间的数据传输。它采用明文传输，存在以下特点：</p><ol><li>无状态协议：每个请求和响应都是相互独立的，不保留任何状态信息。</li><li>明文传输：请求和响应中的数据传输是明文的，容易被第三方窃取和篡改。</li><li>请求方法：HTTP定义了多种请求方法，如GET、POST、PUT、DELETE等，以满足不同的处理需求。</li></ol><h2 id="HTTPS（安全的超文本传输协议）"><a href="#HTTPS（安全的超文本传输协议）" class="headerlink" title="HTTPS（安全的超文本传输协议）"></a>HTTPS（安全的超文本传输协议）</h2><p>HTTPS在HTTP基础上添加了安全层，通过SSL（安全套接层）或TLS（传输层安全）协议对数据进行加密和保护。它解决了HTTP不安全的问题，具有以下特点：</p><ol><li>数据加密：HTTPS使用加密技术对数据进行加密，使得第三方无法直接获取明文内容。</li><li>身份验证：HTTPS通过SSL证书对服务端进行身份验证，确保数据传输的安全性和源的可信度。</li><li>数据完整性：HTTPS使用消息摘要和数字签名等技术确保数据在传输过程中的完整性，防止数据被篡改。</li><li>SEO优化：搜索引擎对HTTPS网站有更高的权重，使用HTTPS可提升网站的排名和可信度。</li></ol><h2 id="HTTP、HTTPS对比"><a href="#HTTP、HTTPS对比" class="headerlink" title="HTTP、HTTPS对比"></a>HTTP、HTTPS对比</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309181420777.webp" alt="HTTP、HTTPS对比"></p><h2 id="HTTPS的部署"><a href="#HTTPS的部署" class="headerlink" title="HTTPS的部署"></a>HTTPS的部署</h2><p>在实际应用中，部署HTTPS需要以下步骤：</p><ol><li>购买SSL证书：选择可信、权威的证书颁发机构（CA）购买SSL证书，用于对服务端进行身份验证。</li><li>证书绑定与配置：将SSL证书绑定到Web服务器上，并进行相应的配置，以启用HTTPS协议。</li><li>重定向配置：将HTTP请求自动重定向至HTTPS，确保用户访问始终通过安全通道。</li><li>安全加固：配置服务器安全性和加密算法，采取防护措施防范潜在的安全威胁。</li></ol><p>HTTP和HTTPS是Web通信的关键协议，对保障信息的安全性和保护用户隐私起着重要作用。了解它们的特点、区别和部署流程，对于保护数据安全、提升用户体验和符合搜索引擎优化有着重要意义。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS：互联网底层通信的重要基石</title>
      <link href="/posts/44850.html"/>
      <url>/posts/44850.html</url>
      
        <content type="html"><![CDATA[<p>DNS（Domain Name System）是一个分布式的、层次化的命名系统，用于将易于记忆的域名映射到对应的IP地址。它充当了一个“电话簿”或“黄页”的角色，提供了一个将域名转化为IP地址的服务。了解DNS的工作原理对于理解互联网通信以及开发和维护网络应用程序至关重要。</p><p>以下是DNS的关键组成部分和工作原理：</p><ol><li><p>域名空间：域名空间是域名按照层次结构组织的方式。域名由多个部分组成，以点分隔，从右向左逐级精确到更具体的标识。例如，<a href="http://www.example.com中,com是顶级域名,example是二级域名,www是三级域名./">www.example.com中，com是顶级域名，example是二级域名，www是三级域名。</a></p></li><li><p>域名服务器：域名服务器是存储域名和对应IP地址映射关系的服务器。域名服务器分为多个层次，包括根域名服务器、顶级域名服务器和权威域名服务器。它们通过递归和迭代查询的方式来解析域名。</p></li><li><p>域名解析过程：当用户在浏览器中输入一个域名时，本地计算机首先向本地域名服务器发起解析请求。如果本地域名服务器没有缓存该域名的IP地址，它将依次向根域名服务器、顶级域名服务器和权威域名服务器发起查询请求，直到找到正确的IP地址。</p></li><li><p>缓存和TTL：为了提高域名解析的速度和效率，本地域名服务器会将解析结果缓存一段时间。TTL（Time-To-Live）确定缓存的有效时间，在TTL过期之前，本地域名服务器将直接返回缓存的结果，而不再重新查询。</p></li><li><p>域名安全性：DNSSEC（DNS Security Extensions）是一种用于增强DNS安全性的扩展机制。它通过数字签名和验证来确保域名解析过程中信息的完整性和真实性，防止DNS劫持和欺骗等安全威胁。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名技术：解密互联网命名系统</title>
      <link href="/posts/11682.html"/>
      <url>/posts/11682.html</url>
      
        <content type="html"><![CDATA[<p>域名技术是建立在互联网命名系统（DNS）之上的。DNS是一个分布式的、层次化的命名系统，用于将域名映射到与之关联的IP地址。它实现了将易于记忆的域名转换为计算机能够理解的IP地址的过程。</p><p>域名技术在互联网中起着重要作用：</p><ol><li><p>域名解析：域名解析是将域名转换为IP地址的过程。当用户在浏览器中输入一个域名时，计算机需要通过域名解析来找到该域名对应的IP地址，从而建立连接。</p></li><li><p>域名注册与管理：域名技术涉及域名的注册和管理。域名可以通过域名注册商购买，并与相应的IP地址进行关联。域名注册商负责维护域名的注册信息并提供域名管理服务。</p></li><li><p>域名服务器：域名技术涉及到域名服务器的建立和管理。域名服务器存储着域名和对应IP地址的映射关系。当用户发起域名解析请求时，域名服务器会返回对应的IP地址。</p></li><li><p>域名安全性：域名技术还与域名的安全性密切相关。域名可以成为网络攻击的目标，例如域名劫持和域名欺诈。因此，域名技术需要包括安全机制来防止域名被滥用。</p></li></ol><p>域名技术的工作原理可以简要概括如下：</p><ol><li><p>递归查询：当用户输入一个域名时，计算机首先发送查询请求给本地域名服务器。如果本地域名服务器不知道该域名对应的IP地址，它会依次向根域名服务器、顶级域名服务器和权限域名服务器发起查询请求，直到找到对应的IP地址。</p></li><li><p>域名解析链路：在查询过程中，域名服务器会根据域名的层次结构依次查询相关的域名服务器，以获取最终的IP地址。</p></li><li><p>缓存和更新：一旦域名解析完成，本地域名服务器会将结果缓存，以加快之后对相同域名的访问速度。同时，域名注册商也会提供域名管理服务，允许域名所有者更改IP地址和其他相关信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析：连接互联网的关键枢纽</title>
      <link href="/posts/330.html"/>
      <url>/posts/330.html</url>
      
        <content type="html"><![CDATA[<p>域名解析是将易于记忆的域名转化为对应的IP地址的过程。当用户在浏览器中输入一个域名时，计算机并不知道如何直接连接到该域名对应的服务器，需要通过域名解析来找到正确的IP地址，从而建立连接。</p><p><img src="https://www.cdn.cheneyblog.com/blog/202309181411003.png" alt="域名解析的过程"></p><p>域名解析的过程可以大致分为以下几个步骤：</p><ol><li><p>发起解析请求：当用户输入一个域名时，计算机会向本地域名服务器发起解析请求。本地域名服务器通常由互联网服务提供商（ISP）或其他DNS（域名系统）服务提供商提供。</p></li><li><p>迭代查询：如果本地域名服务器不知道该域名对应的IP地址，它会向根域名服务器发起查询请求。根域名服务器存储着顶级域名服务器的地址。</p></li><li><p>顶级域名服务器查询：根域名服务器会告知本地域名服务器该域名对应的顶级域名服务器的地址。本地域名服务器再向顶级域名服务器发起查询请求。</p></li><li><p>权限域名服务器查询：顶级域名服务器会继续指引本地域名服务器向权限域名服务器发起查询请求。权限域名服务器通常由域名注册商提供。</p></li><li><p>查询结果返回：权限域名服务器会将域名对应的IP地址返回给本地域名服务器，然后由本地域名服务器将结果返回给用户的计算机。</p></li><li><p>结果缓存：为了提高解析效率，本地域名服务器会将解析结果缓存一段时间。下次用户再访问相同域名时，可以直接返回缓存的结果，从而减少查询时间。</p></li></ol><p>域名解析的过程中，还涉及到TTL（存活时间）的概念。TTL表示在重新查询之前，缓存在本地域名服务器中对应域名解析结果的有效时间。TTL的设置由域名所有者或域名注册商控制，适当的TTL设置可以提高解析效率并确保及时更新。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN：实现高速可靠的网络内容分发</title>
      <link href="/posts/31314.html"/>
      <url>/posts/31314.html</url>
      
        <content type="html"><![CDATA[<p>CDN是一种分布式的网络架构，通过将内容存储在离用户更近的服务器上，实现了快速可靠的内容分发。大多数传统的网络架构采用单一服务器来存储和提供内容。当用户请求访问该服务器时，可能出现带宽瓶颈和延迟等问题。而CDN通过部署位于全球各地的边缘节点，使内容在离用户更近的地方就近提供，从而显著提高了用户体验。</p><h2 id="CDN的工作原理"><a href="#CDN的工作原理" class="headerlink" title="CDN的工作原理"></a>CDN的工作原理</h2><ol><li><p>内容复制和缓存：CDN将内容复制到分布在不同地理位置的服务器上，并根据用户访问模式进行缓存。这样，当用户请求访问某个内容时，CDN会将内容分发到离用户最近的节点上。</p></li><li><p>路由选择：CDN通过智能路由算法选择最佳的节点来提供内容。算法会考虑节点的性能、可用带宽和用户位置等因素，确保用户能够从最佳的服务器获取内容。</p></li><li><p>动态负载均衡：CDN能够根据服务器的负载情况和用户请求的分布，动态调整内容的分发策略，以保证各个节点的负载均衡，提高整体服务的可靠性和响应速度。</p></li></ol><h2 id="CDN的优势"><a href="#CDN的优势" class="headerlink" title="CDN的优势"></a>CDN的优势</h2><ul><li><p>提供快速访问体验：CDN的分布式网络架构确保内容就近存放，减少了数据传输的距离和延迟，提高了用户访问速度和响应时间。</p></li><li><p>应对网络拥塞：在大型事件、热门活动或突发事件期间，用户访问量激增可能导致服务器拥塞。CDN通过将流量分散到各个节点，减轻了服务器的负荷，保证服务的稳定性。</p></li><li><p>提高故障恢复能力：当某个节点出现故障时，CDN可以快速切换到其他正常的节点，确保内容正常提供，减少故障对用户体验的影响。</p></li><li><p>防御网络攻击：CDN可以通过分散流量和筛选非法请求等方式，帮助网站抵御大规模DDoS攻击和其他恶意行为。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之稳定执行计划</title>
      <link href="/posts/1085.html"/>
      <url>/posts/1085.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-Hint"><a href="#Oracle-Hint" class="headerlink" title="Oracle Hint"></a>Oracle Hint</h2><p>&emsp;&emsp;Oracle Hints 是一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划，它允许用户在 SQL 语句中插入相关的语法，从而影响 SQL 的执行方式。</p><h3 id="Hint-的作用"><a href="#Hint-的作用" class="headerlink" title="Hint 的作用"></a>Hint 的作用</h3><ol><li>调整目标 SQL 使用的优化器类型</li><li>调整优化器的优化目标</li><li>调整表的访问路径</li><li>调整表的连接类型</li><li>调整表的连接顺序</li><li>提高语句的并行程度</li></ol><h3 id="Hint-的弊端"><a href="#Hint-的弊端" class="headerlink" title="Hint 的弊端"></a>Hint 的弊端</h3><ul><li>Hint 是比较”暴力”的一种解决方式，不是很优雅。需要开发人员手工修改代码。</li><li>Hint 不会去适应新的变化，只是在现有的基础上产生更优的执行计划。</li><li>Hint 随着数据库版本的变化，可能会有一些差异、甚至废弃的情况。</li></ul><h2 id="Oracle-stored-outline"><a href="#Oracle-stored-outline" class="headerlink" title="Oracle stored outline"></a>Oracle stored outline</h2><p>&emsp;&emsp;Oracle stored outline（存储提纲）是最早的基于提示来控制 SQL 执行计划的机制，也是 9i 以及之前版本唯一可以用来稳定和控制 SQL 执行计划的工具。主要的作用是用来保持固定 sql 语句的执行计划，让 sql 语句的执行计划在数据库环境变更（统计信息、优化器参数、表结果变更等）后还能保持原来的执行计划。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>避免 SQL 的执行计划在统计数据不准确的情况（如未能及时收集表或索引的统计信息）下导致变化从而引起的性能降低。</li><li>避免容易因为 Bind Peeking 导致 SQL 执行计划变差从而引起的性能降低。</li><li>避免大规模分布实施的应用出现数据库版本、配置等区别引起的优化器产生不同的执行计划。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从 10g 以后，outline 基本已经被 Oracle 废弃并且不在维护。</li><li>只有设置 use_stored_outlines 参数后才能启用 outline。</li><li>创建 outline 需要 create any outline or execute_catelog_role 权限 。</li></ul><h2 id="SQL-Profile"><a href="#SQL-Profile" class="headerlink" title="SQL Profile"></a>SQL Profile</h2><p>&emsp;&emsp;SQL Profile 是 stored outline 的进化版，是为目标 SQL 提供除了统计信息之外的其他信息，比如运行环境、更准确的执行路径等，以帮助优化器为 SQL 语句选择更合适的执行计划。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>更容易生成、更改和控制</li><li>适用范围广</li><li>在不改变目标 SQL 文本的情况下达到稳定执行计划的效果</li></ol><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>Automatic 类型的 SQL Profile<br>Automatic 类型的 SQL Profile 其实是目标 SQL 一些额外的调整信息，这些信息存储在数据字典中。Oracle 会使用类似于动态采样的方法来支持 Automatic 类型的 SQL Profile，在生成执行计划的时候 Oracle 会将调整信息同原 SQL 的相关统计信息等内容一起作用从而得到最新的执行计划</li><li>Manual 类型的 SQL Profile<br>Manual 类型 SQL Profile 的本质是一堆来源 Outline Data 部分的 Hint 组合，可以在不改变目标 SQL 文本的情况下调整其执行计划</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;SQL Profile 实际上只是一种亡羊补牢、被动的技术手段，应用在那些执行计划已经发生了不好的变更的 SQL 上，即当我们发现这些 SQL 的执行计划已经出了问题时通过创建 SQL Pofle 来纠正、稳定这些 SQL 的执行计划。也就是说，即便通过创建 SQLProfile 解决了目标 SQL 执行计划变更的问题，依然不能保证系统后续执行的 SQL 的执行计划就不再发生不好的变更。</p><h2 id="SPM（SQL-Plan-Management）"><a href="#SPM（SQL-Plan-Management）" class="headerlink" title="SPM（SQL Plan Management）"></a>SPM（SQL Plan Management）</h2><p>&emsp;&emsp;SPM 是一种主动的稳定执行计划的手段，能够保证只有被验证过的执行计划才会被启用。SPM 既能够主动地稳定执行计划，又保留了继续使用新的执行效率可能更高的执行计划的机会。 SPM 启动后，每个 SQL 的所有执行计划都有对应的 SQL Plan Baseline，可以通过 DBA_SQL_PLAN_BASELINE 查看。只有 DBA_SQL_PLAN_BASELINE 表中 ENABLE 和 ACCEPTED 列的值均为’YES’的 SQL Plan Baseline 对应的执行计划才会被 Oracle 启用。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ul><li>自动捕获（Automatic Initial Plan Capture）</li></ul><ol><li>设置 OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES = Ture</li><li>Oracle 自动监控执行两次以上的 SQL 语句，将执行计划记入 Plan History。</li><li>生成的第一个执行计划被标记为 ENABLED 并且是 ACCEPTED，后续的执行计划会被标记为 ENABLED 但不是 ACCEPTED。</li><li>后续如果关闭了自动捕捉，针对存在 baseline 的 SQL，仍旧会有新的 PLAN 生成，新的 Plan 仍会进入 Plan History，标记为 ENABLED 但不是 ACCEPTED。</li></ol><ul><li>手动导入（Manual Plan Capture）<br>Oracle 支持通过 DBMS_SPM 包手动管理 SPM，可以将 SQL 执行计划从高速缓存或现有的 SQL 优化集中加载到 SPM。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之其他执行计划</title>
      <link href="/posts/44822.html"/>
      <url>/posts/44822.html</url>
      
        <content type="html"><![CDATA[<h2 id="AND-EQUAL-INDEX-MERGE"><a href="#AND-EQUAL-INDEX-MERGE" class="headerlink" title="AND-EQUAL(INDEX MERGE)"></a>AND-EQUAL(INDEX MERGE)</h2><p>INDEX MERGE 是指当 where 条件中出现针对多个不同索引列的等值条件，Oracle 会分别去扫描这些索引列，然后合并每个索引的集合，找到值相同的 ROWID 最后回表。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>涉及到的索引都为单列索引<br>索引都在查询中出现<br>谓词使用=关系符号连接<br>从 Oracle 10g 开始，and_equal 操作被废弃，Oracle 不再支持，这里废弃的含义并不是被彻底移除，而是说不再进行改进，通过 hints 仍然可以强制实现 Index Merge 的 and_equal 操作。</p><h2 id="INDEX-JOIN"><a href="#INDEX-JOIN" class="headerlink" title="INDEX JOIN"></a>INDEX JOIN</h2><p>对 index 进行关联,oracle 通过 hash index join 的方式实现了避免对表的访问.所有的数据都从索引中直接获得.它不受查询条件影响,可以是唯一索引,也可以是多列索引.</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果不是所有数据都能从索引获得,那么将不会使用 index join</p><h2 id="VIEW"><a href="#VIEW" class="headerlink" title="VIEW"></a>VIEW</h2><p>Oracle 在处理包含视图的 SQL 时，通常会根据该视图是否能做视图合并（View Merging），即 Oracle 在执行该 SQL 时可以直接针对该视图的基表，此时 SQL 的执行计划中很可能不会出现关键字”VIEW”<br>对于某些 SQL 而言，即使 Oracle 已经做了视图合并但其所对应的执行计划中可能还是会显示关键字”VIEW”<br>如果不能做视图合并，则 Oracle 将把该视图看作一个整体并独立地执行它，此时 SQL 的执行计划中将出现关键字”VIEW”</p><h2 id="FILTER"><a href="#FILTER" class="headerlink" title="FILTER"></a>FILTER</h2><p>FILTER 直译过来就是过滤、筛选的意思，它是一种特殊的执行计划。</p><pre><code>FILTER 类型的执行计划实际上是一种改良的嵌套循环连接，FILTER的性能跟列值distinct数有关</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li>得到一个驱动结果集。</li><li>根据一定的过滤条件从上述驱动结果集中滤除不满足条件的记录。</li><li>结果集中剩下的记录就会返回给最终用户或者继续参与下一个执行步骤。</li></ol><h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><ol><li>SORT AGGREGATE<br>通常发生在使用一些聚合函数的时候，sum(),avg(),min(),max()，count（）等等，实际上 sort aggregate 不做真正的 sort，并不会用到排序空间，而是通过一个全局变量＋全表或全索引扫描来实现</li><li>SORT UNIQUE<br>需要取 distinct 值的时候或 in 子查询</li><li>SORT GROUP BY<br>发生在有 group by 子句的时候</li><li>SORT ORDER BY<br>发生在有 order by 子句的时候</li><li>SORT JOIN<br>发生在出现 merge join 的情况下，两张关联的表要各自做 sort，然后再 merge</li></ol><h2 id="UNION-UNION-ALL"><a href="#UNION-UNION-ALL" class="headerlink" title="UNION/UNION ALL"></a>UNION/UNION ALL</h2><p>UNION 和 UNIONALL 的区别是 ∶UNION ALL 仅仅是简单地将两个结果集合并，并不做任何额外的处理;而 UNION 除了将两个结果集简单合并之外，还会对合并后的结果集做排序和去重，即 UNION 相当于先做 UNION ALL，然后再对 UNIONALL 之后的结果集做 SORT UNIQUE。</p><h2 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h2><p>CONCAT 就是 IN-List 扩展（IN-List Expansion）或 OR 扩展（OR Expansion），IN-List 扩展/OR 扩展在执行计划中对应的关键字是”CONCATENATION”。<br>CONCATENATION 操作类似 union ,只不过与 union 不同的是他并不对全部数据去重.<br>CONCATENATION 操作只去除由 OR 引起的重复值.</p><h2 id="CONNECT-BY"><a href="#CONNECT-BY" class="headerlink" title="CONNECT BY"></a>CONNECT BY</h2><p>CONNECT BY 是 Oracle 数据库中层次查询（Hierarchical Queries）。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Cache 详解</title>
      <link href="/posts/27399.html"/>
      <url>/posts/27399.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;库缓存主要用于缓存刚刚执行过的 SQL 语句和 PL/SQL 语句（如存储过程、函数、包、触发器）所对应的执行计划、解析树（Parse Tree）、Pcode、Mcode 等，当同样的 SQL 语句和 PL/SOL 语句再次被执行时无须再次从头开始解析，从而提高 SQL 语句和 PL/SQL 语句重复执行的执行效率。V$DB_OBJECT_CACHE 视图可以查看 Library Cache 的对象。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p><a href="https://cheneyblog.com//posts/39514.html">Library Cache 的基本结构</a></p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>可以快速定位数据库对象，并找到对应的信息</li><li>Library Cache 中存储着各库缓存对象的依赖关系，解决依赖问题</li><li>Library Cache 可以并发控制，管理大量共享对象的并发访问和修改问题</li></ol><hr><p>&emsp;&emsp;当 SQL 语句传到服务器，Oracle 会先对目标 SQL 进行哈希运算，然后根据哈希值访问库缓存对象句柄链表，从而找到对应的库缓存对象句柄，重用 SQL 的执行计划、解析树而无需从头开始解析；如果找不到对应的库缓存对象句柄，则重新解析目标 SQL，将解析后的资源以库缓存对象句柄的方式链接在对应 Hash Bucket 的库缓存对象句柄链表中。</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>Oracle 利用 Library cache lock 和 Library cache pin 来实现并发控制，Library cache lock 是在 handle 上获取的，而 Library cache pin 则是在 data heap 上获取。访问对象时，首先必须获取 handle 上的 lock，然后将访问的数据 pin 在内存中。lock 的作用是控制进程间的并发访问，而 pin 的作用是保证数据一致性，防止数据在访问时被交换出去。</p><p>Library cache lock 有三种模式：null，share，exclusive，Library cache pin 有两种模式：share，exclusive。</p><p>每个 handle 上都有 lock 和 pin 的 holder list 和 waiter list，用来保存持有该资源和等待该资源的队列。</p><h2 id="Hash-Latch"><a href="#Hash-Latch" class="headerlink" title="Hash Latch"></a>Hash Latch</h2><p>&emsp;&emsp;当多个用户同时访问或修改 Hash Bucket 和库缓存对象句柄链表时会出现冲突,为了解决这一问题，实现用户的有序访问和共享，Oracle 生成 Hash Latch 的机制来保护这些共享资源，当一个用户需要访问或修改这些 Hash Bucket 及其库缓存对象句柄链表时，需要首先获取 Hash Latch，如果期间有其他需要获取相同 Hash Latch 的用户或会话就需要等待，直到持有该哈希 Latch 的用户释放为止.</p><pre><code>Hash Latch分类shared pool latch：分配或释放空间时使用Library cache latch：hash bucket中定位handle时使用library cache lock latch、library cache pin latch：获取lock和pin时使用</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Cache 的基本结构</title>
      <link href="/posts/39514.html"/>
      <url>/posts/39514.html</url>
      
        <content type="html"><![CDATA[<h2 id="图解-Library-Cache"><a href="#图解-Library-Cache" class="headerlink" title="图解 Library Cache"></a>图解 Library Cache</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309151502341.png" alt="Library Cache 基本结构1"></p><p><img src="https://www.cdn.cheneyblog.com/blog/202309151503289.png" alt="Library Cache 基本结构2"></p><h2 id="结构说明"><a href="#结构说明" class="headerlink" title="结构说明"></a>结构说明</h2><h3 id="Hash-Bucket"><a href="#Hash-Bucket" class="headerlink" title="Hash Bucket"></a>Hash Bucket</h3><p>库缓存相当于一个 Hash Table 由一组 Hash Bucket 构成，每个 Hash Bucket 存储相同哈希值的所有库缓存对象句柄，不同库缓存对象句柄间用指针连接，构成库缓存对象句柄链表（Library Cache Object Handles）</p><pre><code>Hash Bucket主要用于可执行对象的快速定位和存取</code></pre><h3 id="Library-Cache-Object-Handle"><a href="#Library-Cache-Object-Handle" class="headerlink" title="Library Cache Object Handle"></a>Library Cache Object Handle</h3><p>库缓存对象句柄(Library Cache Object Handle)是存储库缓存对象的一种结构，这些句柄包含了对象的相关属性，例如：名称、标记、指向对象内存地址的指针等。<br>Object Handle 的主要属性：</p><ol><li><p>Name<br>库缓存对象句柄对应的库缓存对象名称</p></li><li><p>Namespace<br>库缓存对象句柄对应的库缓存对象的分组名</p><table><thead><tr><th>Namespace 值</th><th>含义</th></tr></thead><tbody><tr><td>CRSR</td><td>SQL 语句和匿名 PL/SQL 语句</td></tr><tr><td>TABL/PRCD/TYPE</td><td>表、视图、序列、同义词、存储过程、函数、Type 和 Package</td></tr><tr><td>BODY/TYBD</td><td>Type 和 Package 的 Body</td></tr><tr><td>TRGR</td><td>Trigger</td></tr><tr><td>INDEX</td><td>索引</td></tr><tr><td>CLST</td><td>Cluster</td></tr></tbody></table></li><li><p>Heap 0 Pointer<br>指向子结构 Heap 0 的指针</p></li></ol><h3 id="Library-Cache-Object"><a href="#Library-Cache-Object" class="headerlink" title="Library Cache Object"></a>Library Cache Object</h3><p>Handle 对应可执行对象 Library Cache Object，通常以堆（Heap）的形式组成。Handle 中指向第一个堆的指针为 Heap 0，Heap 0 中包含指向其他堆的指针信息。</p><ol><li>dependency table<br>该对象依赖的对象信息</li><li>child table<br>对象的子对象；比如同一个父游标对应的不同子游标</li><li>authorization table<br>对象的授权信息</li><li>type<br>shared cursor,index,table,cluster,view,synonym,sequence,procedure,function,package,table body,package body,trigger 等等。</li><li>data blocks<br>data block 也是一个指针，指向了 data heap</li></ol><h3 id="Data-heap"><a href="#Data-heap" class="headerlink" title="Data heap"></a>Data heap</h3><p>Data heap 即存放真实数据的地方，主要包含库缓存对象的 SQL 语句、执行计划、执行文本等信息。</p><table><thead><tr><th>Heap</th><th>Usage</th></tr></thead><tbody><tr><td>0</td><td>Object</td></tr><tr><td>1</td><td>Source</td></tr><tr><td>2</td><td>Diana</td></tr><tr><td>3</td><td>Pcode</td></tr><tr><td>4</td><td>Mcode</td></tr><tr><td>5</td><td>Errors</td></tr><tr><td>6</td><td>SQL Context</td></tr><tr><td>7</td><td>Free</td></tr><tr><td>8</td><td>Subordinate Heaps</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之表连接</title>
      <link href="/posts/10468.html"/>
      <url>/posts/10468.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;表连接，顾名思义多个表之间用用连接条件连接在一起，使用表连接的目标 SQL 其目的就是从多个表获取存储在这些表中不同维度的数据。</p><h2 id="解析表连接-SQL-的要素"><a href="#解析表连接-SQL-的要素" class="headerlink" title="解析表连接 SQL 的要素"></a>解析表连接 SQL 的要素</h2><ol><li>目标 SQL 文本的写法<br>SQL 文本的写法决定表连接的类型：内连接、外连接、自连接<blockquote><p>自连接：同一张表内的字段做连接</p></blockquote></li><li>表连接顺序<br>不管目标 SQL 中有多少个表做连接，Oracle 在实际执行该 SQL 时都只能先两两 连接，再依次同剩下的表做连接，直到目标 SQL 中所有的表都已连接完毕。</li><li>表连接方法<br>排序合并连接、嵌套循环连接、哈希连接和笛卡尔积连接</li></ol><h2 id="表连接类型"><a href="#表连接类型" class="headerlink" title="表连接类型"></a>表连接类型</h2><ul><li>内连接（Join）<br>连接结果只包含那些完全满足连接条件的记录</li><li>外连接<ol><li>左外连接（Left Join）<br>表连接结果包含左边表的全部行，右边表满足连接条件的查询列正常显示，不满足展示 Null</li><li>右外连接（Right Join）<br>表连接结果包含右边表的全部行，左边表满足连接条件的查询列正常显示，不满足展示 Null</li><li>全外连接（Full Join）<br>表连接结果包含两张表的全部记录，满足连接条件的查询列正常显示，不满足连接条件的记录对应另外一张表展示 Null<blockquote><p>如果使用（+）操作符指定外连接,不满足连接条件时靠近操作符表的连接列以 Null 值填充,必须使用 Where 子句指定连接条件,否则会产生笛卡尔积</p></blockquote></li></ol></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>A 表：1，2，3，4，5<br>B 表：2，4，6，8，10<br><img src="https://www.cdn.cheneyblog.com/blog/202309151456976.png" alt="表连接"></p><h2 id="表连接方法"><a href="#表连接方法" class="headerlink" title="表连接方法"></a>表连接方法</h2><h3 id="排序合并连接-Sort-Merge-Join"><a href="#排序合并连接-Sort-Merge-Join" class="headerlink" title="排序合并连接(Sort Merge Join)"></a>排序合并连接(Sort Merge Join)</h3><pre><code>两个表在做表连接时用排序操作(Sort)和合并操作(Merge)来得到结果集的表连接方法</code></pre><p>执行步骤简析</p><ol><li><p>用目标 SQL 中指定的谓词分别去访问两张表，对谓词过滤后的表数据分别按照连接列排序生成结果集 1 和结果集 2。</p></li><li><p>遍历结果集 1，按照连接列的顺序依次匹配结果集 2 中的数据，最后结果集 1 和结果集 2 中所有的匹配结果就是上述排序合并连接的最终结果。</p></li></ol><p>适用场景</p><ul><li><p>通常情况下，排序合并连接的执行效率不如哈希连接，但前者的适用范围广，因为哈希连接通常只用于等值连接，而排序连接还能用于其他连接(例：&gt;,&lt;,&gt;=,&lt;=)。</p></li><li><p>通常情况下，排序合并连接不适合 OLTP(On-Line Transaction Processing)联机事务处理过程，因为排序相对而言成本较高。</p></li></ul><h3 id="嵌套循环连接-Nested-Loops-Join"><a href="#嵌套循环连接-Nested-Loops-Join" class="headerlink" title="嵌套循环连接(Nested Loops Join)"></a>嵌套循环连接(Nested Loops Join)</h3><pre><code>两张表在做表连接时依靠两层嵌套循环(外层循环和内层循环)来得到连接结果集的表连接方法。</code></pre><p>执行步骤</p><ol><li><p>首先 Oracle 优化器会按照一定的规则来决定驱动表和被驱动表。驱动表用于外层循环，被驱动表用于内层循环。</p></li><li><p>然后分别用目标 SQL 中指定的谓词去筛选数据。</p></li><li><p>接着遍历驱动表按照连接条件去匹配被驱动表中的数据，直到遍历完驱动表中的所有数据。显然驱动表有多少数据，内层循环就要做多少次。</p></li></ol><p>适用场景</p><ul><li><p>如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列上又存在唯一索引(或者在被驱动表的连接列上存在选择性比较好的非唯一性索引)，那么此时使用嵌套循环连接的执行效率就会非常高；但如果驱动表所对应的驱动结果集的记录数很多，即便被驱动表的连接列上存在索引，此时使用嵌套循环连接的执行效率也不会太高。</p></li><li><p>大表也可以作为嵌套循环连接的驱动表，关键看目标 SQL 中指定谓词条件能否将驱动结果集的数据量降下来。</p></li><li><p>嵌套循环连接有一个其他连接方法没有的优点：嵌套循环连接可以实现快速响应。</p></li></ul><blockquote><p>在 Oracle11g 中，Oracle 引入了向量 I/O(Vector I/O)。在引入向量 I/O 后，Oracle 就可以将原先一批单块读所需要消耗的物理 I/O 组合起来，然后用一个向量 I/O 去批量处理他们，这样就实现了在单块读的数据量不降低的情况下减少这些单块读所需要消耗的物理 I/O 数量，也就提高了嵌套循环连接的执行效率。</p></blockquote><h3 id="哈希连接-Hash-Join"><a href="#哈希连接-Hash-Join" class="headerlink" title="哈希连接(Hash Join)"></a>哈希连接(Hash Join)</h3><pre><code>两张表在做表连接时主要依靠哈希运算来得到连接结果集的表连接方法。</code></pre><p>执行步骤</p><ol><li>两张表在施加了目标 SQL 指定谓词条件后，结果集数量较少的将被 Oracle 选为哈希连接的驱动表，反之结果集数据量较多的选做被驱动结果集。</li><li>哈希运算会在 hash area 生成 hash bulket，并将若干 bulket 分成一组，成为一个 partition，还会生成一个 bitmap 的列表，每个 bulket 在上面占一位</li><li>对驱动表的连接列做 hash 运算，将数据分散到相应 partition 的 bulket 中，当运算完成后，如果键值唯一性较高的话，bulket 里的数据会比较均匀，也有可能有的桶里面数据会是空的，这样 bitmap 上对应的标志位就是 0，有数据的桶，标志位会是 1</li><li>再对被驱动表的连接列做 hash 运算，确定应该到某个 partition 的某个 bulket 去探测，探测之前，会看这个 bulket 的 bitmap 是否会 1，如果为 0，表示没数据，这行就直接丢弃掉，如果 bitmap 为 1，则在桶内做精确匹配，判断 OK 后，返回数据</li><li>如果驱动表或被驱动表数据量很大，在构建对应的 Hash Table 时，会出现 PGA 的工作区(Work Area)被填满的情况，这时 Oracle 会把工作区中包含记录数最多的 Hash Partition 写到磁盘上(TEMP 表空间)。</li><li>两张表都扫描完毕后，由于两边的数据都按照相同的 hash 算法做的 partition 和 bulket，现在只要成对的比较两边 partition 数据即可，并且在比较的时候，oracle 也做了优化处理，没有严格的驱动与被驱动关系，他会在 partition 对中选较小的一个作为驱动来进行，直到磁盘上所有的 partition 对都比较完成，哈希连接处理结束</li></ol><p>试用场景</p><ul><li>哈希连接只适用于 CBO，只能用于等值连接条件(即使是哈希反连接，Oracle 实际上也是将其转换成了等价的等值连接)。</li><li>当两个表作哈希连接时，如果在施加了目标 SQL 中指定谓词条件后得到的数据量较小的那个结果集所对应的 Hash Table 能够完全被容纳在内存中(PGA 的工作区)，则此时的哈希连接的执行效率会非常高。</li></ul><h3 id="笛卡尔积连接-Cross-Join"><a href="#笛卡尔积连接-Cross-Join" class="headerlink" title="笛卡尔积连接(Cross Join)"></a>笛卡尔积连接(Cross Join)</h3><pre><code>两个表在做表连接时没有任何连接条件的表连接方法。</code></pre><p>执行步骤</p><ol><li><p>首先以目标 SQL 中指定谓词条件访问表 1，得到结果集 1，记录数 m；</p></li><li><p>接着以目标 SQL 中指定谓词条件访问表 2，得到结果集 2，记录数 n；</p></li><li><p>最后对结果集 1 和结果集 2 执行合并操作，因为没有表连接条件，结果集 1 和结果集 2 连接时，结果集 1 中的任意一条记录匹配结果集 2 中的每一条记录，最终得到记录数 m*n 的结果集。</p></li></ol><blockquote><p>笛卡尔积的出现通常是由于目标 SQL 中漏写了表连接条件，笛卡尔积一般是不好的，有些情况下也可以利用笛卡尔积来减少对目标 SQL 中大表的全表扫描次数。</p></blockquote><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309181529407.png" alt="表连接执行计划对比"><br><img src="https://www.cdn.cheneyblog.com/blog/202309181556316.png" alt="让表连接提速的方法1"><br><img src="https://www.cdn.cheneyblog.com/blog/202309181557525.png" alt="让表连接提速的方法2"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之表相关执行计划</title>
      <link href="/posts/46535.html"/>
      <url>/posts/46535.html</url>
      
        <content type="html"><![CDATA[<h2 id="全表扫描（Full-Table-Scans-FTS）"><a href="#全表扫描（Full-Table-Scans-FTS）" class="headerlink" title="全表扫描（Full Table Scans, FTS）"></a>全表扫描（Full Table Scans, FTS）</h2><p>&emsp;&emsp;全表扫描是指 Oracle 在访问目标表里的数据时，会从该表所占用的第一个区（EXTENT）的第一个块（BLOCK）开始扫描，一直扫描到该表的高水位线（HWM,High Water Mark），这段范围内所有的数据块 Oracle 都必须读到。Oracle 会对这期间读到的所有数据施加目标 SQL 的 where 条件过滤，最后返回满足要求的数据。<br>&emsp;&emsp;Oracle 在做全表扫描操作时会使用多块读，在目标表数据量不大时执行效率是非常高的。全表扫描最大的问题是执行时间不稳定、不可控，会随着目标表数据量的递增而递增。<br>&emsp;&emsp;高水位线特性的副作用：即使 DELETE 删光了目标表里的所有数据，高水位线还是会在原来的位置，全表扫描的时候还是会扫描高水位线下所有的数据块。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151446539.png" alt="全表扫描（Full Table Scans, FTS）"></p><h3 id="会引起全表扫描的-SQL"><a href="#会引起全表扫描的-SQL" class="headerlink" title="会引起全表扫描的 SQL"></a>会引起全表扫描的 SQL</h3><ol><li>全模糊查询</li><li>查询条件中含有 is null</li><li>查询条件中使用了不等于操作符（&lt;&gt;、!=）</li><li>对于组合索引，如果查询条件中没有前导列，也会引起全表扫描</li><li>对字段进行表达式操作</li><li>返回的行无任何限定条件</li></ol><h2 id="ROWID-扫描（table-access-by-ROWID）"><a href="#ROWID-扫描（table-access-by-ROWID）" class="headerlink" title="ROWID 扫描（table access by ROWID）"></a>ROWID 扫描（table access by ROWID）</h2><p>&emsp;&emsp;ROWID 表示的是 Oracle 中数据行记录所在的物理存储位置，同数据块中的记录一一对应。Oracle 通过 ROWID 去定位并访问数据的方法叫 ROWID 扫描。</p><h3 id="ROWID-的两层含义"><a href="#ROWID-的两层含义" class="headerlink" title="ROWID 的两层含义"></a>ROWID 的两层含义</h3><ol><li><p>根据 SQL 语句中输入的 ROWID 值直接去访问对应的行记录<br><img src="https://www.cdn.cheneyblog.com/blog/202309151446582.png" alt="ROWID 值直接去访问对应的行记录"></p></li><li><p>通过访问相关索引，再根据索引得到的 ROWID 访问数据<br><img src="https://www.cdn.cheneyblog.com/blog/202309151447101.png" alt="根据索引得到的 ROWID 访问数据"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之优化器的模式</title>
      <link href="/posts/49498.html"/>
      <url>/posts/49498.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;优化器是 Oracle 的内置软件，可以确定执行目标 SQL 的最有效方式。优化器的模式决定 Oracle 解析目标 SQL 时所用优化器的类型，以及决定使用 CBO 时计算成本的侧重点。优化器的模式不同，CBO 计算成本值的方法也不同。控制 Oracle 优化器模式的参数为 optimizer_mode。</p><ul><li>查看参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> optimizer_mode</span><br></pre></td></tr></table></figure><ul><li>修改参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> optimizer_mode<span class="operator">=</span><span class="string">&#x27;CHOOSE&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="RULE"><a href="#RULE" class="headerlink" title="RULE"></a>RULE</h2><p>表示优化器采用 RBO 来解析目标 SQL。<br>是 Oracle 早期版本的一种优化模式。<br>目前 Oracle 已不再更新 RBO，也不推荐使用 RBO。</p><h2 id="CHOOSE"><a href="#CHOOSE" class="headerlink" title="CHOOSE"></a>CHOOSE</h2><p>由 RBO 到 CBO 转换时的默认值。<br>表示既可以使用 RBO 又可以使用 CBO。<br>取决于 SQL 涉及的对象是否有统计信息，有统计信息 CBO（部分有时会采样统计），否则 RBO。</p><h2 id="FIRST-ROWS-n-n-1-10-100-1000"><a href="#FIRST-ROWS-n-n-1-10-100-1000" class="headerlink" title="FIRST_ROWS_n(n=1,10,100,1000)"></a>FIRST_ROWS_n(n=1,10,100,1000)</h2><p>Oracle 采用 CBO 解析目标 SQL。<br>侧重点是最快的速度返回头 n 条记录。<br>本质上其实是 Oracle 把那些能够以最快相应速度返回头 n 条记录所对应的执行步骤的成本修改成一个很小的值（远远小于默认情况下 CBO 对同样执行步骤所计算的成本值）。</p><h2 id="FIRST-ROWS"><a href="#FIRST-ROWS" class="headerlink" title="FIRST_ROWS"></a>FIRST_ROWS</h2><p>Oracle 在解析目标 SQL 时会联合使用 CBO 和 RBO。<br>解析时采用 CBO，侧重点在于以最快的响应速度返回记录；<br>当出现一些特定的情况时，会用 RBO 中的一些内置规则来选取执行计划而不考虑成本。<br>例如用索引来避免排序</p><h2 id="ALL-ROWS"><a href="#ALL-ROWS" class="headerlink" title="ALL_ROWS"></a>ALL_ROWS</h2><p>Oracle 10G 及后续版本的默认值。<br>Oracle 用 CBO 解析目标 SQL，此时计算成本值时的侧重点在于最佳的吞吐量（即最小的系统 I/O 和 CPU 资源的消耗量）。<br>这种优化模式适合于数据查看实时性不是那么强的数据仓库、决策支持系统和面向批处理的数据库（batch-oriented databases）等。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之基于成本的优化器（CBO）</title>
      <link href="/posts/61.html"/>
      <url>/posts/61.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于代价的优化方式"><a href="#基于代价的优化方式" class="headerlink" title="基于代价的优化方式"></a>基于代价的优化方式</h2><p>&emsp;&emsp;Cost-Based Optimization，简称 CBO。CBO 选择目标 SQL 执行计划的判断原则是成本，从目标 SQL 的诸多执行计划中选取成本值最小的执行路径为其执行计划，各执行路径的成本值是根据目标 SQL 中涉及到的表、索引、列等相关对象的统计信息计算出来的，实际反应执行目标 SQL 所要消耗的 I/O、CPU 和网络资源的一个估计值。</p><ul><li>I/O<br>把数据从磁盘读入内存时所需代价(Select 重点指标)</li><li>CPU<br>处理内存中数据所需的代价（排序(sort)、连接(join)操作）</li><li>网络资源<br>网络资源是指那些用了 dblink 的分布式目标 SQL，CBO 在解析该类目标 SQL 时知道在实际执行时所需要的的数据并不在本地数据库中（需要远程数据库取数），便会将网络资源消耗折算成对等的 I/O 资源消耗再进行估算。</li><li>动态采样<br>执行 SQL 所涉及对象（表、索引等）没有被分析、统计过，Oracle 就会使用动态采样，动态的收集表和索引上的一些数据信息，但这些统计信息不会记录在视图中，只在硬解析时才会使用动态采样。</li></ul><h2 id="CBO-组成"><a href="#CBO-组成" class="headerlink" title="CBO 组成"></a>CBO 组成</h2><ul><li><p>查询转化器（Query Transformer）<br>查询转换器的作用就是等价改变查询语句的形式，以便产生更好的执行计划。<br>Oracle 转换技术：视图合并（View Merging）、谓词推进（Predicate Pushing）、非嵌套子查询（Subquery Unnesting）、物化视图的查询重写（Query Rewrite With Materialized Views）</p></li><li><p>代价评估器（Estimator）<br>评估器通过计算三个值来评估各个执行计划的总体成本：选择性（Selectivity）、集的势（Cardinality）、成本（Cost）</p><ol><li><p>选择性（Selectivity）：是指施加制定谓词条件后返回结果集的记录数占未施加任何谓词条件的原始结果集的记录数的比率。选择率的值越大，就意味着返回结果集的 Cardinality 值就越大，所以估算出来的成本值也就越大。</p><hr><p>   选择率的计算公式</p><pre><code>   目标列上没有直方图且没有NULL值的情况下，对目标列做等值查询时       Selectivity = 1 / NUM_DISTINCT       ※ NUM_DISTINCT表示目标列的distinct值的数量</code></pre><hr></li><li><p>集的势（Cardinality）：指集合所包含的记录数。实际上表示对目标 SQL 某个具体执行步骤的执行结果所包含记录数的估算。某个执行步骤的 Cardinality 值越大，那么它所对应的成本值也就越大，这个执行步骤所对应的执行路径总成本值也就越大。</p><hr><p>   CBO 估算 Cardinality 公式</p><pre><code>       Computed Cardinality = Original Cardinality * Selectivity       ※ Computed Cardinality:施加指定谓词条件后返回结果集的记录数       ※ Originad Cardinality:未施加任何谓词条件的原始结果集的记录数       ※ Selectivity:选择率</code></pre><hr></li></ol></li><li><p>计划生成器（Plan Generator）<br>计划生成器会考虑可能的访问路径（Access Path）、关联方法和关联顺序，生成不同的执行计划，让查询优化器从这些计划中选择出执行代价最小的一个计划。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151440141.png" alt="query Optimizer Components"></p></li></ul><h2 id="CBO-的局限性"><a href="#CBO-的局限性" class="headerlink" title="CBO 的局限性"></a>CBO 的局限性</h2><ol><li>CBO 会默认目标 SQL 语句 where 条件中出现的各列之间是独立的，没有关联关系</li><li>CBO 会假设所有的目标 SQL 都是单独执行的，并且互不干扰</li><li>CBO 对直方图统计信息有诸多限制</li><li>CBO 在解析多表关联的目标 SQL 时，可能会漏选正确的执行计划</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之基于规则的优化器（RBO）</title>
      <link href="/posts/65395.html"/>
      <url>/posts/65395.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;基于规则的优化器（RBO）是通过编码在 Oracle 数据库中的一系列固定的规则，来决定目标 SQL 的执行计划。Oracle 事先给各种类型的执行路径定一个等级，从 1 到 15，等级 1 对应执行路径的执行效率最高，等级 15 对应执行路径的执行效率最低。对于等级相同的执行计划，oracle 根据目标对象在数据字典中缓存的顺序判断选择哪一种执行计划。在决定目标 SQL 的执行计划时，RBO 会从该 SQL 的诸多执行路径中选择一条等级最低的执行路径来作为其执行计划。<br>&emsp;&emsp;RBO 中等级 1 对应的执行路径是“single row by rowid（通过 rowID 来访问单行数据）”，等级 15 所对应的执行路径时“full table scan（全表扫描）”。</p><h2 id="RBO-的缺陷"><a href="#RBO-的缺陷" class="headerlink" title="RBO 的缺陷"></a>RBO 的缺陷</h2><ul><li>RBO 的执行计划很难调整</li><li>目标 SQL 的写法及各个对象在该 SQL 文本中出现的先后顺序都会影响执行计划</li><li>Oracle 数据中的很多新特性、功能，均不支持 RBO</li><li>没有考虑目标 SQL 所涉及对象的实际数据量</li></ul><h2 id="RBO-执行计划的调整"><a href="#RBO-执行计划的调整" class="headerlink" title="RBO 执行计划的调整"></a>RBO 执行计划的调整</h2><ul><li><p>等价改写 SQL</p><p>Number 或 Date 类型的字段加上 0,Varchar 类型拼接上空字符’’,使本来走索引的现在不走索引，对于多表连接的改变 form 后表的先后顺序可以影响表连接顺序</p></li><li><p>如果出现多条等级值相同的执行路径，改变目标 SQL 中涉及相关对象数据字典缓存（Data Dictionary Cache）的缓存顺序</p></li><li><p>如果出现多条等级值相同的执行路径，改变目标 SQL 中涉及相关对象在 SQL 文本中出现的先后顺序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之位图索引</title>
      <link href="/posts/35895.html"/>
      <url>/posts/35895.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;目前一般我们使用的索引都是 B-Tree 索引，索引结构中存储的是键值和对应 ROWID。位图索引是指用位图表示的索引，通常创建在有大量重复值的列上，针对每个键值建立不同的位图。索引结构中主要存储键值、起止 ROWID 和位置编码，位置编码中的每一位表示键值对应数据行的有无，一个块可能指向多行数据的位置。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151427035.jpg" alt="位图索引结果图"></p><ul><li>位图索引通过位图向量，表示索引键值在表中的分布</li><li>存在大量更新操作的列上不宜建位图索引，因为更新向量时相应键值涉及到的数据行都将被锁定</li></ul><h2 id="与-B-Tree-索引的区别"><a href="#与-B-Tree-索引的区别" class="headerlink" title="与 B-Tree 索引的区别"></a>与 B-Tree 索引的区别</h2><ol><li>位图索引一个键值对应一个叶子节点，B-Tree 索引一个叶子节点包含多个索引键值</li><li>位图索引使用位图向量标识键值对应数据行的分布，B-Tree 采用 Row_id 定位数据行</li><li>位图索引创建不需要排序，B-Tree 索引需要排序</li><li>位图索引允许键值为 Null，B-Tree 索引对 Null 值敏感</li><li>位图索引可以进行位运算（and、or）</li></ol><h2 id="位图索引优缺点"><a href="#位图索引优缺点" class="headerlink" title="位图索引优缺点"></a>位图索引优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>位图索引由于只存储键值的起止 Rowid 和位图,占用的空间非常少.</li><li>位图索引创建时不需要排序，创建速度快</li><li>位图索引对 Null 值不敏感</li><li>位图运算使相应查询更快</li><li>可以通过位图索引直接计数。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不适合选择度底的列</li><li>频繁的 DML 可能会导致性能问题，更新索引会产生行锁（可能锁定多行）</li><li>可能会溢出，索引数据块难于放下整个索引值，这导致低效。</li></ul><h2 id="位图索引相关执行计划"><a href="#位图索引相关执行计划" class="headerlink" title="位图索引相关执行计划"></a>位图索引相关执行计划</h2><ul><li>位图索引单键值扫描（BITMAP INDEX SINGLE VALUE）</li><li>位图索引范围扫描（BITMAP INDEX RANGE SCAN）</li><li>位图索引全扫描（BITMAP INDEX FULL SCAN）</li><li>位图索引快速全扫描（BITMAP INDEX FAST FULL SCAN）</li><li>位图按位与（BITMAP AND）</li><li>位图按位或（BITMAP OR）</li><li>位图按位减（BITMAP MINUS）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之 B-Tree 索引</title>
      <link href="/posts/26997.html"/>
      <url>/posts/26997.html</url>
      
        <content type="html"><![CDATA[<h2 id="B-Tree-索引内部结构"><a href="#B-Tree-索引内部结构" class="headerlink" title="B-Tree 索引内部结构"></a>B-Tree 索引内部结构</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309151423469.png" alt="B-Tree 索引内部结构"></p><p>&emsp;&emsp;B-Tree 是一种常见的数据结构，可以显著减少定位记录时所经历的中间过程，从而加快存取速度，主要用于 OLTP 系统（事务系统）。B-Tree 索引包含的主要组件如下：</p><ol><li>根节点（Root Node）：一个 B-Tree 索引只有一个根节点，它实际就是位于树的最顶端的分支节点。</li><li>分支节点（Branch Node）：包含指向相应索引分支块或叶子块的指针和索引键值列。</li><li>叶子节点（Leaf Node）：包含被索引键值和该键值对应的 ROWID</li><li>索引项（Index Entry）：对应每一条行记录</li></ol><h2 id="分支节点（Branch-Node）"><a href="#分支节点（Branch-Node）" class="headerlink" title="分支节点（Branch Node）"></a>分支节点（Branch Node）</h2><p>&emsp;&emsp;分支节点主要包括两部分：指针和索引键值列。</p><ul><li>指针<br>指针是指相关分支块或叶子块的块地址 RDBA。每个分支块都会有两种类型的指针，一种是 LMC（Left Most Child），比当前节点中最小的索引值还小的下一级节点块的数据块地址；另外一种是索引行记录指针即下一级节点块地址，该指针指向块的索引键值列最小值一定大于或等于该行记录的索引键值</li><li>索引键值列<br>索引键值列只要 Oracle 能区分相应的索引分支块或叶子块就行，这样既节省空间又可以快速定位下层的分支块或叶子块。</li></ul><h2 id="叶子节点（Leaf-Node）"><a href="#叶子节点（Leaf-Node）" class="headerlink" title="叶子节点（Leaf Node）"></a>叶子节点（Leaf Node）</h2><p>&emsp;&emsp;索引叶子节点也有两个指针，分别指向比当前节点最小索引值还小的叶节点块的地址，以及比当前节点最大索引值还大的叶节点块地址。通过这两个指针，把所有的叶节点串起来，形成一个双向链表。顺序遍历这个链表即可得到有序的数据。<br><strong>拓展</strong><br>唯一 B-Tree 索引，ROWID 存储在索引行的行头，Oracle 不存储该 ROWID 的长度，非唯一 B-Tree 索引则都需要存储。</p><h2 id="B-Tree-索引优势"><a href="#B-Tree-索引优势" class="headerlink" title="B-Tree 索引优势"></a>B-Tree 索引优势</h2><ul><li>所有索引叶子块在同一层，访问每一个键值的时间相同</li><li>通过索引访问数据的时间是可控的、基本稳定</li><li>B-Tree 索引自动保持平衡</li><li>不会随着表数据量的增长而性能下降。</li></ul><p><strong>特别提醒</strong><br>通过 B-Tree 索引访问数据的过程是先访问相关的 B-Tree 索引，然后再根据 ROWID 访问相应的行记录。<br>相应的会产生两部分消耗，一部分是访问索引的成本，另一部分是回表的成本。</p><h2 id="访问-B-Tree-索引的方法"><a href="#访问-B-Tree-索引的方法" class="headerlink" title="访问 B-Tree 索引的方法"></a>访问 B-Tree 索引的方法</h2><h3 id="索引唯一扫描（INDEX-UNIQUE-SCAN）"><a href="#索引唯一扫描（INDEX-UNIQUE-SCAN）" class="headerlink" title="索引唯一扫描（INDEX UNIQUE SCAN）"></a>索引唯一扫描（INDEX UNIQUE SCAN）</h3><p>WHERE 条件里是等值查询，扫描结果最多一条记录</p><h3 id="索引范围扫描（INDEX-RANGE-SCAN）"><a href="#索引范围扫描（INDEX-RANGE-SCAN）" class="headerlink" title="索引范围扫描（INDEX RANGE SCAN）"></a>索引范围扫描（INDEX RANGE SCAN）</h3><p>WHERE 条件为范围查询，扫描结果可能返回多条记录。<br>同等条件下，当目标索引的索引行数量大于 1 时，索引范围扫描所消耗的逻辑读至少会比相应的索引唯一扫描的逻辑读多 1 因为范围扫描会扫描多个叶子块。</p><h3 id="索引全扫描（INDEX-FULL-SCAN）"><a href="#索引全扫描（INDEX-FULL-SCAN）" class="headerlink" title="索引全扫描（INDEX FULL SCAN）"></a>索引全扫描（INDEX FULL SCAN）</h3><p>索引全扫描要从左至右依次顺序扫描目标索引所有叶子块的所有索引行，而索引是有序的，所以索引全扫描的执行结果也是有序的，并且是按照该索引的索引键值列来排序，这也意味着走索引全扫描能够既达到排序的效果，又同时避免了对该索引的索引键值列的真正排序操作。</p><p><strong><em>NULL 值不会在 B 树索引中存在，这意味着 Oracle 中能做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是 NOT NULL</em></strong></p><h3 id="索引快速全扫描（INDEX-FAST-FULL-SCAN）"><a href="#索引快速全扫描（INDEX-FAST-FULL-SCAN）" class="headerlink" title="索引快速全扫描（INDEX FAST FULL SCAN）"></a>索引快速全扫描（INDEX FAST FULL SCAN）</h3><p>从段头开始，读取包含位图块，root block, 所有的 branch block, leaf block，读取的顺序完全由物理存储位置决定，并采取多块读，每次读取 db_file_multiblock_read_count 个。</p><h4 id="索引快速全扫描与索引全扫描的区别"><a href="#索引快速全扫描与索引全扫描的区别" class="headerlink" title="索引快速全扫描与索引全扫描的区别"></a>索引快速全扫描与索引全扫描的区别</h4><ol><li>索引快速全扫描只适用于 CBO</li><li>索引快速全扫描可以使用多块读，也可以并行执行</li><li>索引快速全扫描的执行结果不一定是有序的</li><li>索引快速全扫描是根据索引行在磁盘上的物理存储顺序来扫描<br>索引全扫描时按照逻辑顺序从左至右依次扫描<br>对于单个索引叶子块中的索引行而言，其物理存储顺序和逻辑存储顺序一致;但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序则不一定在逻辑上有序</li></ol><h3 id="索引跳跃式扫描（INDEX-SKIP-SCAN）"><a href="#索引跳跃式扫描（INDEX-SKIP-SCAN）" class="headerlink" title="索引跳跃式扫描（INDEX SKIP SCAN）"></a>索引跳跃式扫描（INDEX SKIP SCAN）</h3><p>索引跳跃式扫描使那些在 where 条件中没有对目标索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标 SQL 依然可以用上该索引。Oracle 会对该索引的前导列的所有 distinct 值做遍历，然后对原目标 SQL 做等价改写，将目标列的所有前导列的 distinct 值加进来。</p><p>Oracle 中的索引跳跃式扫描仅仅适用于那些目标索引前导列的 distinct 值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会随着目标索引前导列的 distinct 值数量的递增而递减。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之索引介绍</title>
      <link href="/posts/9739.html"/>
      <url>/posts/9739.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;索引是建立在表上的可选数据库对象，是一组排序后的的索引键。主要用于加快数据的检索，类似于书籍的目录，快速定位到目标数据。索引在物理上和逻辑上都是独立的，创建或删除索引对基表不会有影响。当对基表进行 DML 操作时 Oracle 会自动管理索引，无需手动处理。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>分区索引</li></ul><p>索引按范围（Range）或散列（Hash，Oracle 10g中引入）进行分区<br>一个分区索引可能指向任何（或全部的）表分区。</p><ul><li>B-Tree 索引</li></ul><p>B-Tree索引是一个典型的树结构，通常包含根节点、分支节点、叶子节点<br>包括正常索引或反转关键字索引</p><ul><li>位图索引</li></ul><p>位图索引主要针对大量相同值的列而创建<br>位图索引不直接存储ROWID，而是存储字节位到ROWID的映射<br>位图索引的空间占用明显小于B-Tree索引<br>位图索引不适合经常更新的表<br>关键字BitMap</p><h3 id="逻辑分类"><a href="#逻辑分类" class="headerlink" title="逻辑分类"></a>逻辑分类</h3><ul><li>单列索引</li></ul><p>索引列为单个字段</p><ul><li>组合索引</li></ul><p>索引列为多个字段，最多为32列，顺序自定义</p><ul><li>唯一索引</li></ul><p>索引列的值唯一，Oracle会自动在表的主键列上创建唯一索引，关键字UNIQUE INDEX</p><ul><li>非唯一索引</li></ul><p>索引列的值允许重复</p><ul><li>函数索引</li></ul><p>一列或多列上的基于函数表达式所创建的索引<br>表达式不能出现聚合函数<br>不能在LOB类型的列上创建<br>创建时必须具有 QUERY REWRITE 权限</p><ul><li>反向键索引</li></ul><p>反向键索引反转索引列键值的每个字节，实现索引的均匀分配<br>通常建立在值是连续增长的列上，使数据均匀地分布在整个索引上<br>关键字REVERSE</p><h2 id="创建索引原则"><a href="#创建索引原则" class="headerlink" title="创建索引原则"></a>创建索引原则</h2><ul><li>权衡索引个数与 DML 之间关系</li></ul><p>建立索引的目的是为了提高查询效率的<br>但建立的索引过多，会影响插入、删除数据的速度</p><ul><li>尽量将表和索引放在不同的表空间</li></ul><p>在读取数据时表与索引是同时进行的。<br>表与索引在一个表空间里就会产生资源竞争，放在不同的表空间最佳。</p><ul><li>创建索引会产生 Redo 信息和占用磁盘空间</li></ul><p>索引是数据库对象之一，需要分配磁盘空间去存储。<br>创建索引会产生Redo信息，对于大表创建索引时可以设置不产生日志信息。</p><ul><li>创建索引需根据具体的业务 SQL</li></ul><p>Oracle根据具体的情况判断是否走索引。<br>索引建在Where限制条件、表连接、需排序字段上。</p><ul><li>唯一索引优先</li></ul><p>如果同时存在唯一性索引和非唯一索引，oracle将使用唯一性索引而忽略非唯一索引</p><ul><li>经常用的字段放组合索引第一列</li></ul><p>组合索引只有它的第一列被where子句引用时，优化器才会使用该索引</p><ul><li>限制表中索引的数量</li></ul><p>索引会占用物理空间，会随基表数据量的增大而增大；<br>当对表中的数据进行DML时，索引也要动态的维护，降低了数据的维护速度</p><ul><li><p>小表不要建索引</p></li><li><p>对于基数大的列适合建立 B 树索引，对于基数小的列适合建立位图索引</p></li><li><p>列中有很多空值，但经常查询该列上非空记录时应该建立索引</p></li><li><p>LONG（可变长字符串数据，最长 2G）和 LONG RAW（可变长二进制数据，最长 2G）列不能创建索引</p></li></ul><h2 id="索引可选项"><a href="#索引可选项" class="headerlink" title="索引可选项"></a>索引可选项</h2><ul><li>NOSORT</li></ul><p>建立索引时会先对表记录排序再建立索引，当表数据量较多是会占用较多的时间。<br>特殊情况下，我们就可以使用该参数加快建索引的速度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) NOSORT;</span><br></pre></td></tr></table></figure><ul><li>ONLINE</li></ul><p>数据库系统默认是不允许 DML 与创建索引同时进行的，ONLINE 选项可以避免此类问题，但会延长建索引时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) ONLINE;</span><br></pre></td></tr></table></figure><ul><li>NOLOGGING</li></ul><p>是否需要记录日志信息，一般用在在大型表上建索引，使用该参数，默认是记日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) NOLOGGING;</span><br></pre></td></tr></table></figure><ul><li>COMPUTE STATISTICS</li></ul><p>该参数会提示数据库建索引的同时，更新对应的统计信息。<br>当数据修改量比较大的情况下，使用该选项有可能导致执行计划的不稳定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) COMPUTE STATISTICS;</span><br></pre></td></tr></table></figure><ul><li>PARALLEL</li></ul><p>增加并发，多服务进程创建索引,通常针对大表建索引使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="comment">/*+ PARALLEL(2)*/</span> INDEX IDX_EMP_ENAME <span class="keyword">ON</span> EMP (ENAME);</span><br></pre></td></tr></table></figure><h2 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h2><ol><li><p>Where 条件有不等于操作符(&lt;&gt;, !=)</p></li><li><p>限定条件中有对空值的判断（Null 或 Not Null）</p></li><li><p>非函数索引，Where 条件中对索引列使用了函数</p></li><li><p>不匹配的索引数据类型</p></li><li><p>全模糊查询（’like ‘%aa’）</p></li><li><p>Union 替换 Or</p></li><li><p>用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN</p></li></ol><h2 id="索引相关视图"><a href="#索引相关视图" class="headerlink" title="索引相关视图"></a>索引相关视图</h2><table><thead><tr><th>视图</th><th>说明</th></tr></thead><tbody><tr><td>dba_indexes all_indexes user_indexes</td><td>这类视图显示索引的基本信息，如索引名称、索引是否压缩存储、索引段的存储等信息以及使用 dbms_stats 包或 analyze 语句生成的统计信息</td></tr><tr><td>dba_ind_columns all_ind_columns user_ind_columns</td><td>这类视图显示了被索引列的信息</td></tr><tr><td>dba_ind_expressions all_ind_expresions user_ind_expressions</td><td>这类视图显示函数索引的函数语句</td></tr><tr><td>dba_ind_statistics all_ind_statistics user_ind_statistics</td><td>这类视图显示对索引的优化统计信息</td></tr><tr><td>index_stats index_histogram</td><td>显示最近一次使用 analyze index… validate structure 语句生成的统计信息</td></tr><tr><td>v$object_usage</td><td>存储由 alter index … monitoring usage 语句生成的索引使用信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Oracle数据库的综合体系结构与各组成部分的作用</title>
      <link href="/posts/47150.html"/>
      <url>/posts/47150.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>Oracle数据库作为一款强大的关系型数据库管理系统，具有复杂而完善的综合体系结构。这个体系结构由物理结构、内存结构、进程结构和逻辑结构组成，它们相互协作，共同为数据库提供高效的数据存储、管理和访问。本文将深入解析Oracle数据库的综合体系结构，探讨各组成部分之间的联系以及它们对数据库的影响与作用。</p></div><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构是指数据库在磁盘上的存储方式和组织形式。它涉及到数据文件、数据块、操作系统文件系统等层面的存储结构。物理结构的设计和调优对于数据库的性能和性能是至关重要的，它直接影响着数据的读取和写入速度，以及数据库的可靠性和可用性。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>内存结构是指Oracle数据库在内存中分配和管理的存储区域。它包括了共享池、数据库缓存、重做日志缓冲区等重要的内存组件。内存结构的设计和配置对于数据库的性能优化和响应速度具有重要影响。合理配置内存结构可以降低磁盘IO操作的频率，提升数据检索和事务处理的效率。</p><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>进程结构是指Oracle数据库的进程组成和协作方式。它包括了实例进程、后台进程和用户进程等多个进程。不同的进程负责着不同的任务和功能，它们相互配合，保证数据库实例的正常运行和对外服务的可用性。</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是指数据库中数据的组织方式和访问方法，如表空间、段、区和数据文件等。它决定了数据在数据库中的存储和访问方式。逻辑结构的设计和管理对于数据的安全性、一致性和有效性具有重要影响。有效的逻辑结构设计可以提高数据的查询效率和管理灵活性。</p><h2 id="各组成部分的联系与作用"><a href="#各组成部分的联系与作用" class="headerlink" title="各组成部分的联系与作用"></a>各组成部分的联系与作用</h2><p>这四个组成部分在Oracle数据库中密切联系，相互协作，共同为数据库的运行和管理提供支持。具体来说：</p><ul><li>物理结构和内存结构之间的联系：物理结构决定了数据在磁盘上的存储方式和布局，而内存结构则管理了数据在内存中的缓存和访问。它们之间的协作可以通过减少磁盘IO操作，加快数据的读取和写入速度，提升数据库的性能。</li><li>内存结构和进程结构之间的联系：内存结构中的共享池和数据库缓存等组件被进程共享和访问，进程通过内存结构来读取和处理数据。内存结构的优化和配置可以提升进程的查询和事务处理效率，从而加快数据库的响应速度。</li><li>进程结构和逻辑结构之间的联系：进程通过逻辑结构访问和操纵数据库中的数据，如表空间、段和区等。进程的操作和管理需要依赖于逻辑结构的定义和存在。逻辑结构的设计和管理直接影响着进程的执行和数据的操作。</li></ul><div class="note info simple"><p>综合体系结构是Oracle数据库运行和管理的基石，物理结构、内存结构、进程结构和逻辑结构相互联系、相互作用，为数据库提供了高效的存储、访问和管理能力。深入理解和综合运用各组成部分的知识和技术，可以帮助数据库管理员和开发人员更好地设计、调优和管理Oracle数据库，提升数据库的性能、可靠性和可用性，为企业提供卓越的数据库服务。希望本文的介绍对您理解Oracle数据库的综合体系结构和各组成部分的作用起到了指导和启发的作用。</p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的逻辑结构与数据组织方式</title>
      <link href="/posts/24947.html"/>
      <url>/posts/24947.html</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑结构图"><a href="#逻辑结构图" class="headerlink" title="逻辑结构图"></a>逻辑结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141411597.png" alt="Oracle逻辑结构图"></p><h2 id="表空间（Tablespace）"><a href="#表空间（Tablespace）" class="headerlink" title="表空间（Tablespace）"></a>表空间（Tablespace）</h2><p>表空间是 Oracle 最大的逻辑存储结构，与物理上的数据文件相对应，但是一个表空间可以拥有多个数据文件。</p><ul><li>数据表空间<br>用于存储用户数据的普通表空间。</li><li>系统表空间<br>默认的表空间，用于保存数据字典（一组保存数据库自身信息的内部系统表和视图，及用于 Oracle 内部使用的其他一些对象），保存所有的 PL/SQL 程序的源代码和解析代码，包括存储过程和函数、包、数据库触发器等，保存数据库对象（表、视图、序列）的定义。</li><li>回滚表空间<br>用于存放回滚段,每个实例最多只能使用一个撤销表空间</li><li>临时表空间<br>存储 SQL 执行过程中产生的临时数据</li></ul><h2 id="段（Segment）"><a href="#段（Segment）" class="headerlink" title="段（Segment）"></a>段（Segment）</h2><p>段是一组盘区，它是一个独立的逻辑存储结构，用于存储具有独立存储结构对象的全部数据。段一般是数据库终端用户处理最小的存储单位，当段的数据区已满，Oracle 为其分配另一个数据区，段的数据区在磁盘上可能是不连续的。</p><ul><li>数据段<br>用来存储表中所有数据；</li><li>索引段<br>用来存储表中索引的所有数据；</li><li>临时段<br>用于存储表排序或汇总时产生的临时数据</li><li>LOB 段<br>LOB 用来存储表中大型数据对象，例如 CLOB 与 BLOB</li><li>回退段<br>用于存储用户数据被修改之前的位置和值；<br>当要对用户的数据进行回退操作时，就要使用回退段。</li></ul><h2 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h2><p>区是 Oracle 存储分配的最小单位，它是由一个或多个数据块组成的。一个或多个区组成一个段，也就是说段的大小都是由区的个数来决定。当一个段的空间使用完之后，Oracle 会自动为该段分配成一个新的区。</p><p>用户还能够通过执行下面的命令来回收表、索引等对象中未使用的区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">deallocate</span> unused;</span><br></pre></td></tr></table></figure><h2 id="块（Block）"><a href="#块（Block）" class="headerlink" title="块（Block）"></a>块（Block）</h2><p>块是用来管理存储空间的最基本的单位，也是最小的逻辑存储单位。块的大小由初始化参数 db_block_size 来决定，不同的 Oracle 版本的大小是不同的，但是数据库一旦创建，其大小便不可更改。虽然每个数据块可以存储不同类型的数据，但是每个数据块都具有一个相同的结构。<br><img src="https://www.cdn.cheneyblog.com/blog/202309141412149.png" alt="块结构"></p><ul><li>块头<br>包含了该数据块一般的属性信息，如数据块的物理地址、所属段类型等</li><li>表目录<br>如果数据块中存储的数据是某个表的数据，则这里存放该表的信息</li><li>行目录<br>用来存储数据块中有效的行信息</li><li>空余空间<br>指数据块还没有使用的存储空间</li><li>行空间<br>表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的进程结构</title>
      <link href="/posts/35730.html"/>
      <url>/posts/35730.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-进程结构图"><a href="#Oracle-进程结构图" class="headerlink" title="Oracle 进程结构图"></a>Oracle 进程结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141407701.png" alt="Oracle 进程结构图"></p><h2 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h2><p>&emsp;&emsp;用户进程是一个与 Oracle 服务器进行交互的程序。一般的客户端软件，像 Oracle 的 sqlplus，sql developer,或者是一些驱动程序等等向数据库发送请求时即创建了用户进程。</p><h2 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h2><p>&emsp;&emsp;当监听程序监听到客户端来了一个请求，在创建会话时便会为其分配一个对应的服务器进程。服务器进程的主要作用就是处理连接到当前实例的用户进程的请求，对客户端发来的 sql 进行执行并返回执行结果。</p><h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>后台进程是 Oracle 数据库为了保持最佳系统性能和协调多个用户请求而设置的一系列后台进程。</p><h3 id="进程监控（PMON）"><a href="#进程监控（PMON）" class="headerlink" title="进程监控（PMON）"></a>进程监控（PMON）</h3><p>对故障的进程执行恢复操作，负责清理内存存储区和释放该进程所使用的资源<br>周期的检查调度进程和服务器进程的状态，对已死的进程进行重启</p><h3 id="系统监控（SMON）"><a href="#系统监控（SMON）" class="headerlink" title="系统监控（SMON）"></a>系统监控（SMON）</h3><p>当数据库实例出现故障或者系统崩溃的时候，执行恢复操作<br>定期合并字典管理的表空间中的空闲空间<br>在系统重启期间，清理表空间所有临时段<br>安装和打开数据库</p><h3 id="数据写入（DBWn）"><a href="#数据写入（DBWn）" class="headerlink" title="数据写入（DBWn）"></a>数据写入（DBWn）</h3><p>负责的将更新完的缓冲区数据写入磁盘中。以下情况发生时执行：</p><ul><li>没有可以写入的缓存空间</li><li>脏缓存达到限制（会导致搜索时间过长）1/4 满</li><li>最晚三秒钟：最晚三秒会执行一次写入</li><li>遇到检查点：遇到这个 checkpoint 便会执行写程序</li><li>表空间热备份的时候</li><li>表空间离线、只读状态</li><li>执行 Drop 操作的时候</li></ul><h3 id="日志写入（LGWR）"><a href="#日志写入（LGWR）" class="headerlink" title="日志写入（LGWR）"></a>日志写入（LGWR）</h3><p>将日志缓冲区的脏数据写进磁盘中 以下情况发生时执行：</p><ul><li>commit 写入</li><li>日志缓冲区占用率 1/3</li><li>DBWn 要写入脏缓冲区前</li></ul><h3 id="检查点进程（CKPT）"><a href="#检查点进程（CKPT）" class="headerlink" title="检查点进程（CKPT）"></a>检查点进程（CKPT）</h3><p>负责发起检查点信号，让 DBWn 开始工作<br>更新控制文件以及数据文件头</p><h3 id="归档进程（ACRn）"><a href="#归档进程（ACRn）" class="headerlink" title="归档进程（ACRn）"></a>归档进程（ACRn）</h3><p>将日志文件复制到归档日志文件中，来避免日志文件组的循环使用覆盖到已有的日志文件。<br>只有当数据库在 ARCHIVELOG 模式下，且自动归档开启的时候，系统便会启动 ARCn 进程；ARCn 包括归档方式和非归档方式。</p><h3 id="恢复器进程-RECO"><a href="#恢复器进程-RECO" class="headerlink" title="恢复器进程(RECO)"></a>恢复器进程(RECO)</h3><p>是一个用于分布式数据库配置的后台进程，它可以自动解决涉及分布式事务处理的故障。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的内存结构</title>
      <link href="/posts/14901.html"/>
      <url>/posts/14901.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-内存结构图"><a href="#Oracle-内存结构图" class="headerlink" title="Oracle 内存结构图"></a>Oracle 内存结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111341.png" alt="Oracle 内存结构图"></p><h2 id="System-Global-Aera-（SGA）"><a href="#System-Global-Aera-（SGA）" class="headerlink" title="System Global Aera （SGA）"></a>System Global Aera （SGA）</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111776.png" alt="SGA"></p><p>V$SGASTAT 视图提供有关 SGA 更详细的内存分配信息。</p><p>V$SGA 视图给出了系统全局区(System Global Area，SGA)内存结构的摘要信息。</p><h3 id="数据库缓存区（Database-Buffer-Cache）"><a href="#数据库缓存区（Database-Buffer-Cache）" class="headerlink" title="数据库缓存区（Database Buffer Cache）"></a>数据库缓存区（Database Buffer Cache）</h3><p>&emsp;&emsp;用于缓存当前或最近使用的从磁盘读取的数据块的拷贝，来优化数据库的 I/O 减少物理读/写。Oralce 依据 LRU 算法对该内存区域进行 block-level 的更新。数据高速缓存块又由以下几个缓存块组成：</p><ul><li>脏缓存块（Dirty buffers）<br>保存被修改过并且 commit 但未写入磁盘数据的缓存块，脏缓存块最终被 DBWn 进程写入到硬盘的数据文件中永久保存。</li><li>命中缓存块（Pinned buffers）<br>保存最近正在被访问的缓存块，始终被保留在数据高速缓存中，不会被写入数据文件。</li><li>空闲缓存块（Free buffers）<br>该缓存块中没有数据，等待被写入数据。oracle 从数据文件中读取数据后，寻找空闲缓存块，以便写入其中。</li></ul><h3 id="日志缓冲区（Redo-Log-Buffer）"><a href="#日志缓冲区（Redo-Log-Buffer）" class="headerlink" title="日志缓冲区（Redo Log Buffer）"></a>日志缓冲区（Redo Log Buffer）</h3><p>&emsp;&emsp;日志缓冲区是一块比较小的内存区域，它是用来短期存储将写入到磁盘中的重做日志信息。日志缓冲区也是为了减少磁盘 IO，减少用户的等待时间。</p><h3 id="共享池（Shared-Pool）"><a href="#共享池（Shared-Pool）" class="headerlink" title="共享池（Shared Pool）"></a>共享池（Shared Pool）</h3><ul><li><p>数据字典缓存区（Data Dictionary Cache）<br>用于存放 SQL 语句相关的数据文件、表、索引、列、用户、其他的数据对象的定义和权限信息等。</p></li><li><p>库缓存区（Librabry Cache）<br>共享 SQL 和 PL/SQL 代码。服务器进程在执行语句时，首先会匹配库缓存，如果存在相同语句则无需编译直接使用已编译的执行计划。<br>绑定变量不是在编译阶段赋值的，而是在运行阶段赋值的，因此含有绑定变量的 SQL 语句可以不用重新编译。</p></li><li><p>SQL 和 PL/SQL 结果缓存（Server Result Cache）<br>用于存储 SQL 查询或 PL/SQL 函数的结果，以加快其将来的执行速度。</p></li></ul><h3 id="大池（Large-Pool）"><a href="#大池（Large-Pool）" class="headerlink" title="大池（Large Pool）"></a>大池（Large Pool）</h3><p>&emsp;&emsp;大池是个可选的内存区域，可提供一个大的缓冲区供数据库的备份与恢复操作过程使用。数据库的备份恢复、执行具有大量排序操作的 SQL 语句、并行化的数据库操作时可能需要用到大池。</p><h3 id="Java-池（Java-Pool）"><a href="#Java-池（Java-Pool）" class="headerlink" title="Java 池（Java Pool）"></a>Java 池（Java Pool）</h3><p>&emsp;&emsp;JAVA 池在数据库中支持 JAVA 的运行，存放 JAVA 代码和 JAVA 语句的语法分析表。</p><h3 id="流池（Stream-Pool）"><a href="#流池（Stream-Pool）" class="headerlink" title="流池（Stream Pool）"></a>流池（Stream Pool）</h3><p>&emsp;&emsp;用于缓存流进程在数据库间移动/复制数据时使用的队列消息。一般从重做日志中提取变更记录的进程和应用变更记录的进程会用到流池。</p><h2 id="Program-Global-Aera-（PGA）"><a href="#Program-Global-Aera-（PGA）" class="headerlink" title="Program Global Aera （PGA）"></a>Program Global Aera （PGA）</h2><p>&emsp;&emsp;PGA 是指单个服务器进程或者单个后台进程所需的数据和控制信息。PGA 是在用户进程连接到数据库并创建一个会话时自动分配。该区域内保留每个与 oracle 数据库连接的用户进程所需的内存，当一个用户会话结束，PAG 就会释放。</p><ol><li>Private SQL area：包含绑定信息、运行时的内存结构。每个发出 sql 语句的会话，都有一个 private SQL area（私有 SQL 区）<br><strong>专有服务器连接私有 SQL 区在 PGA 中，共享服务器连接私有 SQL 区在 SGA 中。</strong></li><li>Session memory：为保存会话中的变量以及其他与会话相关的信息，而分配的内存区。</li></ol><ul><li>排序区<br>当用户需要对数据进行排序时，系统会将需要排序的数据保存到 PGA 中的排序区内，然后在这个排序区内对这些数据进行排序。如果发现用户的很多操作都需要用到排序，那么为用户设置比较大的排序区，可以提高用户访问数据的效率。</li><li>会话区<br>会话区保存了会话所具有的权限、角色、性能统计等信息，通常都是由数据库系统自我维护。</li><li>堆栈区<br>保存着绑定变量、会话变量、SQL 语句运行时的内存结构等重要的信息，通常都是由数据库系统自我维护</li><li>游标区<br>游标区是一个动态的区域，当用户执行游标语句打开游标时，系统会在 PGA 中创建游标区，当关闭游标时，这个区域就会被释放。创建与释放需要占用一定的系统资源，花费一定的时间，如果频繁的打开和关闭游标，就会降低语句的执行性能。</li></ul><h2 id="User-Global-Aera-（UGA）"><a href="#User-Global-Aera-（UGA）" class="headerlink" title="User Global Aera （UGA）"></a>User Global Aera （UGA）</h2><p>&emsp;&emsp;为用户进程存储会话状态。UGA 可以作为 SGA 或者 PGA 的一部分，如果通过一个共享服务器连接，UGA 包含在 SAG 中；如果通过一个专有服务器连接，UGA 就包含在专有服务器的 PGA 中。</p><h2 id="Software-code-areas"><a href="#Software-code-areas" class="headerlink" title="Software code areas"></a>Software code areas</h2><p>&emsp;&emsp;Oracle 存放自身软件代码的一部分内存区，不允许其他会话访问。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的物理结构：文件组织与作用详解</title>
      <link href="/posts/565.html"/>
      <url>/posts/565.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在Oracle数据库中，物理结构是数据库存储的基础，各种文件扮演着重要的角色。本文将为您深入介绍Oracle数据库的物理结构，特别是不同类型的文件以及它们的作用。我们将逐步介绍数据文件、控制文件、重做日志文件和参数文件，并详细解释这些文件在Oracle数据库中的重要性和功能。让我们一起来了解Oracle数据库中的物理结构与文件组织吧！</p></div><h2 id="数据文件（Data-file）"><a href="#数据文件（Data-file）" class="headerlink" title="数据文件（Data file）"></a>数据文件（Data file）</h2><p>数据文件是Oracle数据库中存储实际数据的文件。每个表空间在磁盘上都有一个或多个关联的数据文件，它们保存了表和索引的物理数据。数据文件的扩展名为.dbf。数据文件是Oracle数据库的核心组成部分。</p><h3 id="数据文件特性"><a href="#数据文件特性" class="headerlink" title="数据文件特性"></a>数据文件特性</h3><ol><li>每个数据文件对应一个数据库，一个数据库可以对应多个数据文件</li><li>数据文件可以自动扩展</li><li>数据文件专属于一个表空间，一个表空间可以拥有多个数据文件。</li></ol><h2 id="控制文件（Control-file）"><a href="#控制文件（Control-file）" class="headerlink" title="控制文件（Control file）"></a>控制文件（Control file）</h2><p>控制文件是Oracle数据库的重要组成部分，用于跟踪数据库的结构和状态。它记录了数据库的结构信息，包括数据文件、日志文件和数据库参数的位置和状态信息。控制文件还包含数据库的日志序列号，用于恢复和故障恢复。通常情况下，一个数据库有一个主控制文件和多个备用控制文件。</p><h2 id="重做日志文件（Redo-log-file）"><a href="#重做日志文件（Redo-log-file）" class="headerlink" title="重做日志文件（Redo log file）"></a>重做日志文件（Redo log file）</h2><p>重做日志文件（也称为事务日志文件）是用于保护数据库事务完整性和恢复的关键组件。重做日志文件记录了对数据库所做的所有更改，包括数据修改和结构变化。这些文件存储了对数据库的更改操作，以便在发生故障时进行恢复。重做日志文件通常以循环方式使用，即当一个日志文件被填满后，会切换到下一个日志文件。</p><h2 id="参数文件（Parameter-file）"><a href="#参数文件（Parameter-file）" class="headerlink" title="参数文件（Parameter file）"></a>参数文件（Parameter file）</h2><p>参数文件是Oracle数据库的配置文件，用于存储数据库的初始化参数设置。它包含了数据库的各种配置选项，如内存分配、日志记录级别、网络设置等。参数文件通常具有一个默认名称（如”init.ora”或”spfile.ora”），并且位于数据库实例的启动目录中。参数文件是在启动数据库实例时被读取和加载的。</p><h2 id="归档日志文件（Archived-Log-files）"><a href="#归档日志文件（Archived-Log-files）" class="headerlink" title="归档日志文件（Archived Log files）"></a>归档日志文件（Archived Log files）</h2><p>归档日志文件用来对写满的重做日志文件进行保存复制。其目的是为了长期保存日志以便于恢复。<br>数据库要运行归档模式下,如果数据不运行归档模式下,那么重做日志就循环覆盖写</p><h2 id="告警文件"><a href="#告警文件" class="headerlink" title="告警文件"></a>告警文件</h2><p>告警文件用于记录数据库启动后，用户操作上出现的问题或者数据库本身的问题，它时刻伴随着数据库。</p><div class="note info simple"><p>在Oracle数据库中，不同类型的文件起着关键的作用，确保数据库的正常运行和数据的完整性。从数据文件存储实际数据，到控制文件跟踪数据库的结构和状态，再到重做日志文件记录数据库的更改操作，以及参数文件存储数据库的各种配置选项，每个文件都具有独特的功能和重要性。了解文件的组织和作用对于维护和管理Oracle数据库至关重要。</p></div><p>希望本文的介绍能够帮助您更好地理解和应用Oracle数据库的物理结构，以及不同类型的文件在数据库中的作用。通过合理管理和配置这些文件，您可以确保数据库的稳定性和性能优化。祝您在使用Oracle数据库时取得更好的效果！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速查询优化——深入了解Oracle Hint</title>
      <link href="/posts/24522.html"/>
      <url>/posts/24522.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>引言：<br>在Oracle数据库中，查询性能的优化一直是DBA和开发人员关注的焦点。作为Oracle数据库的高级功能之一，Oracle Hint（提示）可以直接指导执行计划的生成，对于提高查询性能至关重要。</p></div><h2 id="什么是Oracle-Hint？"><a href="#什么是Oracle-Hint？" class="headerlink" title="什么是Oracle Hint？"></a>什么是Oracle Hint？</h2><p>Oracle Hint是一种以注释形式嵌入SQL语句中的指令，其目的是引导数据库优化器生成更优化的查询执行计划。通过使用Hint，我们可以直接干预执行计划的生成过程，以最大程度地提高查询性能。</p><h2 id="常用Hint"><a href="#常用Hint" class="headerlink" title="常用Hint"></a>常用Hint</h2><table><thead><tr><th>Oracle Hint</th><th>作用与使用场景</th></tr></thead><tbody><tr><td>ALL_ROWS</td><td>以最佳的性能获取所有行的方式进行查询</td></tr><tr><td>FIRST_ROWS(n)</td><td>指示优化器返回前n行结果，适用于需要快速返回部分结果的查询</td></tr><tr><td>INDEX(table_name index)</td><td>强制使用指定索引进行查询</td></tr><tr><td>FULL(table_name)</td><td>强制执行全表扫描，避免使用索引</td></tr><tr><td>ORDERED</td><td>强制按照查询中表出现的顺序连接表</td></tr><tr><td>USE_HASH(table_name)</td><td>强制使用哈希连接算法来连接表</td></tr><tr><td>USE_MERGE(table_name)</td><td>强制使用合并连接算法</td></tr><tr><td>LEADING(table_name)</td><td>指定连接的顺序</td></tr><tr><td>USE_CONCAT(table_name)</td><td>合并多个表的全表扫描</td></tr><tr><td>PARALLEL(table_name, n)</td><td>指示查询并行执行</td></tr><tr><td>INDEX_ASC(table_name)</td><td>强制使用升序索引进行查询</td></tr><tr><td>INDEX_DESC(table_name)</td><td>强制使用降序索引进行查询</td></tr><tr><td>PUSH_PRED(table_name)</td><td>提前将谓词推入到视图或子查询中进行评估</td></tr><tr><td>UNNEST(table_name)</td><td>对表的嵌套子查询进行展开</td></tr><tr><td>NO_MERGE(table_name)</td><td>禁止合并表达式计算</td></tr><tr><td>NO_PUSH_PRED(table_name)</td><td>禁止将谓词推入到视图或子查询中进行评估</td></tr><tr><td>USE_CUBE(table_name)</td><td>使用立方体优化进行查询</td></tr><tr><td>VECTOR_TRANSFORM(table_name)</td><td>使用向量转换技术进行查询</td></tr><tr><td>REWRITE(table_name)</td><td>使用查询重写技术进行优化</td></tr><tr><td>OPT_PARAM(‘optimizer_feature_enable’, ‘false’)</td><td>禁用特定的优化器功能</td></tr></tbody></table><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例子1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(orders order_date_idx) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2022-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上述查询中，我们使用Hint “INDEX(orders order_date_idx)”，强制优化器使用名为”order_date_idx”的索引来执行查询。这可以提高查询性能，尤其在处理大量数据时效果显著。</p><p>例子2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ PARALLEL(employees, 8) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “PARALLEL(employees, 8)”，指示优化器使用8个并行进程来执行查询，提高查询效率和并行处理能力。</p><p>例子3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(dept, emp) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments dept</span><br><span class="line"><span class="keyword">JOIN</span> employees emp <span class="keyword">ON</span> dept.department_id <span class="operator">=</span> emp.department_id;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “LEADING(dept, emp)”，强制优化器按照给定的连接顺序连接表，以达到更好的性能。</p><p>例子4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_HASH(customers, orders) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.customer_id <span class="operator">=</span> orders.customer_id;</span><br></pre></td></tr></table></figure><p>在以上查询中，我们使用Hint “USE_HASH(customers, orders)”，指示优化器使用哈希连接算法来连接customers表和orders表，以提升查询效率。</p><p>例子5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ OPT_PARAM(&#x27;optimizer_feature_enable&#x27;, &#x27;false&#x27;) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “OPT_PARAM(‘optimizer_feature_enable’, ‘false’)”，禁用特定的优化器功能，以便在特定情况下获得更好的查询性能。</p><h2 id="Hint使用规范"><a href="#Hint使用规范" class="headerlink" title="Hint使用规范"></a>Hint使用规范</h2><ol><li>谨慎使用：仅在需要进行特定优化时使用Hint，并在使用前进行全面测试和评估。</li><li>避免过度使用：过度使用Hint可能导致查询性能下降或不稳定。</li><li>Hint的适应性：使用Hint时要考虑数据库结构、数据规模和查询需求的特点，选择适应性强的Hint。</li><li>统计信息更新：使用Hint可能会影响优化器对表和索引的统计信息的收集和更新，应及时更新相关统计信息。</li><li>版本兼容性：不同版本的Oracle数据库对Hint的支持和效果可能有所差异，应根据具体版本权衡使用。</li></ol><blockquote><p>结语：<br>通过合理使用Oracle Hint，我们可以直接干预查询执行计划的生成过程，从而优化查询性能。在使用Hint时，我们需要根据实际需求和数据库环境进行选择和测试，并注意遵循使用Hint的最佳实践和注意事项。希望本文的介绍和示例能够帮助您更好地理解和应用Oracle Hint，并在优化查询性能的过程中取得更好的效果。祝您的查询性能优化顺利！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何根据执行计划识别低效SQL</title>
      <link href="/posts/20503.html"/>
      <url>/posts/20503.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309140949942.png" alt="总结1"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之执行顺序</title>
      <link href="/posts/12101.html"/>
      <url>/posts/12101.html</url>
      
        <content type="html"><![CDATA[<h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>  最右最上先执行</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>从上往下，第一个没有子节点的步骤先执行</li><li>对于兄弟节点，即靠上的节点先执行</li><li>所有兄弟节点执行完以后，执行父节点</li></ol><hr><ol><li>缩进最深的，最先执行</li><li>缩进深度相同的，先上后下</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>从上至下，从右向左</p><p>  由上至下：在执行计划中一般含有多个节点，相同级别(或并列)的节点，靠上的优先执行，靠下的后执行<br>  从右向左：在某个节点下还存在多个子节点，先从最靠右的子节点开始执行。</p><p>&emsp;&emsp;先从最开头一直连续往右看，直到看到最右边的并列的地方;对于不并列的，靠右的先执行;如果见到并列的，就从上往下看，对于并列的部分，靠上的先执行。</p><h2 id="格式化显示父子关系"><a href="#格式化显示父子关系" class="headerlink" title="格式化显示父子关系"></a>格式化显示父子关系</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, parent_id, operation</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> level lvl,</span><br><span class="line">               id,</span><br><span class="line">               parent_id,</span><br><span class="line">               lpad(<span class="string">&#x27; &#x27;</span>, level) <span class="operator">||</span> operation <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span> options <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span></span><br><span class="line">               object_name <span class="keyword">as</span> operation</span><br><span class="line">          <span class="keyword">from</span> plan_table</span><br><span class="line">         <span class="keyword">start</span> <span class="keyword">with</span> id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">connect</span> <span class="keyword">by</span> prior id <span class="operator">=</span> parent_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> lvl <span class="keyword">desc</span>, id;</span><br></pre></td></tr></table></figure><p>  该SQL必须同explain plan for 在同一个session（即同一个窗口执行）</p><h2 id="查看执行顺序工具"><a href="#查看执行顺序工具" class="headerlink" title="查看执行顺序工具"></a>查看执行顺序工具</h2><ul><li><p>PL/SQL Developer 快捷键 F5<br><img src="https://www.cdn.cheneyblog.com/blog/202309140926628.png" alt="示例"></p></li><li><p>XPLAN 包<br><img src="https://www.cdn.cheneyblog.com/blog/202309140927069.png" alt="XPLAN 包"><br><img src="https://www.cdn.cheneyblog.com/blog/202309140943310.png" alt="扫码获取xplan包"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划</title>
      <link href="/posts/54365.html"/>
      <url>/posts/54365.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取执行计划的方法"><a href="#获取执行计划的方法" class="headerlink" title="获取执行计划的方法"></a>获取执行计划的方法</h2><p><a href="https://cheneyblog.com//posts/16791.html">获取执行计划之 Autotrace</a><br><a href="https://cheneyblog.com//posts/21084.html">获取执行计划之 explain plan for</a><br><a href="https://cheneyblog.com//posts/8170.html">获取执行计划之 dbms_xplan.display_cursor()</a><br><a href="https://cheneyblog.com//posts/51893.html">获取执行计划之 dbms_xplan.display_awr()</a><br><a href="https://cheneyblog.com//posts/53050.html">获取执行计划之 10046 事件</a><br><a href="https://cheneyblog.com//posts/24823.html">获取执行计划之 10053 事件</a><br><a href="https://cheneyblog.com//posts/28768.html">获取执行计划之 AWR</a></p><h2 id="适用场合分析"><a href="#适用场合分析" class="headerlink" title="适用场合分析"></a>适用场合分析</h2><ol><li>简单获取执行计划的方法：explain plan for 或 set autotrace on</li><li>获取目标 SQL 的多个执行计划：dbms_xplan.display_cursor 或 AWR 报告</li><li>有函数，存在多层调用：10046 事件</li><li>表被访问次数：dbms_xplan.display_cursor 搭配 ALTER SESSION SET STATISTICS_LEVEL = ALL</li><li>获取真实执行计划：除 explain plan for 和 SET AUTOTRACE TRACEONLY EXPLAIN 外</li><li>dbms_xplan.display_cursor()与 set autotrace traceonly exp 的区别在于当 SQL 有绑定变量时，1 更准确(毕竟 sql 先执行再获取的执行计划)，2 可能不准确，其他情况下两者获取的执行计划基本一样</li></ol><h2 id="指标总结"><a href="#指标总结" class="headerlink" title="指标总结"></a>指标总结</h2><ol><li>sql 执行多次不改变 arraysize(一次提取操作在网络回路中传输的可能的数据行数)的情况下，每次的 consistent gets 不会变</li><li>sql 执行一次改变一次 arraysize 的情况下，每次的 consistent gets 会变，Arraysize 越大每次从数据块中获取的行数将得到提高，相同行数情况下，访问数据块的次数自然减小，逻辑读也就相应的降低。</li><li>arraysize 参数如果过低，会影响如 physical reads，consistent gets 还有 SQL*Net roundtrips to/from client 次数。</li><li>执行计划中的 Cost (%CPU)等于 v$sql_plan.COST</li><li>只是一个 select(非 select for update)时，db block gets 是 0</li></ol><blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309131548538.png" alt="总结1"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131550078.png" alt="总结2"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 AWR</title>
      <link href="/posts/28768.html"/>
      <url>/posts/28768.html</url>
      
        <content type="html"><![CDATA[<h2 id="AWR"><a href="#AWR" class="headerlink" title="AWR"></a>AWR</h2><p>&emsp;&emsp;AWR（Automatic Workload Repository 自动工作负载库）。AWR 报告是进行日常数据库性能评定、问题 SQL 发现的重要手段。可以自动采集 Oracle 运行中的负载信息，并生成与性能相关的统计数据。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;AWR 报告的原理是基于 Oracle 数据库的定时镜像功能。Oracle 数据库后台进程会以一定间隔收集系统的快照信息，并且保存在数据库中。AWR 通过比对两次快照收集到的统计信息来生成对应的报表数据。<br>AWR 来源：<code>V$ACTIVE_SESSION_HISTORY</code><br>AWR 开关参数：<code>CONTROL_MANAGEMENT_PACK_ACCESS</code><br>采样频率和保存时间配置表：<code>DBA_HIST_WR_CONTROL</code>。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>sqlplus 运行 awrrpt.sql 脚本</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>选择报告生成格式<br><img src="https://www.cdn.cheneyblog.com/blog/202309131531894.png" alt="报告生成格式"></p></li><li><p>选择生成报告日期，缺省值最近 7 天<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532123.png" alt="生成报告日期"></p></li><li><p>选择 snpID<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532557.png" alt="snpID"></p></li><li><p>选择报告保存路径以及名字，默认路径为当前 CMD 目录<br><img src="https://www.cdn.cheneyblog.com/blog/202309131533376.png" alt="AWR名称"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131534637.png" alt="awr完成"></p></li><li><p>根据上面的 awr 报告中，找出花费时间比较长的单条 sql 语句的执行计划<br><img src="https://www.cdn.cheneyblog.com/blog/202309131534339.png" alt="Elapsed Time"><br>我们这里以<strong>f7d3m1dh7bjkg</strong>为例</p></li><li><p>运行 awrsqrpt</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrsqrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>重复执行第二、三、四步</p></li><li><p>选择查看执行计划的 sql_id<br><img src="https://www.cdn.cheneyblog.com/blog/202309131535419.png" alt="sql_id"></p></li><li><p>默认名称生成对应 SQL 的执行计划</p></li></ol><h2 id="Awrsqrpt-报告详解"><a href="#Awrsqrpt-报告详解" class="headerlink" title="Awrsqrpt 报告详解"></a>Awrsqrpt 报告详解</h2><ul><li><p>SQL Summary<br>SQL 摘要包括 sql_id、执行时间、执行工具及 SQL 文本<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536846.png" alt="sql摘要"></p></li><li><p>SQL plan<br>SQL_ID 对应的执行计划，如果存在多个则会有多条记录，对应的 Plan Hash Value 不同<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536439.png" alt="sqlplan"></p></li><li><p>Plan Statistics<br>执行计划统计信息<br><img src="https://www.cdn.cheneyblog.com/blog/202309131537857.png" alt="plan_statistics"></p></li><li><p>Execution Plan<br>目标 SQL 对应执行步骤<br><img src="https://www.cdn.cheneyblog.com/blog/202309131538844.png" alt="Execution Plan"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_awr()</title>
      <link href="/posts/51893.html"/>
      <url>/posts/51893.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>  目标SQL的执行计划被Oracle采集到AWR Reponsitory中</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li><p>查看 <code>CONTROL_MANAGEMENT_PACK_ACCESS</code>、<code>STATISTICS_LEVEL</code> 参数</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARAMETER</span> control_management_pack_access</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> STATISTICS_LEVEL</span><br></pre></td></tr></table></figure><p> 以上两个参数用于控制诊断和调优包的使用<br> <code>CONTROL_MANAGEMENT_PACK_ACCESS</code> 应该被设置为 DIAGNOSTIC+TUNING 诊断和调优模式<br> DIAGNOSTIC 为确保启用自动数据库诊断监视器，包括 AWR、ADDM<br> TUNING 显示一 sql 推断信息和调优建议，包括 SQL Tuning Advisor,、SQLAccess Advisor</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> control_management_pack_access<span class="operator">=</span>&quot;DIAGNOSTIC+TUNING&quot;;</span><br></pre></td></tr></table></figure></li><li><p>执行测试 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查询 Shared Pool 中是否已经缓存了 <code>select count(1) from emp</code> 的执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131528480.png" alt="缓存记录"></p></li><li><p>手工收集 AWR 报告，清空 Shared Pool 缓冲池</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_workload_repository.create_snapshot();</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> flush shared_pool;</span><br><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131529745.png" alt="清空缓存池"></p></li><li><p>使用 dbms_xplan.display_awr(‘sql_id’)查看执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_awr(<span class="string">&#x27;9r5a71wx8rpr1&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><br>可以得到真实的执行计划</li><li><strong>缺点</strong><br>该方法不能显示谓词信息，是因为从 <code>V$SQL_PLAN</code> 导入 AWR 基表 <code>WRH$_SQL_PLAN</code> 时未将谓词字段 access_predicates 和 filter_predicates 导入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10053 事件</title>
      <link href="/posts/24823.html"/>
      <url>/posts/24823.html</url>
      
        <content type="html"><![CDATA[<h2 id="10053"><a href="#10053" class="headerlink" title="10053"></a>10053</h2><p>  10053事件提供了Oracle如何选择执行计划，为什么会得到这样的执行计划信息。<br>  10053事件的trace文件，只能阅读原始的trace文件，不能使用tkprof工具来处理。</p><h2 id="10053-事件级别"><a href="#10053-事件级别" class="headerlink" title="10053 事件级别"></a>10053 事件级别</h2><ul><li>Level 2<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li><li>Level 1<br>Parameters used by the optimizer<br>Index statistics<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li></ul><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>启用 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS<span class="operator">=</span><span class="string">&#x27;10053 trace name context forever, level 1&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>确定 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D.VALUE <span class="operator">||</span> <span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> <span class="built_in">LOWER</span>(RTRIM(I.INSTANCE, CHR(<span class="number">0</span>))) <span class="operator">||</span> <span class="string">&#x27;_ora_&#x27;</span> <span class="operator">||</span>P.SPID <span class="operator">||</span> <span class="string">&#x27;.trc&#x27;</span> <span class="keyword">AS</span> &quot;trace_file_name&quot;</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> P.SPID</span><br><span class="line"><span class="keyword">FROM</span> V$MYSTAT M, V$SESSION S, V$PROCESS P</span><br><span class="line">        <span class="keyword">WHERE</span> M.STATISTIC# <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> S.SID <span class="operator">=</span> M.SID</span><br><span class="line">        <span class="keyword">AND</span> P.ADDR <span class="operator">=</span> S.PADDR) P,</span><br><span class="line">    (<span class="keyword">SELECT</span> T.INSTANCE</span><br><span class="line">        <span class="keyword">FROM</span> V$THREAD T, V$<span class="keyword">PARAMETER</span> V</span><br><span class="line">        <span class="keyword">WHERE</span> V.NAME <span class="operator">=</span> <span class="string">&#x27;thread&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> (V.VALUE <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> T.THREAD# <span class="operator">=</span> TO_NUMBER(V.VALUE))) I,</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">VALUE</span> <span class="keyword">FROM</span> V$<span class="keyword">PARAMETER</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;user_dump_dest&#x27;</span>) D;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS <span class="string">&#x27;10053 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131449766.png" alt="10053"></p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10046 事件</title>
      <link href="/posts/53050.html"/>
      <url>/posts/53050.html</url>
      
        <content type="html"><![CDATA[<h2 id="10046"><a href="#10046" class="headerlink" title="10046"></a>10046</h2><p>&emsp;&emsp;10046 事件可以得到 Oracle 内部执行系统解析、调用、等待、绑定变量等详细的信息，可以帮助我们解析一条/多条 SQL、PL/SQL 语句的运行状态，这些状态包括：Parse/Fetch/Execute 三个阶段中遇到的等待事件、消耗的物理和逻辑读、CPU 时间、执行计划等，还能帮我们分析一些 DDL 维护命令的内部工作原理，RMAN、Data Pump Expdp/impdp 等工具缓慢问题。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context forever,level 12&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(m.sid),p.pid,p.tracefile <span class="keyword">from</span> v$mystat m,v$session s,v$process p <span class="keyword">where</span> m.sid<span class="operator">=</span>s.sid <span class="keyword">and</span> s.paddr<span class="operator">=</span>p.addr;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oradebug setmypid</span><br><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug tracefile_name</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131523044.png" alt="10046"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong></li></ul><ol><li>可以看出 sql 语句对应的等待事件</li><li>函数调用也会被列出</li><li>可以方便的看处理的行数，产生的逻辑物理读</li><li>可以方便的看解析时间和执行时间</li><li>可以跟踪整个程序包</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>步骤繁琐</li><li>无法判断表被访问了多少次</li><li>执行计划中的谓词部分不能清晰的展现出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_cursor()</title>
      <link href="/posts/8170.html"/>
      <url>/posts/8170.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>SQL执行计划仍在Shared Pool中</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBMS_XPLAN.DISPLAY_CURSOR(</span><br><span class="line">sql_id        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">child_number  <span class="keyword">IN</span>  NUMBER    <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">format        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="string">&#x27;TYPICAL&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>sql_id<br>指位于库缓存执行计划中 SQL 语句的父游标。默认值为 null。当使用默认值时当前会话的最后一条 SQL 语句的执行计划将被返回<br>可以通过查询 <code>V$SQL</code> 或 <code>V$SQLAREA</code> 的 SQL_ID 列来获得 SQL 语句的 SQL_ID。</li><li>child_number<br>指定父游标下子游标的序号。即指定被返回执行计划的 SQL 语句的子游标。默认值为 0。如果为 null，则 sql_id 所指父游标下所有子游标的执行计划都将被返回。</li><li>format<br>控制 SQL 语句执行计划的输出部分。</li></ul><h2 id="Format-参数详解"><a href="#Format-参数详解" class="headerlink" title="Format 参数详解"></a>Format 参数详解</h2><ul><li>官方输出格式<ol><li>BASIC: 显示最少的信息，只包括操作类型，ID 名称和选项。</li><li>TYPICAL: 默认值，显示相关信息以及某些附加的显示选项，如分区和并发使用等。</li><li>SERIAL: 与 TYPICAL 类型相似，区别是它不包括并发的信息，即使是并行执行的计划。</li><li>ALL: 显示最多的信息，包含了 TYPICAL 的全部以及更多的附加信息,如别名和远程调用等。</li></ol></li><li>附加输出格式（逗号和空格分隔来声明多个关键字，使用”+”和”-”符号来包含或排除相应的显示元素）<ol><li>ROWS – 显示被优化器估算的记录的行号</li><li>BYTES – 显示优化器估算的字节数</li><li>COST – 显示优化器计算的成本信息</li><li>PARTITION – 显示分区的分割信息</li><li>PARALLEL – 显示并行执行信息</li><li>PREDICATE – 显示谓语</li><li>PROJECTION – 显示列投影部分(每一行的那些列被传递给其父列已经这些列的大小)</li><li>ALIAS – 显示查询块名称已经对象别名</li><li>REMOTE – 显示分布式查询信息</li><li>NOTE – 显示注释</li><li>IOSTATS – 显示游标执行的 IO 统计信息</li><li>MEMSTATS – 为内存密集运算如散列联结，排序，或一些类型的位图运算显示内存管理统计信息</li><li>ALLSTATS – 与’IOSTATS MEMSTATS’等价</li><li>LAST – 显示最后执行的执行计划统计信息，默认显示为 ALL 类型，并且可以累积。</li></ol></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><code>dbms_xplan.display_cursor(null,null,&#39;advanced&#39;)</code> 仅用于 SQLplus 中查看刚执行过的 SQL 执行计划，在 PL/SQL Developer 中无法使用，因为工具在执行完 SQL 后还会执行其他的后台语句。</p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>  <code>dbms_xplan.display_cursor()</code>通常搭配<code>ALTER SESSION SET STATISTICS_LEVEL = ALL</code>或 <code>/*+ GATHER_PLAN_STATISTICS*/</code></p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131521485.png" alt="执行计划"></p><ol><li>starts：SQL 执行的次数；</li><li>E-Rows：执行计划预计返回的行数；</li><li>A-Rows：执行计划实际返回的行数；</li><li>A-Time：每一步执行的时间(HH:MM:SS.FF)，根据这一行可知 SQL 耗时在哪些地方；</li><li>Buffers：每一步实际执行的逻辑读或一致性读；</li><li>Reads：物理读；</li><li>OMem：OMem 为最优执行模式所需的内存评估值， 这个数据是由优化器统计数据以及前一次执行的性能数据估算得出的；</li><li>1Mem：1Mem 为 one-pass 模式所需的内存评估值，当工作区大小无法满足操作所需的大小时，需要将部分数据写入临时磁盘空间中(如果仅需要写入一次就可以完成操作，就称一次通过，One-Pass;否则为多次通过，Multi-Pass).该列数据为语句最后一次执行中，单次写磁盘所需要的内存大小，这个由优化器统计数据以及前一次执行的性能数据估算得出的</li><li>Used_Mem：Used-Mem 则为当前操作实际执行时消耗的内存，括号里面为(发生磁盘交换的次数,1 次即为 One-Pass,大于 1 次则为 Multi_Pass,如果没有使用磁盘，则显示 0)</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>可得到真实的执行计划</li><li>可以看出表被访问了多少次</li><li>可以通过 E-ROWS 和 A-RWS 得到预测行数和实际行数</li><li>Buffers 和 Reads 也可以显示真实的逻辑读和物理读</li></ol></li><li><strong>缺点</strong><ol><li>只有语句执行完毕才可以看到结果</li><li>看不出递归调用的次数</li><li>无法控制记录打屏输出</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 explain plan for</title>
      <link href="/posts/21084.html"/>
      <url>/posts/21084.html</url>
      
        <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br></pre></td></tr></table></figure><p>explain plan命令通常和dbms_xplan.display()命令结合使用<br>PL/SQL Developer里F5快捷键的原理就是调用explain plan命令</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;explain plan 命令的原理是 Oracle 将目标 SQL 所产生的执行计划写入 PLAN_TABLE$<br>（ON COMMIT PRESERVE ROWS 的 GLOBAL TEMPORARY TABLE 即会话级临时表仅对当前会话有效）然后再通过dbms_xplan.display()命令将PLAN_TABLE$中的具体执行步骤格式化显示出来</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>无需真正执行，快捷方便</li></ol></li><li><strong>缺点</strong><ol><li>没有输出相关统计信息</li><li>无法判断是处理了多少行</li><li>无法判断表被访问了多少次</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 Autotrace</title>
      <link href="/posts/16791.html"/>
      <url>/posts/16791.html</url>
      
        <content type="html"><![CDATA[<h2 id="Autotrace-简介"><a href="#Autotrace-简介" class="headerlink" title="Autotrace 简介"></a>Autotrace 简介</h2><pre><code>AUTOTRACE是一项SQL*Plus功能，自动跟踪为SQL语句生成一个执行计划并且提供与该语句的处理有关的统计。AUTOTRACE的好处是您不必设置跟踪文件的格式，并且它将自动为SQL语句显示执行计划。</code></pre><h2 id="Autotrace-选项说明"><a href="#Autotrace-选项说明" class="headerlink" title="Autotrace 选项说明"></a>Autotrace 选项说明</h2><table><thead><tr><th align="center">命令</th><th align="center">输出内容</th><th align="center">简写</th><th>是否真实执行</th></tr></thead><tbody><tr><td align="center">SET AUTOTRACE OFF</td><td align="center">缺省模式，只显示 SQL 执行结果</td><td align="center">SET AUTOT OFF</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE ON</td><td align="center">显示 SQL 结果、执行路径和资源消耗</td><td align="center">SET AUTOT ON</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY</td><td align="center">显示 SQL 结果数量、执行路径和资源消耗</td><td align="center">SET AUTOT TRACE</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY EXPLAN</td><td align="center">只显示 SQL 执行路径</td><td align="center">SET AUTOT TRACE EXP</td><td>Select 语句没有，DML 会被执行</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY STATISTICS</td><td align="center">只显示资源消耗</td><td align="center">SET AUTOT TRACE STAT</td><td></td></tr></tbody></table><h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309131518397.png" alt="统计信息"></p><table><thead><tr><th align="right">统计信息</th><th align="left">解释</th></tr></thead><tbody><tr><td align="right">recursive calls</td><td align="left">产生的递归 sql 调用的条数</td></tr><tr><td align="right">Db block gets</td><td align="left">从 buffer cache 中读取的 block 的数量</td></tr><tr><td align="right">consistent gets</td><td align="left">从 buffer cache 中读取的 undo 数据的 block 的数量</td></tr><tr><td align="right">physical reads</td><td align="left">从磁盘读取的 block 的数量</td></tr><tr><td align="right">redo size</td><td align="left">DML 生成的 redo 的大小</td></tr><tr><td align="right">bytes sent via SQL*Net to client</td><td align="left">数据库服务器通过 SQL*Net 向查询客户端发送的查询结果字节数</td></tr><tr><td align="right">bytes received via SQL*Net from client</td><td align="left">通过 SQL*Net 接受的来自客户端的数据字节数</td></tr><tr><td align="right">SQL*Net roundtrips to/from client</td><td align="left">服务器和客户端来回往返通信的 Oracle Net messages 条数</td></tr><tr><td align="right">sorts (memory)</td><td align="left">在内存执行的排序量</td></tr><tr><td align="right">sorts (disk)</td><td align="left">在磁盘上执行的排序量</td></tr><tr><td align="right">rows processed</td><td align="left">处理的数据的行数</td></tr></tbody></table><h2 id="Autotrace-优缺点"><a href="#Autotrace-优缺点" class="headerlink" title="Autotrace 优缺点"></a>Autotrace 优缺点</h2><ul><li><strong>优点</strong><ol><li>可以输出运行时的相关统计信息</li><li>有多种模式可供选择</li></ol></li><li><strong>缺点</strong><ol><li>必须要等 SQL 语句执行完，才出结果</li><li>无法看到表被访问了多少次</li><li>当存在绑定变量时执行计划可能不准</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解DBMS_STATS包：优化Oracle数据库统计信息管理</title>
      <link href="/posts/32449.html"/>
      <url>/posts/32449.html</url>
      
        <content type="html"><![CDATA[<h2 id="收集统计信息"><a href="#收集统计信息" class="headerlink" title="收集统计信息"></a>收集统计信息</h2><p>首先，让我们通过一个例子来了解如何使用DBMS_STATS包收集表的统计信息。假设我们有一个名为”employees”的表，我们希望为该表收集统计信息。我们可以使用以下命令执行此操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_STATS.GATHER_TABLE_STATS(<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;EMPLOYEES&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中，’HR’为用户名，’EMPLOYEES’为表名。通过执行以上命令，DBMS_STATS包会收集’employees’表的统计信息，如行数、列的唯一值数量、索引信息等。</p><h2 id="自动收集统计信息"><a href="#自动收集统计信息" class="headerlink" title="自动收集统计信息"></a>自动收集统计信息</h2><p>除了手动收集，我们还可以让DBMS_STATS包自动定期收集统计信息，以确保数据库的最新性能。首先，我们需要创建一个统计信息收集作业。以下是一个创建作业的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_SCHEDULER.CREATE_JOB(</span><br><span class="line">      job_name        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_COLLECTION_JOB&#x27;</span>,</span><br><span class="line">      job_type        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;PLSQL_BLOCK&#x27;</span>,</span><br><span class="line">      job_action      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;BEGIN DBMS_STATS.GATHER_DATABASE_STATS(); END;&#x27;</span>,</span><br><span class="line">      start_date      <span class="operator">=</span><span class="operator">&gt;</span> SYSTIMESTAMP,</span><br><span class="line">      repeat_interval <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;FREQ=DAILY&#x27;</span>,</span><br><span class="line">      enabled         <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过这个作业，DBMS_STATS包将每天收集一次数据库的统计信息。</p><h2 id="导出和导入统计信息"><a href="#导出和导入统计信息" class="headerlink" title="导出和导入统计信息"></a>导出和导入统计信息</h2><p>另一个强大的功能是DBMS_STATS包支持统计信息的导出和导入。这在数据库升级、数据迁移或创建测试环境时非常有用。以下是一个导出统计信息的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.EXPORT_SCHEMA_STATS(</span><br><span class="line">      ownname      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;HR&#x27;</span>,</span><br><span class="line">      stattab      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_TABLE&#x27;</span>,</span><br><span class="line">      statid       <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;EMP_STATS&#x27;</span>,</span><br><span class="line">      statown      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_OWNER&#x27;</span>,</span><br><span class="line">      cascade      <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们将’HR’模式的统计信息导出到名为’STATS_TABLE’的表中。</p><h2 id="统计信息管理"><a href="#统计信息管理" class="headerlink" title="统计信息管理"></a>统计信息管理</h2><p>除了收集和导出统计信息，DBMS_STATS包还提供了其他管理功能。例如，我们可以使用以下命令锁定统计信息，防止其被自动收集或修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.LOCK_SCHEMA_STATS(<span class="string">&#x27;HR&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过上述命令，’HR’用户的统计信息将被锁定。</p><blockquote><p>DBMS_STATS包是Oracle数据库中一个强大的工具包，通过其提供的过程和函数，我们可以方便地收集、导出、导入和管理数据库对象的统计信息。深入了解和灵活应用DBMS_STATS包的知识，可以帮助我们优化数据库性能，提高查询效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle执行计划简介：优化数据库查询的关键</title>
      <link href="/posts/20895.html"/>
      <url>/posts/20895.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h2><p>执行计划是Oracle数据库根据查询语句、表、索引和统计信息等生成的一种执行路线图，它描述了数据库优化器在执行查询语句时的执行步骤和操作方式。执行计划包括了查询的访问方式、连接方式、操作顺序等关键信息。</p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131358420.png" alt="执行计划示例"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li><p>目标 SQL 的正文、sql_id 和执行计划对应的 plan_hash_value<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610746.png" alt="目标SQL的正文"></p></li><li><p>执行计划主体，主要有内部执行步骤、执行顺序、谓词信息、列信息、Cardinality、Cost 等<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610827.png" alt="执行计划主体"></p></li><li><p>执行计划的额外补充信息，是否动态采用（dynamic sampling）、是否 Cardinality Feedback、是否 SQL Profile<br><img src="https://www.cdn.cheneyblog.com/blog/202309131611503.png" alt="补充信息"></p></li></ol><h2 id="模块解读"><a href="#模块解读" class="headerlink" title="模块解读"></a>模块解读</h2><h3 id="主体-Header"><a href="#主体-Header" class="headerlink" title="主体 Header"></a>主体 Header</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131611458.png" alt="Header"></p><ul><li>ID：序号</li><li>Operation： 当前操作的内容</li><li>Rows： 当前操作的 Cardinality，Oracle 估计当前操作的返回结果集。</li><li>Cost：SQL 执行的代价</li><li>Time：Oracle 估计当前操作的时间</li></ul><h3 id="Query-Block-Name"><a href="#Query-Block-Name" class="headerlink" title="Query Block Name"></a>Query Block Name</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131612236.png" alt="Query Block Name"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Query Block Name <span class="operator">/</span> Object Alias (identified <span class="keyword">by</span> operation id):           <span class="comment">--这部分显示的为查询块名和对象别名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> SEL$<span class="number">1</span>                                                            <span class="comment">--SEL$为select 的缩写，位于块1,相应的还有DEL$,INS$,UPD$等</span></span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span>                                               <span class="comment">--DEPT@SEL$1，对应到执行计划中的操作ID为3上，即在表DEPT上的查询，DEPT为别名，下面类同</span></span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> EMP<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> J<span class="variable">@SEL</span>$<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Outline-Data"><a href="#Outline-Data" class="headerlink" title="Outline Data"></a>Outline Data</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613271.png" alt="Outline Data"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Outline Data                                                            <span class="comment">--提纲部分，这部分将执行计划中的图形化方式以文本形式来呈现，即转换为提示符方式</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*+</span></span><br><span class="line"><span class="comment">      BEGIN_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">      IGNORE_OPTIM_EMBEDDED_HINTS</span></span><br><span class="line"><span class="comment">      OPTIMIZER_FEATURES_ENABLE(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      DB_VERSION(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      ALL_ROWS</span></span><br><span class="line"><span class="comment">      OUTLINE_LEAF(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      INDEX(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; (&quot;DEPT&quot;.&quot;DEPTNO&quot;))                  --指明对于DEPT上的访问方式为使用索引</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                      --指明对于EMP上的访问方式为全表扫描</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      LEADING(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)        --指明前导表</span></span><br><span class="line"><span class="comment">      USE_MERGE(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                 --使用USE_MERGE提示，即MERGE SORT排序合并连接</span></span><br><span class="line"><span class="comment">      USE_HASH(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)                                    --使用USE_HASH提示，即HASH连接</span></span><br><span class="line"><span class="comment">      END_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="Predicate-Information"><a href="#Predicate-Information" class="headerlink" title="Predicate Information"></a>Predicate Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613212.png" alt="Predicate Information"></p><ul><li>Access</li></ul><ol><li>通过某种方式定位了需要的数据，然后读取出这些结果集，叫做 Access。</li><li>表示这个谓词条件的值将会影响数据的访问路劲（表还是索引）。</li></ol><ul><li>Filter</li></ul><ol><li>把所有的数据都访问了，然后过滤掉不需要的数据，这种方式叫做 filter 。</li><li>表示谓词条件的值不会影响数据的访问路劲，只起过滤的作用。</li></ol><h3 id="Column-Projection-Information"><a href="#Column-Projection-Information" class="headerlink" title="Column Projection Information"></a>Column Projection Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131614629.png" alt="Column Projection Information"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Column</span> Projection Information (identified <span class="keyword">by</span> operation id):             <span class="comment">--执行时每一步骤所返回的列，下面的不同步骤返回了不同的列</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br><span class="line">   <span class="number">2</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>]</span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> &quot;DEPT&quot;.ROWID[ROWID,<span class="number">10</span>], &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">5</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>], &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> &quot;J&quot;.&quot;JOB_NAME&quot;[VARCHAR2,<span class="number">50</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131615740.png" alt="Note"><br>&emsp;&emsp;动态采样（dynamic sampling）是 Oracle CBO 优化器的一种特性。如果相关数据表没有收集过统计量，又要使用 CBO 的机制，就会引起动态采样。</p><h2 id="执行计划的选定依据"><a href="#执行计划的选定依据" class="headerlink" title="执行计划的选定依据"></a>执行计划的选定依据</h2><p>在选择执行计划时，数据库优化器会考虑以下几个关键依据：</p><ol><li>统计信息：执行计划的选定依赖于表、索引和列的统计信息。这些统计信息包括表的行数、列的唯一值数目、索引的高度等。通过准确的统计信息，优化器能够评估不同执行计划的成本和效率，并选择最佳的执行路径。</li><li>查询语句和条件：执行计划的选定还考虑了查询语句和条件的影响。优化器会分析查询涉及的表、索引、连接方式以及查询条件的复杂性和选择性。根据这些因素，优化器会评估执行计划的成本和效率，以选择最佳的执行路径。</li><li>系统资源：执行计划的选定还会受到系统资源的限制和优化目标的影响。优化器会考虑系统可用的资源（例如CPU和内存）以及管理员设置的优化目标，以选择适当的执行计划，以平衡查询性能和系统负载。</li></ol><blockquote><p>执行计划在优化数据库查询性能中起着关键的作用。它能够帮助我们理解查询的执行过程、优化查询语句和提高数据库的响应速度。执行计划的选定依据主要包括统计信息、查询语句和条件，以及系统资源的限制和优化目标。通过深入理解和应用执行计划，我们能够更好地优化查询性能，提升数据库的整体效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升数据库性能的关键：Oracle统计信息</title>
      <link href="/posts/26508.html"/>
      <url>/posts/26508.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是统计信息？"><a href="#什么是统计信息？" class="headerlink" title="什么是统计信息？"></a>什么是统计信息？</h2><p>统计信息是数据库中关于表、索引和列的统计数据，用于优化查询计划的生成。Oracle数据库会定期收集这些统计信息，并据此进行优化决策，以提供最佳的查询性能。统计信息主要包括表的行数、列的唯一值个数、索引高度等。</p><h2 id="为什么统计信息如此重要"><a href="#为什么统计信息如此重要" class="headerlink" title="为什么统计信息如此重要"></a>为什么统计信息如此重要</h2><p>统计信息的准确性直接影响着查询的执行效率。如果统计信息不准确，数据库可能会选择错误的查询计划，导致查询性能下降甚至出现严重的性能问题。因此，及时收集和更新统计信息是提升数据库性能的关键步骤之一。</p><h2 id="如何收集统计信息"><a href="#如何收集统计信息" class="headerlink" title="如何收集统计信息"></a>如何收集统计信息</h2><p>Oracle提供了多种方式来收集统计信息：</p><ol><li>自动收集：Oracle会自动定期收集表的统计信息，可以通过设置相关参数来调整收集的频率和深度。</li><li>手动收集：可以使用DBMS_STATS包中的过程来手动收集统计信息，可以选择对整个数据库、表、索引或列进行统计信息的收集。</li><li>统计信息导入导出：可以将统计信息导出为统计信息的XML格式文件，然后在其他数据库中导入使用。</li></ol><h2 id="如何使用统计信息优化性能"><a href="#如何使用统计信息优化性能" class="headerlink" title="如何使用统计信息优化性能"></a>如何使用统计信息优化性能</h2><p>在收集统计信息后，Oracle优化器会根据统计信息进行查询计划的生成。有几点需要注意：</p><ol><li>统计信息的准确性：确保收集的统计信息准确无误，可以使用DBMS_STATS包提供的过程对统计信息进行评估和修正。</li><li>统计信息的更新：当表的数据发生较大变化时，需要及时更新统计信息，以保证优化器生成最新且最适合的查询计划。</li><li>数据库参数的设置：合理配置相关的数据库参数，如optimizer_mode、optimizer_index_cost_adj等，以便优化器更好地利用统计信息进行查询优化。</li></ol><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>大家可能注意到LAST_ANALYZED字段的取值，似乎时间有点早，不像每天都收集的样子，原来Oracle可以专门对表的记录变化量进行管理，当某表一天记录变化量没有超过指定的阈值时，Oracle就不会对该表进行统计信息收集，所以很多时候不少表被<br>第一次收集统计信息后，由于一直很少更新，故很少再有针对该表收集信息的动作。</p></div><blockquote><p>Oracle统计信息在数据库性能的优化中起着至关重要的作用。通过准确收集和更新统计信息，我们可以使数据库选择最佳的查询计划，从而提升查询性能。同时，定期的统计信息维护也是保证数据库长期稳定运行的重要环节。希望以上的内容对你们理解和应用统计信息有所帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组解析：探索数据存储与操作的利器</title>
      <link href="/posts/50102.html"/>
      <url>/posts/50102.html</url>
      
        <content type="html"><![CDATA[<h2 id="数组的基础知识"><a href="#数组的基础知识" class="headerlink" title="数组的基础知识"></a>数组的基础知识</h2><p>数组是一种存储连续数据的结构，它由相同类型的元素组成。在Java中，数组的长度是固定的，一旦创建后，无法改变。每个元素都通过索引访问，索引从0开始。这个特性使得数组在很多编程任务中非常有用。</p><h2 id="数组的声明和初始化"><a href="#数组的声明和初始化" class="headerlink" title="数组的声明和初始化"></a>数组的声明和初始化</h2><p>在Java中，声明和初始化数组可以分为两步，首先声明数组变量，然后使用<code>new</code>关键字为数组分配内存并初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个整数数组</span></span><br><span class="line"><span class="type">int</span>[] numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个长度为5的整数数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化一个字符串数组</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简化的语法初始化一个字符数组</span></span><br><span class="line"><span class="type">char</span>[] vowels = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过指定数组的大小和类型，我们可以声明一个数组，然后使用<code>new</code>关键字为其分配内存空间。</p><h2 id="数组的访问和遍历"><a href="#数组的访问和遍历" class="headerlink" title="数组的访问和遍历"></a>数组的访问和遍历</h2><p>通过索引，我们可以访问数组中的元素。索引从0开始，最后一个元素的索引为数组长度减1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">firstNumber</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">// 访问数组的第一个元素</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">10</span>; <span class="comment">// 修改数组的第三个元素</span></span><br></pre></td></tr></table></figure><p>除了直接访问数组元素，我们还可以使用循环结构（如<code>for</code>循环或<code>foreach</code>循环）来遍历数组中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><p>Java提供了许多有用的数组操作方法。例如，我们可以使用<code>Arrays</code>类中的<code>sort()</code>方法对数组进行排序，使用<code>binarySearch()</code>方法查找元素，使用<code>copyOf()</code>方法复制数组等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧妙运用Java表达式：编程中的算术与逻辑之道</title>
      <link href="/posts/37227.html"/>
      <url>/posts/37227.html</url>
      
        <content type="html"><![CDATA[<h2 id="算术表达式：实现精确计算"><a href="#算术表达式：实现精确计算" class="headerlink" title="算术表达式：实现精确计算"></a>算术表达式：实现精确计算</h2><p>在Java中，算术表达式用于进行数学运算，例如加法、减法、乘法和除法等。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> a - b; <span class="comment">// 减法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法</span></span><br></pre></td></tr></table></figure><p>另外，Java还提供了取模运算符（%），用于获取两个数相除的余数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><p>合理利用算术表达式的组合和嵌套，可以实现复杂的数学计算，并在编程中达到精确计算的目的。</p><h2 id="逻辑表达式：实现条件判断"><a href="#逻辑表达式：实现条件判断" class="headerlink" title="逻辑表达式：实现条件判断"></a>逻辑表达式：实现条件判断</h2><p>逻辑表达式在编程中非常重要，它用于实现条件判断和逻辑控制。我们常用的逻辑操作符有：</p><ul><li>逻辑与（&amp;&amp;）：当两个操作数都为true时，结果为true。</li><li>逻辑或（||）：当两个操作数中有一个为true时，结果为true。</li><li>逻辑非（！）：用于取反操作，将true变为false，将false变为true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFalse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> isTrue &amp;&amp; isFalse; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> isTrue || isFalse; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result3</span> <span class="operator">=</span> !isTrue; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>逻辑表达式通常与条件语句（如if语句）结合使用，根据条件的真假执行相应的逻辑操作。</p><h2 id="提高表达式的可读性和效率"><a href="#提高表达式的可读性和效率" class="headerlink" title="提高表达式的可读性和效率"></a>提高表达式的可读性和效率</h2><p>在编程中，良好的代码习惯对于表达式的编写非常重要。以下是一些有效的建议，可帮助提高表达式的可读性和效率：</p><ol><li><p>使用括号：使用括号明确表达式的执行顺序，避免歧义。</p></li><li><p>命名变量：使用有意义的变量名，使表达式更易理解。</p></li><li><p>避免过度复杂化：尽量避免编写过于复杂的表达式，以免降低代码的可读性和可维护性。</p></li><li><p>避免除数为0的情况：在进行除法操作时，务必考虑除数为0的异常情况。</p></li><li><p>使用短路求值：对于逻辑与（&amp;&amp;）和逻辑或（||）操作，利用短路求值的特性，可以提高代码的效率。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程语言：优雅而强大的编程利器</title>
      <link href="/posts/42473.html"/>
      <url>/posts/42473.html</url>
      
        <content type="html"><![CDATA[<p>Java作为一门广泛应用于软件开发和企业级应用的编程语言，以其优雅的语法、强大的跨平台性能和丰富的生态系统而广受欢迎。本文将为您全面介绍Java的起源、特点和发展历程，带您走进这门受众众多开发者推崇的编程利器。</p><h2 id="起源和背景"><a href="#起源和背景" class="headerlink" title="起源和背景"></a>起源和背景</h2><p>Java诞生于20世纪90年代初，由Sun Microsystems的詹姆斯·高斯林（James Gosling）及其团队创作。当时，Sun Microsystems致力于开发一种能在家用电视和其他家电设备上运行的机器语言，他们让这个项目称为“绿色计划”。然而，由于电视技术的限制，这个项目没能实现，但是却为创建一种通用的编程语言奠定了基础。</p><h2 id="Java的特点与优势"><a href="#Java的特点与优势" class="headerlink" title="Java的特点与优势"></a>Java的特点与优势</h2><p>Java具备诸多独特的特点和优势，使它成为了如今广泛使用的编程语言之一：</p><ol><li><p>跨平台性：Java的最大特点之一是“一次编写，到处运行”。它的程序可以在各种操作系统上运行，如Windows、Mac、Linux等，这是通过Java虚拟机（JVM）实现的。</p></li><li><p>简单易学：Java采用了C++语言的面向对象编程理念，但去除了C++中的复杂和难以理解的部分。Java提供了清晰而易于理解的语法，使初学者也能够轻松入门。</p></li><li><p>安全性：Java注重安全性，它提供了一些机制用于防止程序中的潜在安全漏洞。Java的安全性主要通过Java安全管理器、类加载机制以及字节码验证等来实现。</p></li><li><p>面向对象：Java是一种纯面向对象的编程语言，它支持类、继承、多态等面向对象的特性。这种特点使得Java开发更加模块化、易于维护和扩展。</p></li><li><p>强大的生态系统：Java拥有丰富的类库和开发工具，比如Java标准库（Java API）提供了大量已经实现的类和方法，开发者可以直接使用这些类来实现复杂的功能。此外，Java还有大量的开源框架和工具，如Spring、Hibernate等，能够帮助开发者更高效地进行开发。</p></li></ol><h2 id="发展历程和应用领域"><a href="#发展历程和应用领域" class="headerlink" title="发展历程和应用领域"></a>发展历程和应用领域</h2><p>Java的成功得益于其出色的设计和适用性，在过去的几十年中不断发展壮大。</p><ol><li><p>初期发展（1995-2000）：Java 1.0发布后迅速引起了开发者们的关注，在互联网的应用和Web开发中得以迅速推广。Java Servlet和Java Server Pages（JSP）的引入使得Java在Web应用开发领域占据了重要的地位。</p></li><li><p>中期发展（2000-2010）：Java 2（J2SE）、Java 2 Enterprise Edition（J2EE）和Java 2 Micro Edition（J2ME）等版本陆续发布，Java的应用范围进一步扩大。同时，大型企业应用和金融系统中广泛采用Java，使其成为企业级应用的首选语言。</p></li><li><p>当代发展（2010至今）：Java 8的发布引入了函数式编程的特性，使得Java更加现代化和强大。Java继续保持其领先地位，广泛应用于大数据处理、云计算、物联网和移动应用等领域。</p></li></ol><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>随着技术的发展和需求的变化，Java仍然保持着强大的生命力。目前，Java继续推进语言和库的更新，提供更好的性能和安全性。同时，Java也在不断发展与演进，如引入模块化系统（Java模块化系统）和提供更好的开发工具支持等。</p><blockquote><p>Java是一门具备优雅语法和强大能力的编程语言，它的跨平台性、面向对象特性和丰富的生态系统使其得到了广泛应用。无论是开发大型企业级应用还是小型移动应用，Java都能为开发者提供可靠的解决方案。相信未来，在技术的推动下，Java将继续成为企业级开发和大规模系统构建的首选语言。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精通Java流程控制：玩转条件和循环，打造高效编程之路！</title>
      <link href="/posts/42343.html"/>
      <url>/posts/42343.html</url>
      
        <content type="html"><![CDATA[<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句用于根据条件的成立与否决定是否执行某个代码块。Java中常用的条件语句有<code>if</code>语句、<code>if-else</code>语句和<code>switch</code>语句。</p><ol><li><p><code>if</code>语句</p><p> <code>if</code>语句用于在条件成立时执行某个代码块，语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>condition</code>是一个布尔表达式，当其结果为<code>true</code>时，执行代码块。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>if-else</code>语句</p><p> <code>if-else</code>语句用于在条件成立和不成立时分别执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行条件为true时的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行条件为false时的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num小于等于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>语句</p><p> <code>switch</code>语句用于根据不同的取值，执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 执行值为value1的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 执行值为value2的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 执行默认情况的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>expression</code>是一个表达式，根据其值来匹配不同的<code>case</code>。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行一段代码，直到某个条件不再成立。Java中常用的循环语句有<code>for</code>循环、<code>while</code>循环和<code>do-while</code>循环。</p><ol><li><p><code>for</code>循环</p><p> <code>for</code>循环用于在已知循环次数的情况下重复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>while</code>循环</p><p> <code>while</code>循环用于在条件成立时反复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>do-while</code>循环</p><p> <code>do-while</code>循环和<code>while</code>循环类似，不同之处在于它先执行一次循环体，然后在判断条件是否成立。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="流程控制的嵌套和跳转"><a href="#流程控制的嵌套和跳转" class="headerlink" title="流程控制的嵌套和跳转"></a>流程控制的嵌套和跳转</h2><p>在实际编程中，我们常常会在流程控制语句内部进行嵌套，以实现更复杂的逻辑。此外，Java还提供了跳转语句<code>break</code>和<code>continue</code>，用于跳出循环或跳过本次循环。</p><ul><li><code>break</code>语句用于跳出当前循环，结束循环执行。</li><li><code>continue</code>语句用于跳过本次循环，继续执行下一次循环。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Java运算符：理解常用运算符及其应用场景</title>
      <link href="/posts/37240.html"/>
      <url>/posts/37240.html</url>
      
        <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用于执行基本的数学运算，包括加法、减法、乘法、除法、取模等。对于整型和浮点型变量，可以使用如下算术运算符：</p><ul><li><code>+</code> ：用于执行加法运算；</li><li><code>-</code> ：用于执行减法运算；</li><li><code>*</code> ：用于执行乘法运算；</li><li><code>/</code> ：用于执行除法运算；</li><li><code>%</code> ：用于执行取模（求余）运算。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">subtract</span> <span class="operator">=</span> a - b; <span class="comment">// 减法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符用于将一个值赋给变量。Java中的常用赋值运算符是<code>=</code>，表示将右边的值赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>a</code>变量被赋值为10，然后将<code>a</code>的值赋给了<code>b</code>变量。</p><p>另外，赋值运算符还有一些简化的形式，如<code>+=</code>、<code>-=</code>、<code>*=</code>等，表示将右边的值和左边的变量进行特定运算后再赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">num += <span class="number">10</span>; <span class="comment">// 等价于num = num + 10;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>num</code>的值先加上10，再赋给<code>num</code>。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符用于比较两个值之间的关系，返回一个布尔值（<code>true</code>或<code>false</code>）。常见的关系运算符包括：</p><ul><li><code>==</code> ：判断相等；</li><li><code>!=</code> ：判断不等；</li><li><code>&gt;</code> ：大于；</li><li><code>&lt;</code> ：小于；</li><li><code>&gt;=</code> ：大于等于；</li><li><code>&lt;=</code> ：小于等于。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (a &gt; b); <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符用于执行逻辑操作，常用的逻辑运算符有：</p><ul><li><code>&amp;&amp;</code> ：逻辑与运算符，当两个条件都为<code>true</code>时，返回<code>true</code>；</li><li><code>||</code> ：逻辑或运算符，当两个条件其中一个为<code>true</code>时，返回<code>true</code>；</li><li><code>!</code> ：逻辑非运算符，用于取反操作。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">condition1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">condition2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> condition1 &amp;&amp; condition2; <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符用于对整数类型的数据进行位操作，常见的位运算符包括：</p><ul><li><code>&amp;</code> ：按位与运算，对每一位进行与操作；</li><li><code>|</code> ：按位或运算，对每一位进行或操作；</li><li><code>^</code> ：按位异或运算，对每一位进行异或操作；</li><li><code>~</code> ：按位取反运算，对每一位进行取反操作；</li><li><code>&lt;&lt;</code> ：左移运算符，将二进制表示的数向左移动指定位数；</li><li><code>&gt;&gt;</code> ：右移运算符，将二进制表示的数向右移动指定位数。</li></ul><p>位运算符常用于处理二进制数据，例如位操作、图像处理、加密算法等。</p><h2 id="自增、自减运算符"><a href="#自增、自减运算符" class="headerlink" title="自增、自减运算符"></a>自增、自减运算符</h2><p>在Java中，自增自减运算符是一种用于增加或减少变量值的特殊运算符。它们可以用于整数类型和浮点数类型的变量。</p><ul><li>自增运算符（++）用于增加变量的值。语法是<code>++variable</code>或<code>variable++</code>。如果它在变量前使用（前缀），它会先将变量增加一次，然后返回增加后的值；如果它在变量后使用（后缀），它会先返回变量当前的值，然后再增加一次。</li></ul><p>下面是使用自增运算符的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a; <span class="comment">// 先将 a 增加 1，然后将结果赋给 b</span></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a); <span class="comment">// 输出结果：a = 6</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b); <span class="comment">// 输出结果：b = 6</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c++; <span class="comment">// 先将 c 的值赋给 d，然后再将 c 增加 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;c = &quot;</span> + c); <span class="comment">// 输出结果：c = 11</span></span><br><span class="line">System.out.println(<span class="string">&quot;d = &quot;</span> + d); <span class="comment">// 输出结果：d = 10</span></span><br></pre></td></tr></table></figure><ul><li>自减运算符（–）用于减少变量的值。语法和使用方式与自增运算符相同，只是操作是减少而不是增加。</li></ul><p>下面是使用自减运算符的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> --a; <span class="comment">// 先将 a 减少 1，然后将结果赋给 b</span></span><br><span class="line">System.out.println(<span class="string">&quot;a = &quot;</span> + a); <span class="comment">// 输出结果：a = 4</span></span><br><span class="line">System.out.println(<span class="string">&quot;b = &quot;</span> + b); <span class="comment">// 输出结果：b = 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> c--; <span class="comment">// 先将 c 的值赋给 d，然后再将 c 减少 1</span></span><br><span class="line">System.out.println(<span class="string">&quot;c = &quot;</span> + c); <span class="comment">// 输出结果：c = 9</span></span><br><span class="line">System.out.println(<span class="string">&quot;d = &quot;</span> + d); <span class="comment">// 输出结果：d = 10</span></span><br></pre></td></tr></table></figure><p>需要注意的是，自增自减运算符的结果要赋给一个变量，才能得到变化后的值。否则，变量的值不会被改变。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS配置：将域名连接到IP地址的关键步骤</title>
      <link href="/posts/59495.html"/>
      <url>/posts/59495.html</url>
      
        <content type="html"><![CDATA[<p>在互联网世界中，DNS（Domain Name System）是一项至关重要的技术，它将人们可读的域名转换为机器可理解的 IP 地址，为用户提供访问网站和服务的便利性。本文将介绍DNS配置的基本知识以及常见的配置方法，帮助你更好地理解和配置DNS。</p><h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 是一个分布式的命名系统，用于将域名转换为 IP 地址。在用户输入网址访问网站时，计算机将通过 DNS 查询来找到相应的 IP 地址，然后建立连接并获取网页内容。</p><h2 id="DNS配置的基本概念"><a href="#DNS配置的基本概念" class="headerlink" title="DNS配置的基本概念"></a>DNS配置的基本概念</h2><ol><li><p>域名注册：首先，你需要选择并注册一个域名，可以通过各大域名注册服务商进行购买和管理。</p></li><li><p>域名服务器（名称服务器）：域名服务器是存储和管理域名解析信息的服务器。当用户访问一个域名时，域名服务器将负责将域名解析为对应的 IP 地址。</p></li><li><p>DNS解析：DNS 解析是指将域名解析为 IP 地址的过程。它是通过查找域名服务器中存储的相关记录（如A记录、CNAME记录等）来进行的。</p></li></ol><h2 id="常见的DNS配置方法"><a href="#常见的DNS配置方法" class="headerlink" title="常见的DNS配置方法"></a>常见的DNS配置方法</h2><ol><li><p>A记录配置：A记录将域名直接映射到一个 IPv4 地址。在域名服务器的管理界面，创建一个A记录，设置域名和对应的IP地址，即可完成配置。</p></li><li><p>CNAME记录配置：CNAME记录允许将一个域名指向另一个域名。这在需要将多个域名指向同一个 IP 地址时非常有用。在域名服务器的管理界面，创建一个CNAME记录，设置域名和目标域名，即可完成配置。</p></li><li><p>MX记录配置：MX记录用于指定电子邮件服务器的地址。在域名服务器的管理界面，创建一个MX记录，设置邮件服务器的优先级和对应的域名或IP地址，即可完成配置。</p></li><li><p>TXT记录配置：TXT记录可以用于存储任意文本信息，常用于验证域名所有权、设置 SPF（发件人策略框架）等。在域名服务器的管理界面，创建一个TXT记录，并设置相应的文本信息，即可完成配置。</p></li><li><p>AAAA记录配置：AAAA记录用于将域名映射到一个 IPv6 地址。在域名服务器的管理界面，创建一个AAAA记录，设置域名和对应的IPv6地址，即可完成配置。</p></li></ol><h2 id="DNS配置生效时间及调试方法"><a href="#DNS配置生效时间及调试方法" class="headerlink" title="DNS配置生效时间及调试方法"></a>DNS配置生效时间及调试方法</h2><ol><li><p>DNS配置生效时间：DNS配置的生效时间可能需要一段时间（通常为数小时到一天），全球各地的 DNS 服务器需要时间来获取和更新新的配置。</p></li><li><p>DNS调试方法：可以使用 DNS 查询工具（如 Dig、Nslookup、mxtoolbox 等）进行 DNS 查询和调试，验证域名解析是否生效，并检查相关记录是否正确配置。</p></li></ol><p>DNS配置是构建互联网基础设施的关键步骤，通过正确配置和管理DNS，确保域名解析和服务访问的稳定性和可靠性。通过本文的介绍，你应该对DNS的基本概念和常见的配置方法有了初步了解，希望对你进行DNS配置提供一定的帮助。如果你想深入了解更多细节，可以参考相关文档和教程，或者咨询专业的DNS服务提供商。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升网站设计的绝佳选择：教你如何使用 FontAwesome 图标库</title>
      <link href="/posts/21975.html"/>
      <url>/posts/21975.html</url>
      
        <content type="html"><![CDATA[<h2 id="FontAwesome-简介"><a href="#FontAwesome-简介" class="headerlink" title="FontAwesome 简介"></a>FontAwesome 简介</h2><p>FontAwesome 是一个免费的开源图标库，拥有超过一万多个矢量图标供你使用。它以 CSS 和字体文件的形式提供图标，可以轻松地自定义图标的样式、大小、颜色和动画效果。</p><h2 id="使用-FontAwesome-的步骤"><a href="#使用-FontAwesome-的步骤" class="headerlink" title="使用 FontAwesome 的步骤"></a>使用 FontAwesome 的步骤</h2><ol><li><p>下载和引入 FontAwesome：首先，你需要在官方网站 (fontawesome.com) 上下载最新版本的 FontAwesome。解压文件，复制所需的 CSS 文件或字体文件到你的项目文件夹中。在 HTML 文件的 <code>&lt;head&gt;</code> 标签中引入 CSS 文件。</p></li><li><p>添加图标到你的网页：FontAwesome 提供了丰富的图标选择。在需要添加图标的地方，使用 <code>&lt;i&gt;</code> 或 <code>&lt;span&gt;</code> 标签，并添加相应的类名，例如 <code>&lt;i class=&quot;fas fa-heart&quot;&gt;&lt;/i&gt;</code>。这将在页面上显示一个带有心形图标的元素。</p></li><li><p>定制图标样式：FontAwesome 提供了多种方式来自定义图标的外观。通过添加额外的类名，可以更改图标的大小、颜色和样式。例如，要增加图标的大小，可以使用 <code>fa-lg</code> 或 <code>fa-2x</code> 类名。</p></li><li><p>添加动画效果：FontAwesome 还支持添加动画效果，使图标更加生动和引人注目。通过添加 <code>fa-spin</code> 类名，可以使图标旋转起来。还可以使用其他类名，如 <code>fa-pulse</code>（脉冲效果）和 <code>fa-pulse</code>（跳动效果）。</p></li></ol><h2 id="技巧和注意事项"><a href="#技巧和注意事项" class="headerlink" title="技巧和注意事项"></a>技巧和注意事项</h2><ol><li><p>参考 FontAwesome 文档：FontAwesome 提供详细的文档，包括图标的类名、使用示例和定制选项。参考官方文档可以帮助你更好地了解和使用 FontAwesome。</p></li><li><p>结合其他 CSS 框架或库：FontAwesome 可以与其他流行的 CSS 框架和库（如Bootstrap）无缝集成。通过结合使用，可以进一步扩展和定制你的图标效果。</p></li><li><p>考虑兼容性：在使用 FontAwesome 时，要考虑到不同浏览器和设备的兼容性。确保在不同的环境中，图标正常显示且不影响页面的加载和性能。</p></li></ol><p>FontAwesome 是一个强大而灵活的图标库，为网站设计带来了无限的可能性。通过掌握基本的使用步骤和技巧，你可以轻松地为你的网站添加优秀的图标效果，提升用户体验和设计质量。</p>]]></content>
      
      
      <categories>
          
          <category> HtmlCss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlCss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析Java变量：理解变量的本质与使用技巧</title>
      <link href="/posts/36533.html"/>
      <url>/posts/36533.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量的定义与声明"><a href="#变量的定义与声明" class="headerlink" title="变量的定义与声明"></a>变量的定义与声明</h2><p>在Java中，变量是用来存储数据的容器。在使用变量之前，需要先进行声明和定义。变量的声明指的是告诉编译器我们要使用一个变量，并指定变量的类型和名称。变量的定义指的是实际为变量分配内存空间，并可以给变量赋初值。</p><p>Java的变量名是由字母、数字、下划线（_）和美元符号（$）组成的，不能以数字开头，不能使用Java的关键字作为变量名。例如，下面是一个声明和定义一个整型变量的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>int</code>表示整型数据类型，<code>num</code>是变量的名称，<code>10</code>是变量的初值。</p><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><p>变量的作用域指的是变量在程序中可见和可访问的范围。在Java中，变量的作用域可以分为局部变量和成员变量两种。</p><p>局部变量是在某个特定的代码块（如方法、循环体）中定义的变量，它的作用域限制在该代码块内。当代码执行离开该代码块时，局部变量的内存空间会被释放。</p><p>成员变量是定义在类中的变量，它的作用域限制在整个类中。成员变量在对象创建时被分配内存空间，并在对象销毁时释放。</p><h2 id="变量的赋值和使用"><a href="#变量的赋值和使用" class="headerlink" title="变量的赋值和使用"></a>变量的赋值和使用</h2><p>在Java中，变量可以被赋值和使用。变量的赋值可以通过直接赋值、表达式赋值、方法返回值赋值等方式进行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getMax(a, b);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>a</code>变量直接赋值为10，<code>b</code>变量通过表达式<code>a + 5</code>赋值，<code>c</code>变量通过方法返回值赋值。</p><p>变量的使用可以通过变量名直接引用变量的值。例如，可以使用<code>System.out.println(a)</code>来打印变量<code>a</code>的值。</p><h2 id="变量的命名规范和约定"><a href="#变量的命名规范和约定" class="headerlink" title="变量的命名规范和约定"></a>变量的命名规范和约定</h2><p>良好的变量命名可以提高代码的可读性和可维护性。在命名变量时，应遵循以下规范和约定：</p><ol><li>变量名应具有描述性，能够清晰地表达变量的含义；</li><li>变量名采用驼峰命名法，即首个单词小写，后续单词首字母大写，不含下划线；</li><li>常量名使用全大写，并使用下划线分隔单词；</li><li>避免使用单个字符作为变量名，除非表示计数或临时变量。</li></ol><h2 id="变量的类型和转换"><a href="#变量的类型和转换" class="headerlink" title="变量的类型和转换"></a>变量的类型和转换</h2><p>Java中的变量有多种类型，包括整型、浮点型、字符型、布尔型等。不同类型的变量在存储和使用上有所区别，开发人员需要根据实际需求选择合适的变量类型。</p><p>在程序中，有时需要进行变量类型的转换。例如，将一个整型变量赋给浮点型变量时，会发生自动类型转换。而将一个浮点型变量赋给整型变量时，需要进行强制类型转换。</p><h2 id="常见变量错误和注意事项"><a href="#常见变量错误和注意事项" class="headerlink" title="常见变量错误和注意事项"></a>常见变量错误和注意事项</h2><p>在使用变量时，有一些常见的错误和需要注意的事项：</p><ol><li>变量使用前未初始化：在使用变量之前，要确保为其赋予初值，否则会导致编译错误；</li><li>变量作用域错误：在使用局部变量时，要注意其生命周期和作用域，避免超出范围的引用；</li><li>变量类型不匹配：在进行变量赋值和计算时，要确保类型匹配，避免编译错误或运行时异常。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探索Java引用数据类型：从基础到进阶</title>
      <link href="/posts/39770.html"/>
      <url>/posts/39770.html</url>
      
        <content type="html"><![CDATA[<p>Java是一门面向对象的编程语言，引用数据类型是其核心概念之一。在Java中，除了基本数据类型外，我们还会常常使用引用数据类型来表示复杂的数据结构和对象。本文将带你深入探索Java引用数据类型的基础知识，并介绍一些进阶的应用场景。</p><h2 id="引用数据类型的定义与声明"><a href="#引用数据类型的定义与声明" class="headerlink" title="引用数据类型的定义与声明"></a>引用数据类型的定义与声明</h2><p>引用数据类型是Java中用来表示对象、类和接口的数据类型。与基本数据类型（如int、double等）不同，引用数据类型在内存中存储的是对象的引用，而非对象本身。</p><p>在Java中，我们可以通过类名或接口名来声明一个引用变量。例如，声明一个<code>Person</code>类的对象引用变量可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person;</span><br></pre></td></tr></table></figure><p>这样的声明并不会在内存中实际创建对象，而只是为引用变量分配了存储空间，使得它可以引用一个<code>Person</code>类的对象。</p><h2 id="引用数据类型的初始化与赋值"><a href="#引用数据类型的初始化与赋值" class="headerlink" title="引用数据类型的初始化与赋值"></a>引用数据类型的初始化与赋值</h2><p>要创建一个具体的对象，需要使用<code>new</code>关键字来为引用变量实例化一个对象。例如，创建一个<code>Person</code>类的对象可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>上述代码中，<code>new Person()</code>创建了一个<code>Person</code>类的对象，并通过赋值操作将对象的引用赋给了<code>person</code>引用变量。</p><h2 id="引用数据类型的特性和操作"><a href="#引用数据类型的特性和操作" class="headerlink" title="引用数据类型的特性和操作"></a>引用数据类型的特性和操作</h2><p>引用数据类型在内存中存储的是对象的引用，通过引用变量可以访问和操作对象的属性和方法。例如，通过<code>person.getName()</code>可以获取<code>Person</code>对象的名称属性值。</p><p>与基本数据类型不同，引用数据类型的大小在内存中是固定的，无论对象本身的大小是多少。因为引用数据类型所占空间的大小与对象本身的大小无关，而是由引用变量的大小决定的。</p><h2 id="引用数据类型的内存管理"><a href="#引用数据类型的内存管理" class="headerlink" title="引用数据类型的内存管理"></a>引用数据类型的内存管理</h2><p>Java中的垃圾回收机制负责管理引用数据类型的内存。当一个对象不再被引用时，垃圾回收器会自动将其标记为垃圾，并进行内存回收。开发人员无需手动释放对象所占用的内存，这样一方面减轻了内存管理的负担，另一方面也避免了内存泄漏的问题。</p><p>需要注意的是，Java中的引用数据类型是存在空指针的可能性的。当一个引用变量没有指向任何对象时，它的值为<code>null</code>。使用空指针引用变量访问对象的属性或方法将导致空指针异常的发生。因此，在使用引用数据类型时，要注意进行空指针判断，以避免程序的异常终止。</p><h2 id="引用数据类型的进阶应用"><a href="#引用数据类型的进阶应用" class="headerlink" title="引用数据类型的进阶应用"></a>引用数据类型的进阶应用</h2><p>除了基本的使用方式外，引用数据类型还有许多进阶的应用场景。例如，使用数组来存储多个对象的引用，通过循环遍历数组可以批量操作对象；使用集合类来管理动态对象集合，提供更丰富的数据操作方法；使用泛型来提高代码的可重用性和类型安全性等等。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型揭秘：数据的奥义与转换技巧</title>
      <link href="/posts/33481.html"/>
      <url>/posts/33481.html</url>
      
        <content type="html"><![CDATA[<p>今天，让我们一起深入探索Java的基本数据类型，并详细了解它们的特点、取值范围以及适用场景。对于Java开发者来说，熟悉基本数据类型是编写高效和可靠代码的关键。现在就跟随我一同揭开Java基本数据类型背后的内幕吧！</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>在Java中，有四种整数类型：</p><ol><li><p>byte：占用1个字节，范围在-128至127之间。适用于节省内存的情况，如存储一个很小的整数值。</p></li><li><p>short：占用2个字节，范围在-32768至32767之间。适用于需要中等范围的整数值存储，如计数和数量。</p></li><li><p>int：占用4个字节，范围在-2147483648至2147483647之间。是Java中使用最广泛的整数类型，适用于大多数整数计算和变量存储。</p></li><li><p>long：占用8个字节，范围在-9223372036854775808至9223372036854775807之间。适用于特别大范围的整数值，如时间戳操作和位运算等。</p></li></ol><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>在Java中，有两种浮点数类型：</p><ol><li><p>float：占用4个字节，精度为7位有效数字。适用于存储较大的浮点数值，并且对精度要求不是十分严格的情况，如科学计算、图形处理等。</p></li><li><p>double：占用8个字节，精度为15位有效数字。是Java中使用最广泛的浮点数类型，适用于需要更高精度的浮点数计算，如财务计算、物理学等。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>在Java中，字符类型使用char来表示，占用2个字节。它用于存储单个字符，如字母、数字、标点符号等。可以用单引号括起来，例如：<code>char ch = &#39;A&#39;;</code>。字符类型适用于处理文本和字符操作，如密码输入、字符串处理等。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>Java的布尔类型用boolean来表示，只占用1个字节。它只有两个值：true（真）和false（假）。布尔类型适用于判断条件和控制流程，如条件判断、循环控制等。例如：<code>boolean isTrue = true;</code>。</p><h2 id="常量类型和字面常量"><a href="#常量类型和字面常量" class="headerlink" title="常量类型和字面常量"></a>常量类型和字面常量</h2><p>在Java中，常量类型指的是用final关键字声明的不可变的变量。常量类型可以是任何基本数据类型，并且在声明时必须进行初始化，并且初始化后不能再修改常量的值。例如：<code>final int MAX_VALUE = 100;</code>。</p><p>此外，还有字面常量，它们是直接写入代码的常量值。例如，整数常量<code>int num = 10;</code>、浮点数常量<code>float num = 3.14;</code>、字符常量<code>char ch = &#39;A&#39;;</code>、布尔常量<code>boolean isTrue = true;</code>等。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Java中，数据类型之间的转换分为两种类型：</p><ol><li><p>自动类型转换：当容量小的数据类型和容量大的数据类型进行运算时，会自动将小类型转换为大类型，以避免数据丢失。例如，int类型可以自动转换为long类型。</p></li><li><p>强制类型转换：当将容量大的数据类型赋值给容量小的数据类型时，需要进行强制类型转换。强制类型转换可能会导致数据精度的损失或溢出，需要谨慎使用。</p></li></ol><blockquote><p><a href="https://cheneyblog.com//posts/13247.html">数据类型转换的奥义</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Java数据类型：探索数据存储的多样性</title>
      <link href="/posts/41318.html"/>
      <url>/posts/41318.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是数据类型？"><a href="#什么是数据类型？" class="headerlink" title="什么是数据类型？"></a>什么是数据类型？</h2><p>在编程中，数据类型是用来声明变量和解释内存中存储数据的方式。Java是一种静态类型的编程语言，每个变量都需要被指定数据类型。数据类型决定了变量可存储的数据类型和所占用的内存空间。</p><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><p>Java提供了一组基本数据类型，用于存储简单的值。以下是Java的基本数据类型：</p><ol><li><p>整数类型：byte、short、int、long</p></li><li><p>浮点数类型：float、double</p></li><li><p>字符类型：char</p></li><li><p>布尔类型：boolean</p></li></ol><p>这些基本数据类型直接存储在内存中，具有固定的大小和取值范围。您可以根据需求选择最合适的数据类型。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>除了基本数据类型，Java还提供了引用数据类型，用于存储复杂的对象。引用数据类型包括类、接口、数组等，它们在内存中存储的是对象的引用。</p><ol><li><p>类：通过关键字<code>class</code>定义，可以包含属性（变量）和方法。</p></li><li><p>接口：通过关键字<code>interface</code>定义，声明了一组方法的规范。</p></li><li><p>数组：通过使用<code>[]</code>来声明，可以存储多个相同类型的元素。</p></li></ol><p>引用数据类型在内存中存储的是对象的地址，而不是实际的数据本身。这使得Java能够有效地管理和操作复杂的数据结构。</p><h2 id="常量和常量类型"><a href="#常量和常量类型" class="headerlink" title="常量和常量类型"></a>常量和常量类型</h2><p>除了变量，Java还提供了常量和常量类型。常量是不可修改的值，常量类型是指可以保存常量的数据类型。</p><ol><li><p>字面常量：直接写入代码的常量，如整数常量、浮点数常量、字符串常量等。</p></li><li><p>final常量：使用关键字<code>final</code>声明的常量，一旦赋值后就无法更改。</p></li><li><p>枚举常量：通过关键字<code>enum</code>声明的常量，用于定义一组有限的值。</p></li></ol><p>常量提供了在程序中使用不变值的方法，可以提高代码的可维护性和可读性。</p><h2 id="数据类型的选择和使用注意事项"><a href="#数据类型的选择和使用注意事项" class="headerlink" title="数据类型的选择和使用注意事项"></a>数据类型的选择和使用注意事项</h2><p>在选择和使用数据类型时，需要考虑以下因素：</p><ol><li><p>取值范围：选择合适的数据类型以确保变量能够存储所需的值范围。</p></li><li><p>内存占用：不同的数据类型占用不同大小的内存，应根据数据量和性能需求进行选择。</p></li><li><p>类型转换：在不同数据类型之间进行转换时，确保类型兼容，并注意数据丢失的可能性。</p></li><li><p>数据精度：浮点数类型的精度有限，需要注意精确计算时的误差问题。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java的基本数据类型、引用数据类型和常量类型，以及选择和使用数据类型的注意事项。</p><p>进一步学习Java数据类型，请阅读Java官方文档、Java编程书籍和在线教程，深入理解数据类型的细节和使用技巧。同时，通过编写代码和实践项目来锻炼自己的数据类型选择和使用能力。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密Java关键字：探索Java语言的特殊力量</title>
      <link href="/posts/29193.html"/>
      <url>/posts/29193.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是关键字？"><a href="#什么是关键字？" class="headerlink" title="什么是关键字？"></a>什么是关键字？</h2><p>在Java中，关键字是一组被保留并且具有特殊意义的标识符。这些关键字在Java编程语言中有特定的用途，不能用作标识符（比如变量、方法或类名）。Java关键字是由语言规范定义的，每个关键字都有其独特的功能和语法。</p><h2 id="常用的Java关键字"><a href="#常用的Java关键字" class="headerlink" title="常用的Java关键字"></a>常用的Java关键字</h2><ol><li><p>public、private、protected：访问修饰符，用于定义类、方法和变量的可访问性范围。</p></li><li><p>class、interface：用于声明类和接口。</p></li><li><p>extends、implements：继承和实现，用于实现类之间的继承和接口的实现。</p></li><li><p>static、final：用于定义静态成员和常量，可以通过类名直接访问。</p></li><li><p>void：用于方法签名中，表示方法没有返回值。</p></li><li><p>new、this、super：用于创建新对象、引用当前对象和引用父类对象。</p></li><li><p>if、else、switch、case、default：条件语句和分支控制关键字，用于控制程序的执行路径。</p></li><li><p>for、while、do-while：循环语句的关键字，用于重复执行一段代码。</p></li><li><p>break、continue：用于在循环或switch语句中改变程序的执行流程。</p></li><li><p>try、catch、finally：异常处理的关键字，用于捕获和处理异常。</p></li></ol><h2 id="特殊的关键字"><a href="#特殊的关键字" class="headerlink" title="特殊的关键字"></a>特殊的关键字</h2><p>除了常用的关键字外，Java还有一些特殊的关键字，具有特定的作用：</p><ol><li><p>native：用于标识本地方法，即由其他语言（如C、C++）实现的Java方法。</p></li><li><p>synchronized：用于实现线程安全的同步访问。</p></li><li><p>transient、volatile：用于定义变量的特殊属性，分别标识变量不被序列化和变量的可见性。</p></li><li><p>enum：用于定义枚举类型，提供一组有限的值。</p></li><li><p>package、import：用于声明包和导入类。</p></li></ol><h2 id="关键字的使用注意事项"><a href="#关键字的使用注意事项" class="headerlink" title="关键字的使用注意事项"></a>关键字的使用注意事项</h2><ol><li><p>大小写敏感：Java关键字是大小写敏感的，需以正确的大小写形式使用。</p></li><li><p>不作为标识符：关键字不能用作变量、方法、类名等标识符。</p></li><li><p>命名规范：建议避免与关键字同名的标识符，以免引起混淆和错误。</p></li><li><p>版本差异：Java的不同版本可能对关键字进行扩展或修改，需要根据使用的Java版本来选择适当的关键字。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java关键字的概念、常见的关键字以及一些特殊关键字。了解和正确使用Java关键字将使您更好地理解和编写Java代码。</p><p>进一步学习Java关键字的知识，您可以阅读Java官方文档、Java编程书籍和在线教程。此外，参与Java社区的讨论和交流也是提升自己的好方式。</p><p>在使用Java关键字时，请确保理解其用法和限制，并在编码过程中遵循最佳实践。通过不断的学习和实践，相信您将能够熟练掌握Java关键字，并在编程中发挥它们的特殊力量。</p><p>感谢各位读者的阅读，希望本文能为您提供有价值的Java关键字知识。愿您在编程的旅程中越走越远！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JDK：解锁编程之门，探索Java开发必备利器</title>
      <link href="/posts/55389.html"/>
      <url>/posts/55389.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Java-JDK？"><a href="#什么是Java-JDK？" class="headerlink" title="什么是Java JDK？"></a>什么是Java JDK？</h2><p>Java JDK是Java开发中的核心工具包，包含了一系列开发和运行Java应用程序所需的工具和库。它提供了编译、调试、运行和部署Java代码的功能，是Java开发的不可或缺的组成部分。</p><h2 id="为什么需要了解JDK？"><a href="#为什么需要了解JDK？" class="headerlink" title="为什么需要了解JDK？"></a>为什么需要了解JDK？</h2><p>了解JDK的重要性在于它对于Java开发的基础和核心功能提供了支持。以下是为什么要了解JDK的几个重要原因：</p><ol><li><p>编译和运行Java代码：JDK中包含了Java编译器（javac），可以将Java源代码编译成可执行的字节码文件。同时，JDK提供了Java Virtual Machine（JVM）来执行这些字节码文件。</p></li><li><p>开发工具和库：JDK提供了丰富的开发工具和库，包括调试器、性能分析工具、图形界面库等。这些工具和库能够提升您的开发效率和代码质量。</p></li><li><p>版本管理和兼容性：JDK的不同版本之间可能存在一些差异，了解各个版本的特性和变化对于代码的迁移和兼容性非常重要。</p></li></ol><h2 id="JDK版本介绍"><a href="#JDK版本介绍" class="headerlink" title="JDK版本介绍"></a>JDK版本介绍</h2><p>Java JDK经历了多个版本的演进和迭代，每个版本都引入了新的功能和改进。以下是几个常见的JDK版本：</p><ol><li><p>JDK 8：这个版本引入了很多重要的特性，如Lambda表达式、Stream API、新的Date/Time API等。</p></li><li><p>JDK 11：此版本是一个长期支持（LTS）版本，提供了新的特性和性能优化，同时降低了内存占用。</p></li><li><p>JDK 15：此版本引入了包括记录类型（Records）、Pattern Matching for instanceof等在内的多项新功能。</p></li></ol><h2 id="安装JDK的步骤"><a href="#安装JDK的步骤" class="headerlink" title="安装JDK的步骤"></a>安装JDK的步骤</h2><p>安装JDK是开始Java开发的第一步。以下是安装JDK的一般步骤：</p><ol><li><p>下载JDK安装包：您可以从Oracle官网（<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a>）下载合适的JDK安装包。</p></li><li><p>安装JDK：按照下载的安装包的指引执行安装操作。根据不同的操作系统，可能需要配置环境变量（如JAVA_HOME）以使JDK可用。</p></li><li><p>验证安装：安装完成后，可以在命令行运行<code>java -version</code>命令来验证JDK的安装是否成功。</p></li></ol><h2 id="学习资源和练习"><a href="#学习资源和练习" class="headerlink" title="学习资源和练习"></a>学习资源和练习</h2><p>学习Java开发需要不断学习和练习。以下是一些提升Java开发技能和知识的资源：</p><ol><li><p>官方文档和教程：Oracle官方提供了丰富的文档和教程，适合初学者入门和进阶学习。</p></li><li><p>在线课程和教学视频：诸如Coursera、Udemy、Codecademy等在线学习平台提供了许多Java开发相关的课程和教学视频。</p></li><li><p>开发工具和IDE：使用流行的开发工具和集成开发环境（IDE），如Eclipse、IntelliJ IDEA等，可以提供更多支持信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业数字化：引领未来商业发展的关键</title>
      <link href="/posts/64847.html"/>
      <url>/posts/64847.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><p>​  随着信息技术的飞跃发展，企业数字化已成为引领未来商业发展的关键要素。本文将探讨企业数字化的含义、重要性以及实施数字化转型的关键策略，旨在帮助企业把握数字化机遇，迈向全面发展的新高度。</p><h2 id="企业数字化的含义和重要性"><a href="#企业数字化的含义和重要性" class="headerlink" title="企业数字化的含义和重要性"></a>企业数字化的含义和重要性</h2><p>​  企业数字化是指将传统的商业活动以数字化方式进行，通过技术和网络平台来实现管理、运营和创新的转型过程。它涵盖了包括业务流程、组织结构、客户关系、市场营销等方面的数字化化改造，旨在提高效率、降低成本、提升竞争力。</p><p>​  企业数字化的重要性不可忽视。首先，数字化能够实现业务流程的高度自动化和集成化，提升企业的运营效率和灵活性。其次，数字化极大地扩展了企业的市场触角，打破了地域限制，带来全球范围内的商机和合作伙伴。再次，数字化为企业创新提供了无限可能，通过大数据分析和人工智能等技术手段，企业能够更加准确地洞察市场需求，开发出高质量的产品和服务。</p><h2 id="实施数字化转型的关键策略"><a href="#实施数字化转型的关键策略" class="headerlink" title="实施数字化转型的关键策略"></a>实施数字化转型的关键策略</h2><ol><li><p>制定清晰的数字化战略：企业需要明确数字化的目标和方向，制定可行的战略计划，并将其与企业的整体战略相衔接。数字化战略应该包括改造业务流程、优化组织结构、提升客户体验等方面。</p></li><li><p>投资适当的技术和平台：企业需要评估和选择适合自身需求的技术和平台，例如云计算、大数据分析、人工智能等。同时，企业还需要建立健全的信息技术基础设施，确保数字化转型的顺利进行。</p></li><li><p>建设高效的数字化团队：企业应该拥有一支专业的数字化团队，包括技术人员、数据分析师、数字营销专家等。这支团队能够推动数字化战略的实施，提供相关的技术支持和培训，确保数字化转型的成功。</p></li><li><p>提升组织文化和员工意识：企业数字化的成功还取决于组织文化和员工意识的转变。企业应该鼓励创新思维和信息共享，提供培训和奖励机制，激发员工参与到数字化转型中来。</p></li></ol><blockquote><p>Conclusion</p><p>企业数字化已经成为未来商业发展的不可或缺的一部分。通过实施数字化转型，企业能够提高效率、拓展市场、实现创新，并保持竞争优势。然而，在数字化转型的过程中，企业需要制定清晰的战略、选择适当的技术、建设强大的团队以及改变组织文化和员工意识。只有通过实施一系列的关键策略，企业才能在数字时代中立足并持续发展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Digitalize </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digitalize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Java开发的专有名词：掌握专有术语，驾驭编程世界！</title>
      <link href="/posts/4785.html"/>
      <url>/posts/4785.html</url>
      
        <content type="html"><![CDATA[<p>Java是一种广泛应用的编程语言，在Java开发中有一些必须了解的专有名词。对于初学者来说，这些名词可能有些陌生，但理解它们对于掌握Java开发是至关重要的。在本文中，我们将简单明了地介绍这些专有名词。</p><ol><li><p>JDK（Java Development Kit）<br>JDK是Java开发工具包，它是开发Java应用程序所必需的核心工具集。其中包括了编译器（用于将Java源代码编译为字节码）、调试器（用于调试程序）、类库（提供各种Java类和方法）等。JDK是开发Java应用程序的基石，必须安装和配置好才能开始编写Java代码。</p></li><li><p>JVM（Java Virtual Machine）<br>JVM是Java虚拟机，它是Java程序运行的环境。JVM会将Java字节码解释或编译成机器码，并执行程序。JVM具有跨平台特性，使得Java程序在不同的操作系统上能够运行。</p></li><li><p>OOP（Object-Oriented Programming）<br>OOP是面向对象编程的缩写，是一种编程范式。在Java中，一切都是对象，通过封装、继承和多态等概念，以对象为基本单位进行软件设计和开发。OOP使得代码更加模块化、可维护和可扩展。</p></li><li><p>IDE（Integrated Development Environment）<br>IDE是集成开发环境，它提供了一站式的开发工具。IDE包含代码编辑器、编译器、调试器和其他辅助工具，使得开发者可以更高效地编写、调试和测试代码。常见的Java IDE有Eclipse、IntelliJ IDEA等。</p></li><li><p>API（Application Programming Interface）<br>API是应用程序接口，它定义了软件组件之间的通信规范。通过API，开发者可以调用其他软件组件提供的方法和函数，访问其功能和数据。Java提供了丰富的API，包括图形界面、网络通信、数据库访问等方面。</p></li><li><p>MVC（Model-View-Controller）<br>MVC是一种软件架构模式，将应用程序分成三个核心部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据逻辑，视图负责展示数据和用户界面，控制器负责处理用户的输入和交互。这种分离有助于提高代码的可维护性和可扩展性。</p></li><li><p>Servlet<br>在Java Web开发中，Servlet是运行在服务器端的Java程序。它接收和处理HTTP请求，并生成响应。Servlet通常用于构建动态的Web应用程序，可以与HTML、CSS、JavaScript等前端技术结合使用。</p></li><li><p>JDBC（Java Database Connectivity）<br>JDBC是Java数据库连接，它是一种Java API，用于连接和操作数据库。通过JDBC，开发者可以与各种数据库建立连接，并执行SQL查询、更新等操作。JDBC给予开发者对数据库的灵活控制能力。</p></li></ol><p>了解这些专有名词对于Java开发者而言是非常重要的。它们是Java开发中的基础，深入学习和理解将有助于提高编程能力和开发效率。通过不断实践和探索，你会发现Java是一个强大而广泛应用的开发语言。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL执行过程</title>
      <link href="/posts/65435.html"/>
      <url>/posts/65435.html</url>
      
        <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202307291635919.png" alt="SQL语句执行流程图"></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>  用户在客户端输入执行SQL，该SQL语句通过session传输到服务器端，服务器通过Server Process接收SQL语句。客户端无需再做其他的操作，只是将SQL语句发送给服务端。</p><h3 id="查看Lib-Cache"><a href="#查看Lib-Cache" class="headerlink" title="查看Lib Cache"></a>查看Lib Cache</h3><p>  服务器进程在接到客户端传送过来的 SQL 语句后，不会直接去数据库查询。服务器进程会把这个 SQL 语句的字符进行转码，将转码后的值传递给一个 HASH 函数，并返回一个 hash 值，然后服务器进程将到 shared pool 的 library cache （高速缓存）中去查找是否存在相同的 hash 值。如果存在，服务器进程将使用这条语句已高速缓存在 library cache 中的已分析过的解析树和执行计划，省去后续的解析工作，这便是软解析。若高速缓存中不存在，则仍需要继续解析SQL、生成最佳执行计划，这便是硬解析，硬解析通常是昂贵的操作，大约占整个 SQL 执行的 70% 左右的时间。<br>​  所以，采用高速数据缓存的话，可以提高 SQL 语句的查询效率。其原因有两方面：一方面是从内存中读取数据要比从硬盘中的数据文件中读取数据效率要高，另一方面也是因为避免语句解析而节省了时间。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>  分析SQL语句的语法是否符合规范，如果服务器进程认为这条 SQL 语句不符合语法规则的时候，就会把这个错误信息反馈给客户端。在这个语法检查的过程中，不会对 SQL 语句中所包含的表名、列名等等进行检查，只是检查语法。</p><h3 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h3><p>  服务器进程接下去会对语句中涉及的表、索引、视图等对象进行解析，并对照数据字典检查这些对象的名称以及相关结构，看看这些字段、表、视图等是否在数据库中。如果存在问题的话，则数据库就会反馈错误信息给客户端。</p><h3 id="对象解析锁"><a href="#对象解析锁" class="headerlink" title="对象解析锁"></a>对象解析锁</h3><p>  系统会对我们需要查询的对象加锁，主要是为了保障数据的一致性，防止我们在查询的过程中，其他用户对这个对象的结构发生改变。</p><h3 id="权限核对"><a href="#权限核对" class="headerlink" title="权限核对"></a>权限核对</h3><p>  服务器进程还会检查连接用户是否有语句涉及对象的相关权限，若用户不具备相应权限的话则也会返回客户端。</p><h3 id="查询转换"><a href="#查询转换" class="headerlink" title="查询转换"></a>查询转换</h3><p>  视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>​  表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。</p><h3 id="选定执行计划"><a href="#选定执行计划" class="headerlink" title="选定执行计划"></a>选定执行计划</h3><p>  选择优化器，不同的优化器一般产生不同的“执行计划”。<br>​  选择连接方式，ORACLE有四种连接方式，对多表连接ORACLE可选择适当的连接方式。<br>​  选择连接顺序，对多表连接ORACLE选择驱动表和被驱动表。<br>​  选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>​  在生成的多个执行计划中，按统计信息带入，找出执行成本最小的执行计划，作为执行此SQL语句的执行计划。<br>​  将SQL文本、解析树、执行计划缓存到库缓存，存放地址以及SQL语句的哈希值，以便下次执行该SQL时可直接获取相关信息。</p><h2 id="语句执行"><a href="#语句执行" class="headerlink" title="语句执行"></a>语句执行</h2><h3 id="查询语句（Select）"><a href="#查询语句（Select）" class="headerlink" title="查询语句（Select）"></a>查询语句（Select）</h3><p>  首先服务器进程要判断所需数据是否在 db buffer 存在，如果存在且可用，则直接获取该数据而不是从数据库文件中去查询数据，同时根据 LRU 算法增加其访问计数；</p><p>  若数据不在缓冲区中，则服务器进程将从数据库文件中查询相关数据，并把这些数据放入到数据缓冲区中（ buffer cache ）。</p><p>  其中，判断数据的存在性和可用性检查方式为：查看 db buffer 块的头部是否有事务，如果有事务，则从回滚段中读取数据；如果没有事务，则比较 select 的 scn 和 db buffer 块头部的 scn ，如果前者小于后者，仍然要从回滚段中读取数据；如果前者大于后者，说明这是一非脏缓存，可以直接读取这个 db buffer 块的中内容。<br><strong>SQL Select语句完整的执行顺序</strong></p><ol><li>from子句组装来自不同数据源的数据；</li><li>where子句基于指定的条件对记录行进行筛选；</li><li>group by子句将数据划分为多个分组；</li><li>使用聚集函数进行计算；</li><li>使用having子句筛选分组；</li><li>计算所有的表达式；</li><li>使用order by对结果集进行排序；</li><li>执行select。</li></ol><h3 id="DML语句（Insert、Update、Delete）"><a href="#DML语句（Insert、Update、Delete）" class="headerlink" title="DML语句（Insert、Update、Delete）"></a>DML语句（Insert、Update、Delete）</h3><ol><li><p>检查所需的数据是否已经被读取到缓冲区中。如果已经存在缓冲区，则跳过第2部；</p></li><li><p>若所需的数据库并不在缓冲区缓存中，则服务器将数据块从数据文件读取到缓冲区中缓存；</p></li><li><p>对想要修改的表取得的数据行锁定（ Row Exclusive Lock ），之后对所需要修改的数据行取得独占锁；</p></li><li><p>将数据的 Redo 记录复制到 redo log buffer ；</p></li><li><p>产生数据修改的 undo 数据；</p></li><li><p>修改 db buffer ；</p></li><li><p>dbwr 将修改写入数据文件；</p></li></ol><h2 id="返回客户端"><a href="#返回客户端" class="headerlink" title="返回客户端"></a>返回客户端</h2><p>SQL语句被处理完成后Select语句会将查询结果返回给客户端，DML语句执行完后数据库会将对应的执行结果返回给客户端。最终客户端按照不同的方式呈现给用户。至此该SQL语句的生命周期完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> OracleSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDSQL For MySQL认证-单选题</title>
      <link href="/posts/3039.html"/>
      <url>/posts/3039.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.cdn.cheneyblog.com/blog/202307291510322.png" alt="关注公众号回复TDSQL认证获取更多资源"></p><ol><li><p>TDSQL(mysql)下列关于主键错误的是().</p><p>A. InnoDB表必须指定主键<br>B. 尽量游免更新主键字段<br>C. 如果存在多个唯一健，考虑最常用的唯一键作为主键<br>D. 主键值可以为空</p><blockquote><p>D. 主键值不可以为空，是错误的，应该修改为主键值不允许为空。</p><blockquote><p>在TDSQL中，主键是数据库表中的一个特殊字段，它的值必须是唯一的，且不允许为空，用来唯一标识一条记录。因此，选项D是错误的。选项A是正确的，在使用InnoDB存储引擎的表中，必须指定主键。选项B是正确的，尽量避免对主键字段进行更新操作，以减少索引维护的成本。选项C是合理的建议，根据最常用的唯一键作为主键可以提高查询效率和数据存储的规范性。</p></blockquote></blockquote></li><li><p>在mysql 中innodb引擎表T1，执行update t1 set a=2 where id =1；语句，id列有索引，下面描述正确的是（）.<br>A. 加表锁<br>B. 不加锁<br>C. 加行锁<br>D. 加字段锁</p><blockquote><p>C. 加行锁。</p><blockquote><p>在MySQL中，InnoDB引擎支持行级锁，当执行类似 <code>update t1 set a=2 where id =1</code> 的语句时，根据id列的索引，InnoDB引擎会为该行加上行锁。行锁是最细粒度的锁，只会锁定执行语句中涉及到的行，而不是整张表。这样可以避免不必要的锁竞争，提高并发性能。<br>如果涉及到多行数据的更新，InnoDB引擎会根据语句的执行计划，采用不同的锁策略。如果更新的行数少于等于当前隔离级别下的自增长值，那么会采用行锁；否则会采用表锁，避免出现死锁和性能下降的问题。因此，在具体的开发中需要根据实际情况进行测试和优化。</p></blockquote></blockquote></li><li><p>负责mysqld 进程存活检查并进行拉起的进程是（）.<br>A. Oc agent<br>B. Scheduer.<br>C. manager<br>D. hdfs</p><blockquote><p>B. Scheduler。</p><blockquote><p>MySQL是一个长时间运行的进程，如果因为某种原因意外退出，需要及时拉起，以保证服务的可用性。在腾讯云数据库TDSQL中，负责mysqld进程存活检查并进行拉起的进程是Scheduler。Scheduler是TDSQL的一个重要组件，它负责管理MySQL实例的启动、停止、重启、配置变更等操作，并通过监控Agent对MySQL进程进行存活检查，一旦发现MySQL进程异常退出，就会及时拉起，以保证服务的高可用性和可靠性。选项A的Oc agent是腾讯云的一种云原生容器服务，用于应用的容器化部署；选项C的manager和选项D的hdfs都与MySQL进程的运行管理没有直接的联系。</p></blockquote></blockquote></li><li><p>使用mysql客户端透传登方式录后，可以查看库中有哪些表是分表的语句是（）.<br>A. <code>/*proxy*/show table with shardkey;</code><br>B. <code>show shardkey tables;</code><br>C. <code>/*proxy*/show tables;</code><br>D. <code>/*proxy*/show shardkey tables;</code></p><blockquote><p>A. <code>/*proxy*/show table with shardkey;</code></p><blockquote><p>当使用MySQL客户端透传登方式登录到腾讯云数据库TDSQL分布式实例时，需要在SQL语句前加上注释<code>/*proxy*/</code>，以便将该SQL语句透传到分片节点执行。查看分表信息的语句是<code>show table with shardkey;</code>，加上透传登注释后即为<code>/*proxy*/show table with shardkey;</code>。该语句将返回数据库中所有分表的信息，包括表名、鉴别键类型、分表数量及分表的节点信息等。选项B和D的语法有误；选项C返回了所有表的信息，而不是分表的信息。</p></blockquote></blockquote></li><li><p>TDSQL 修改字段类型命令正确的是（）.<br>A. alter table t1 alter e varchar(20);<br>B. alter table t1 modify e varchar(30);<br>C. alter table t1.e modify varchar(30);<br>D. alter table t1.e alter varchar(30);</p><blockquote><p>B. alter table t1 modify e varchar(30);</p><blockquote><p>在腾讯云数据库TDSQL中，要修改表字段的数据类型，可以使用ALTER TABLE语句。正确的语法是<code>alter table 表名 modify 字段名 字段类型</code>，即选项B。该语句将修改t1表中e字段的类型为varchar(30)。选项A的语法错误，缺少modify关键字；选项C语法错误，应该为<code>alter table t1 modify e varchar(30)</code>；选项D的语法错误，应该为<code>alter table t1 modify e varchar(30)</code>。</p></blockquote></blockquote></li><li><p>使用mysql客户端登录TDSQL时，加哪个参数可以使用透传功能?<br>A. -a<br>B. -b<br>C. -c<br>D. -d</p><blockquote><p>C. <code>-c</code></p><blockquote><p>在使用MySQL客户端登录腾讯云数据库TDSQL时，如果要使用透传功能，需要在登录命令中添加<code>-c</code>参数。使用该参数后，在SQL语句中添加<code>/*proxy*/</code>注释，即可将该SQL语句透传给后端节点执行。例如，使用以下命令登录MySQL客户端，可以开启透传功能：<code>mysql -h hostname -u user -p -P port -c</code><br>其中，<code>hostname</code>是TDSQL实例的内网地址，<code>user</code>是数据库用户名，<code>port</code>是数据库端口，添加了<code>-c</code>参数后，就可以在SQL语句前添加<code>/*proxy*/</code>注释，实现透传功能。</p></blockquote></blockquote></li><li><p>当检测到死锁时，TDSQL InnoDB 存储引擎如何处理它们?<br>A. 两个受影响的事务都将回滚。<br>B. 受职响的事务等待inodb lock wait 超时，然后回滚。<br>C. 一个受影响的事务将回滚，另一个允许继续.<br>D. 事务隔离级别决定回滚哪个事务.</p><blockquote><p>C. 一个受影响的事务将回滚，另一个允许继续.</p><blockquote><p>答案解释如下：<br>A. 两个受影响的事务都将回滚<br>这个选项是错误的。当检测到死锁时，TDSQL InnoDB 存储引擎只需要选择一个牺牲者回滚，不需要把所有事务都回滚。回滚所有事务会导致所有事务的更改都被撤销，可能会导致严重的数据一致性问题。<br>B. 受影响的事务等待 InnoDB lock wait 超时，然后回滚<br>这个选项也是错误的。等待 InnoDB lock wait 超时的事务并不知道它是在等待死锁的解决。等待超时后可能会自行回滚事务，但如果其他事务继续增加锁等待，则问题仍将存在。<br>D. 事务隔离级别决定回滚哪个事务<br>这个选项是错误的。事务隔离级别影响并发操作的方式，但不会决定哪个事务应该被回滚。在 TDSQL 中，当 InnoDB 检测到死锁时，根据其自己的规则选择牺牲者回滚事务，而不考虑事务隔离级别。</p></blockquote></blockquote></li><li><p>存在表T1，有a，b，c三个字段，c 字段有普通索引，下面查询可以使用到索引的是（）.<br>A. <code>select * from t1 where b=1 and c=2</code><br>B. <code>select * from t1 where c+1=2</code><br>C. <code>select * from t1 where c like %2</code><br>D. <code>select * from t1 where c!=2</code></p><blockquote><p>A. <code>select * from t1 where b=1 and c=2</code></p><blockquote><p>B. <code>select * from t1 where c+1=2</code><br>这个查询中的 c + 1 表达式不能使用 c 列上的索引，因为这个表达式不是一个普通的列名。MySQL 在查询解析时，无法直接判断 c+1 表达式的结果。如果你想在查询中使用到 c 列上的索引，可以考虑修改查询条件或者采用 MySQL 的可计算列技术来实现。<br>C. <code>select * from t1 where c like %2</code><br>像前面所说的，因为 % 通配符是以 c 列值开头，且在查询计划时无法确定符合条件的数据行，因此不能使用 c 列上的索引。<br>D. <code>select * from t1 where c!=2</code><br>在这个查询中，该条件不能使用 c 列上的普通索引。这是因为对于索引来说，无法直接响应「不等于」操作符。如果你需要使用不等于查询，并且期望内部使用到索引来处理 WHERE 从句，你可以考虑使用覆盖索引或是使用聚簇索引。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）关于强同步策略描述正确的是?<br>A. 主机不等从机应答直接返客户端成功<br>B. 主机等待多数从机应答再返回客户端成功<br>C. 主机等待至少一台从机应答成功后才返回客户端成功<br>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>强同步策略需要确保每个从机节点都写入成功后，才返回给客户端成功，这就要求所有从机节点都要可用。虽然强同步策略能够提供最高的数据可靠性，但由于要等待所有从机节点写入成功后才能返回客户端成功，所以会增加写入时延，并且在高并发写入场景下可能会出现瓶颈，因此，应根据实际需求选择合适的同步策略。</p></blockquote></blockquote></li><li><p>MysQL查询哪些进程正在执行().<br>A. <code>show process;</code><br>B. <code>show processlist;</code><br>C. <code>list process;</code><br>D. <code>list processe;</code></p><blockquote><p>B. <code>show processlist;</code></p></blockquote></li><li><p>TDSQL（MySQL版）分布式支持哪种类型的表?<br>A. 分表<br>B. 单表<br>C. 广播表<br>D. 以上都支持</p><blockquote><p>D. 以上都支持</p><blockquote><p>A. 分表是指将一个表的数据按照某种方式拆分成多个表，分布到多个节点上。不同的节点上存储同一张表的不同分片，可以水平扩展表的存储和查询性能。TDSQL（MySQL版）支持分片表。<br>B. 单表是指一个库中只有一张表，这种表类型不涉及到分布式问题。任何一种数据库都支持单表。<br>C. 广播表是指将一个表的数据复制到所有的节点中，每个节点都有该表的完整数据。广播表主要用于数据量较小、对查询性能要求较高、且需要高可靠性的场景。TDSQL（MySQL版）同样支持广播表。</p></blockquote></blockquote></li><li><p>查看InnoDB内存参数设置的命今是（）.<br>A. <code>show variables like &quot;innodb%;</code><br>B. <code>show parameter like &quot;innodb%;</code><br>C. <code>list variables like &quot;innodb%;</code><br>D. <code>list parameter like inodb%;</code></p><blockquote><p>A. <code>show variables like &quot;innodb%;</code></p></blockquote></li><li><p>关于mysql 主从同步中Slave_IO_Running线程描述不正确的是.<br>A. 可以判断I/O线程是否被启动，并成功地连接到主服务器上。<br>B. 备库回放relay log的线程<br>C. 存在备库上面的线程<br>D. 接收到主库binlog 并写入中继日志的线程</p><blockquote><p>B. 备库回放relay log的线程</p><blockquote><p>备库回放 relay log 的线程是 Slave SQL Running 线程完成的。Slave SQL Running 线程是负责执行中继日志中的事件，将这些事件应用到备库上的线程，因此 B 选项描述是错误的。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）的路由信息是保存在哪里的?<br>A. 数据库中<br>B. Scheduler<br>C. Zookeper<br>D. oss</p><blockquote><p>C. Zookeper</p><blockquote><p>ZooKeeper 是一个分布式的、开放源代码的分布式应用程序协调服务，它是 TDSQL（MySQL版）中的重要组件，用于保存和管理集群中的元数据信息和路由信息，包括数据库实例的地址、分片和拆分等信息。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）分布式实例中哪些表只存在第一个set上?<br>A. 单表<br>B. 分表<br>C. 广播表<br>D. 所有表</p><blockquote><p>A. 单表</p></blockquote></li><li><p>TDSQL中自增字段描述正确的是（）.<br>A. TDSQL只保证在单个分片内部递增<br>B. TDSQL 可以保证在全局递增，但不是单调递增<br>C. TDSQL不支持自增字段<br>D. TDSQL 可以保证在全局严格单调递增</p><blockquote><p>B. TDSQL 可以保证在全局递增，但不是单调递增</p><blockquote><p>自增字段是一种在插入记录时自动递增的字段。在 TDSQL 中，自增字段可以使用 AUTO_INCREMENT 关键字来定义。当插入记录时，TDSQL 会为自增字段赋一个新值，以便保证每条记录都有唯一的值。<br>在 TDSQL 中，自增字段的递增方式取决于表的分片设置。如果表被水平分片到多个节点上，那么自增字段的递增方式可能是局部递增的，也就是说，在每个节点上自增字段的值都是递增的，但是不同节点上的自增字段值可能会重复。如果表没有被分片或者只被分片到一个节点上，那么自增字段的递增方式将是全局递增的。<br>需要注意的是，在 TDSQL 中，自增字段的递增方式并不一定是单调递增的。这是因为在分片环境下，不同节点上自增字段的值可能会有交错。然而，TDSQL 会保证自增字段在全局上是递增的，也就是说，每个自增字段的值都比之前插入的记录的自增字段的值大。</p></blockquote></blockquote></li><li><p>关于TDSQL 广播表说法正确的是（）?<br>A. 广播表可以将表数据均匀拆分到各个set<br>B. 广播表一般适合数据量较大的表<br>C. 广播表适合用于频繁更新的表<br>D. 广播表适用于更新较少的小表</p><blockquote><p>D. 广播表适用于更新较少的小表</p><blockquote><p>TDSQL 的广播表是将一个表完全复制到集群的所有 Set 上。数据拷贝是在数据变更时同步进行的，因此对数据的读写操作在所有 Set 上都是相同的。由于广播表在所有 Set 上都有完整副本，所以广播表能够提供非常高的查询性能，对于 join、group by 等操作尤为显著。<br>由于广播表拷贝的是完整的数据，所以其适用场景是数据量较小、更新较少的表，如一些配置表、元数据表等。这些表通常不会有太多的数据变动，可以在集群启动时快速拷贝所有数据，然后在之后的运行中进行读取操作。</p></blockquote></blockquote></li><li><p>查看MySQL服务进程是存在?<br>A. ps -ef|grep 端口号<br>B. fs -ef|grep 端口号<br>C. ns-ef|grep 端口号<br>D. ys-ef|grep 端口号</p><blockquote><p>A. ps -ef|grep 端口号</p><blockquote><p>ps命令可以列出当前所有进程的信息，包括进程ID（PID）、进程状态、运行时间等信息。通过grep命令可以过滤出包含指定端口号的进程。因此，在Linux或Unix系统中，可以通过ps -ef|grep 端口号命令来查看MySQL服务进程是否存在。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL)中主备数据一致性检查的工具是？<br>A. pt-online-schema-change<br>B. pt-pmp<br>C. pt-table-checksum<br>D. pt-mysql-summary</p><blockquote><p>C. pt-table-checksum</p><blockquote><p>pt-table-checksum是Percona Toolkit中的一个工具，可以检查MySQL主库和从库之间的数据一致性。它通过对比主库和从库的数据行数、校验和等信息，来确定两个库之间是否存在数据不一致的情况。如果发现不一致，就可以通过其他工具（例如pt-table-sync）来修复数据。因此，pt-table-checksum对于保证TDSQL（MySQL）主从数据一致性非常有用。</p></blockquote></blockquote></li><li><p>下面哪个命令可以通过透传的方式查看tdsql 集群的消息（）.<br>A. <code>show status;</code><br>B. <code>/*proxy*/show status</code><br>C. <code>/*proxy*/cluster status;</code><br>D. <code>/*cluster*/show status;</code></p><blockquote><p>B. <code>/*proxy*/show status</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> TDSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDSQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发学习路线</title>
      <link href="/posts/11880.html"/>
      <url>/posts/11880.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将为大家分享自学Java开发的学习路线，助力您步入编程的精彩世界。无论您是对编程感兴趣的新手，还是希望升级自己技能的开发者，本文将为您提供一份简明扼要的指南。让我们一起探索自学Java开发的学习之旅吧！</p><h2 id="掌握Java基础知识"><a href="#掌握Java基础知识" class="headerlink" title="掌握Java基础知识"></a>掌握Java基础知识</h2><p>Java是一门广泛应用的编程语言，熟练掌握其基础知识是成为合格Java开发者的第一步。以下是您应该着重学习的内容：</p><ol><li><p>语法基础：了解Java的关键词、数据类型、变量、运算符、流程控制等基本语法。</p></li><li><p>面向对象编程（OOP）：掌握类、对象、继承、多态、封装等OOP的核心概念。</p></li><li><p>Java集合框架：学习常用的集合类如List、Set、Map等，掌握它们的用法和特性。</p></li><li><p>异常处理：了解异常的概念、处理机制和异常处理的最佳实践。</p></li></ol><h2 id="深入学习Java核心技术"><a href="#深入学习Java核心技术" class="headerlink" title="深入学习Java核心技术"></a>深入学习Java核心技术</h2><p>除了基础知识外，了解Java核心技术将帮助您更全面地应用和理解Java开发。以下是您应该关注的主题：</p><ol><li><p>IO操作和文件处理：学习Java中的输入输出操作，包括文件读写、流操作、序列化等。</p></li><li><p>多线程编程：掌握多线程的概念、线程同步、锁机制等，以提高程序的并发性能。</p></li><li><p>网络编程：了解Socket编程、HTTP协议等，为构建网络应用打下基础。</p></li><li><p>数据库操作：学习Java与数据库的交互，掌握SQL语句的编写和数据库连接的使用方式。</p></li></ol><h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><p>Web开发是Java的一个重要应用领域。学习相关技术将带给您更广阔的发展前景。以下是您需要学习的内容：</p><ol><li><p>Servlet和JSP：了解Servlet的原理和用法，学习JSP的页面开发和动态内容生成。</p></li><li><p>Web框架：研究主流的Java Web框架，如Spring MVC、Struts等，掌握它们的工作原理和使用方式。</p></li><li><p>前端技术：学习HTML、CSS、JavaScript等前端技术，使您能够构建漂亮的用户界面。</p></li><li><p>数据库框架：掌握数据库框架，如Hibernate、MyBatis等，简化与数据库的交互操作。</p></li></ol><h2 id="提升开发效率"><a href="#提升开发效率" class="headerlink" title="提升开发效率"></a>提升开发效率</h2><p>成为一名高效的Java开发者，除了掌握核心技术外，还需要掌握一些工具和技巧：</p><ol><li><p>开发工具：熟练使用开发工具，例如Eclipse、IntelliJ IDEA等。熟悉调试技巧和代码重构。</p></li><li><p>版本控制：学习使用Git等版本控制工具，管理代码的版本和团队协作。</p></li><li><p>构建工具：了解Maven或Gradle等构建工具的使用，自动化依赖管理和项目构建。</p></li><li><p>测试与调试：学习单元测试和集成测试的方法，进行代码调试和性能优化。</p></li></ol><h2 id="实践与项目"><a href="#实践与项目" class="headerlink" title="实践与项目"></a>实践与项目</h2><p>在学习过程中，通过实践项目来应用所学知识是非常重要的。以下是一些建议：</p><ol><li><p>自主开发小项目：尝试独立完成一个小型项目，如个人博客、待办事项管理系统等，锻炼实际应用能力。</p></li><li><p>参与开源项目：加入开源社区，学习借鉴他人的经验，并为项目贡献自己的代码。</p></li><li><p>进行代码审查：与其他开发者交流，互相审查和改进代码，提高质量和可维护性。</p></li></ol><h2 id="持续学习和保持激情"><a href="#持续学习和保持激情" class="headerlink" title="持续学习和保持激情"></a>持续学习和保持激情</h2><p>Java发展日新月异，作为一名Java开发者，需要跟上技术的脚步。以下是一些持续学习的建议：</p><ol><li><p>阅读技术博客和书籍：关注Java技术的最新动态，通过阅读优秀的技术博客和书籍来不断学习。</p></li><li><p>参加技术交流活动：参加技术研讨会、开发者大会等活动，与其他开发者进行交流和分享经验。</p></li><li><p>学习新的技术领域：探索其他相关技术领域，如云计算、人工智能等，丰富自己的技能树。</p></li></ol><p>无论您的目标是在职场中找到更好的机会，还是追求个人技术成长，自学Java开发是一条值得追求的道路。相信通过持续的努力和实践，您将逐渐成为一名优秀的Java开发者。祝您在学习Java开发的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作手册</title>
      <link href="/posts/34671.html"/>
      <url>/posts/34671.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><ul><li><p>Hexo官网：<a href="https://hexo.io/zh-cn/">Hexo</a></p></li><li><p>Hexo是一款基于Node.js的静态网站生成器，可用于快速搭建个人博客或静态网站。</p></li></ul><h2 id="安装前配置"><a href="#安装前配置" class="headerlink" title="安装前配置"></a>安装前配置</h2><ol><li><p>Node.js</p><p>Hexo是基于Node.js开发的，因此需要先安装Node.js。</p><p>Node.js官方：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><p>Windows安装Node.js教程</p><iframe src="//player.bilibili.com/player.html?aid=412728509&bvid=BV11V411o7Zh&cid=177010975&page=1" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li><li><p>Git</p><p>如果您想使用Hexo主题或插件，可能需要使用Git进行下载和管理。</p><p>Git官网：<a href="https://git-scm.com/">Git (git-scm.com)</a></p><p>Windows安装Git教程</p><iframe src="//player.bilibili.com/player.html?aid=426532004&bvid=BV133411A7zU&cid=721246198&page=1" weight = 100% height = "500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol><h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><ol><li><p>打开命令行，使用npm安装Hexo<br><code>npm install hexo-cli -g</code></p></li><li><p>初始化Hexo<br>进入需要存放博客的目录，然后右键选择Git Bash Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init HenryCheney</span><br><span class="line"><span class="built_in">cd</span> HenryCheney</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>博客目录：G:\blog\HenryCheney</p></li><li><p>配置Hexo</p><p>进入博客目录，修改<code>_config.yml</code>文件以配置Hexo。在该文件中，你可以设置博客标题、描述、作者信息、主题、链接等内容。<br><img src="https://www.cdn.cheneyblog.com/blog/202307291429384.png" alt="博客配置"></p></li><li><p>编写文章<br><code>hexo new &quot;My New Post&quot;</code><br>新创建一个名为My New Post的文章存放在G:\blog\HenryCheney\source\_posts目录下</p></li><li><p>生成静态文件<br><code>hexo generate</code><br>简写：<code>hexo g</code></p></li><li><p>预览网站</p><p><code>hexo server</code><br>简写：<code>hexo s</code><br>然后在浏览器中访问<code>http://localhost:4000</code>，就可以访问到自己的博客了。</p></li><li><p>网站推送到GitHub<br>A. 首先安装hexo-deployer-git<br>   <code>npm install hexo-deployer-git --save</code><br>B. 修改 _config.yml 文件</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repository: git@github.com <span class="comment"># 仓库地址</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>C. 部署项目到GitHub</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><ul><li><p><code>hexo init [folder]</code><br> 初始化一个本地文件夹为网站的根目录<br> 如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p></li><li><p><code>hexo new [layout] &lt;title&gt;</code><br> 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p></li><li><p><code>hexo generate</code><br> 生成静态文件。<br> 该命令可以简写为<code>hexo g</code></p></li><li><p><code>hexo publish [layout] &lt;filename&gt;</code><br> 发表草稿。</p></li><li><p><code>hexo server</code><br> 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a><br> 简写：hexo s</p></li><li><p><code>hexo deploy</code><br> 部署网站<br> 简写：hexo d</p></li><li><p><code>hexo clean</code><br> 清除缓存文件 (db.json) 和已生成的静态文件 (public)<br> 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
