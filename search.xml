<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java开发学习指南：从入门到精通，掌握高效编程的利器！</title>
      <link href="/posts/16531.html"/>
      <url>/posts/16531.html</url>
      
        <content type="html"><![CDATA[<p>Java作为一门广泛应用的编程语言，其在企业级应用和软件开发领域拥有广泛的影响力。学习Java开发能够让你掌握高效编程的利器，并为你未来的职业发展提供坚实的基础。本文将持续为你提供一个全面的Java开发学习目录，帮助你系统地学习并掌握这一领域的知识和技能。</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li><a href="https://cheneyblog.com//posts/42473.html">Java简介</a></li><li><a href="https://cheneyblog.com//posts/4785.html">Java开发你必须了解的专有名词</a></li><li><a href="https://cheneyblog.com//posts/55389.html">解锁Java开发之JDK</a></li><li><a href="https://cheneyblog.com//posts/29193.html">Java关键字：“Foundation of Power”（权力基石）</a></li><li><a href="https://cheneyblog.com//posts/41318.html">解析Java数据类型</a></li><li><a href="https://cheneyblog.com//posts/33481.html">Java基本数据类型揭秘</a></li><li><a href="https://cheneyblog.com//posts/39770.html">探索Java引用数据类型</a></li><li><a href="https://cheneyblog.com//posts/36533.html">剖析Java变量</a></li><li><a href="https://cheneyblog.com//posts/37240.html">Java运算符：逻辑与算术的连接器</a></li><li><a href="https://cheneyblog.com//posts/42343.html">高效编程利器：Java流程控制</a></li><li><a href="https://cheneyblog.com//posts/37227.html">Java表达式：算与术的巧妙结合</a></li><li><a href="https://cheneyblog.com//posts/50102.html">Java数组：一种新的数据结构</a></li></ul><blockquote><p>持续更新中，敬请期待！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle开发学习指南：从入门到精通，打造高效数据库应用</title>
      <link href="/posts/50904.html"/>
      <url>/posts/50904.html</url>
      
        <content type="html"><![CDATA[<p>当涉及到Oracle开发学习，有一些关键的指南可以帮助你更好地掌握这个数据库管理系统。在本文中，我将向大家分享一些有关Oracle开发学习的重要指南。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li><a href="https://cheneyblog.com//posts/565.html">物理结构</a></li><li><a href="https://cheneyblog.com//posts/14901.html">内存结构</a></li><li><a href="https://cheneyblog.com//posts/35730.html">进程结构</a></li><li><a href="https://cheneyblog.com//posts/24947.html">逻辑结构</a></li><li><a href="https://cheneyblog.com//posts/47150.html">体系结构</a></li></ul><h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><ul><li><a href="https://cheneyblog.com//posts/65435.html">SQL语句执行过程</a></li></ul><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><ul><li><a href="https://cheneyblog.com//posts/20895.html">执行计划简介</a></li><li><a href="https://cheneyblog.com//posts/26508.html">Oracle统计信息</a></li><li><a href="https://cheneyblog.com//posts/32449.html">统计信息管理工具：DBMS_STATS包</a></li><li><a href="https://cheneyblog.com//posts/54365.html">获取执行计划</a></li><li><a href="https://cheneyblog.com//posts/12101.html">看懂执行计划之执行顺序</a></li><li><a href="https://cheneyblog.com//posts/20503.html">如何根据执行计划识别低效SQL</a></li><li><a href="https://cheneyblog.com//posts/24522.html">加速查询优化——深入了解Oracle Hint</a></li></ul><p>通过以上的指南，你可以更好地学习和掌握Oracle开发技能。无论是作为初学者还是有一定经验的开发者，这些指南都能够为你提供有价值的指导和帮助。祝你在Oracle开发学习的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Oracle数据库的综合体系结构与各组成部分的作用</title>
      <link href="/posts/47150.html"/>
      <url>/posts/47150.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>Oracle数据库作为一款强大的关系型数据库管理系统，具有复杂而完善的综合体系结构。这个体系结构由物理结构、内存结构、进程结构和逻辑结构组成，它们相互协作，共同为数据库提供高效的数据存储、管理和访问。本文将深入解析Oracle数据库的综合体系结构，探讨各组成部分之间的联系以及它们对数据库的影响与作用。</p></div><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构是指数据库在磁盘上的存储方式和组织形式。它涉及到数据文件、数据块、操作系统文件系统等层面的存储结构。物理结构的设计和调优对于数据库的性能和性能是至关重要的，它直接影响着数据的读取和写入速度，以及数据库的可靠性和可用性。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>内存结构是指Oracle数据库在内存中分配和管理的存储区域。它包括了共享池、数据库缓存、重做日志缓冲区等重要的内存组件。内存结构的设计和配置对于数据库的性能优化和响应速度具有重要影响。合理配置内存结构可以降低磁盘IO操作的频率，提升数据检索和事务处理的效率。</p><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>进程结构是指Oracle数据库的进程组成和协作方式。它包括了实例进程、后台进程和用户进程等多个进程。不同的进程负责着不同的任务和功能，它们相互配合，保证数据库实例的正常运行和对外服务的可用性。</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是指数据库中数据的组织方式和访问方法，如表空间、段、区和数据文件等。它决定了数据在数据库中的存储和访问方式。逻辑结构的设计和管理对于数据的安全性、一致性和有效性具有重要影响。有效的逻辑结构设计可以提高数据的查询效率和管理灵活性。</p><h2 id="各组成部分的联系与作用"><a href="#各组成部分的联系与作用" class="headerlink" title="各组成部分的联系与作用"></a>各组成部分的联系与作用</h2><p>这四个组成部分在Oracle数据库中密切联系，相互协作，共同为数据库的运行和管理提供支持。具体来说：</p><ul><li>物理结构和内存结构之间的联系：物理结构决定了数据在磁盘上的存储方式和布局，而内存结构则管理了数据在内存中的缓存和访问。它们之间的协作可以通过减少磁盘IO操作，加快数据的读取和写入速度，提升数据库的性能。</li><li>内存结构和进程结构之间的联系：内存结构中的共享池和数据库缓存等组件被进程共享和访问，进程通过内存结构来读取和处理数据。内存结构的优化和配置可以提升进程的查询和事务处理效率，从而加快数据库的响应速度。</li><li>进程结构和逻辑结构之间的联系：进程通过逻辑结构访问和操纵数据库中的数据，如表空间、段和区等。进程的操作和管理需要依赖于逻辑结构的定义和存在。逻辑结构的设计和管理直接影响着进程的执行和数据的操作。</li></ul><div class="note info simple"><p>综合体系结构是Oracle数据库运行和管理的基石，物理结构、内存结构、进程结构和逻辑结构相互联系、相互作用，为数据库提供了高效的存储、访问和管理能力。深入理解和综合运用各组成部分的知识和技术，可以帮助数据库管理员和开发人员更好地设计、调优和管理Oracle数据库，提升数据库的性能、可靠性和可用性，为企业提供卓越的数据库服务。希望本文的介绍对您理解Oracle数据库的综合体系结构和各组成部分的作用起到了指导和启发的作用。</p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的逻辑结构与数据组织方式</title>
      <link href="/posts/24947.html"/>
      <url>/posts/24947.html</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑结构图"><a href="#逻辑结构图" class="headerlink" title="逻辑结构图"></a>逻辑结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141411597.png" alt="Oracle逻辑结构图"></p><h2 id="表空间（Tablespace）"><a href="#表空间（Tablespace）" class="headerlink" title="表空间（Tablespace）"></a>表空间（Tablespace）</h2><p>表空间是 Oracle 最大的逻辑存储结构，与物理上的数据文件相对应，但是一个表空间可以拥有多个数据文件。</p><ul><li>数据表空间<br>用于存储用户数据的普通表空间。</li><li>系统表空间<br>默认的表空间，用于保存数据字典（一组保存数据库自身信息的内部系统表和视图，及用于 Oracle 内部使用的其他一些对象），保存所有的 PL/SQL 程序的源代码和解析代码，包括存储过程和函数、包、数据库触发器等，保存数据库对象（表、视图、序列）的定义。</li><li>回滚表空间<br>用于存放回滚段,每个实例最多只能使用一个撤销表空间</li><li>临时表空间<br>存储 SQL 执行过程中产生的临时数据</li></ul><h2 id="段（Segment）"><a href="#段（Segment）" class="headerlink" title="段（Segment）"></a>段（Segment）</h2><p>段是一组盘区，它是一个独立的逻辑存储结构，用于存储具有独立存储结构对象的全部数据。段一般是数据库终端用户处理最小的存储单位，当段的数据区已满，Oracle 为其分配另一个数据区，段的数据区在磁盘上可能是不连续的。</p><ul><li>数据段<br>用来存储表中所有数据；</li><li>索引段<br>用来存储表中索引的所有数据；</li><li>临时段<br>用于存储表排序或汇总时产生的临时数据</li><li>LOB 段<br>LOB 用来存储表中大型数据对象，例如 CLOB 与 BLOB</li><li>回退段<br>用于存储用户数据被修改之前的位置和值；<br>当要对用户的数据进行回退操作时，就要使用回退段。</li></ul><h2 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h2><p>区是 Oracle 存储分配的最小单位，它是由一个或多个数据块组成的。一个或多个区组成一个段，也就是说段的大小都是由区的个数来决定。当一个段的空间使用完之后，Oracle 会自动为该段分配成一个新的区。</p><p>用户还能够通过执行下面的命令来回收表、索引等对象中未使用的区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">deallocate</span> unused;</span><br></pre></td></tr></table></figure><h2 id="块（Block）"><a href="#块（Block）" class="headerlink" title="块（Block）"></a>块（Block）</h2><p>块是用来管理存储空间的最基本的单位，也是最小的逻辑存储单位。块的大小由初始化参数 db_block_size 来决定，不同的 Oracle 版本的大小是不同的，但是数据库一旦创建，其大小便不可更改。虽然每个数据块可以存储不同类型的数据，但是每个数据块都具有一个相同的结构。<br><img src="https://www.cdn.cheneyblog.com/blog/202309141412149.png" alt="块结构"></p><ul><li>块头<br>包含了该数据块一般的属性信息，如数据块的物理地址、所属段类型等</li><li>表目录<br>如果数据块中存储的数据是某个表的数据，则这里存放该表的信息</li><li>行目录<br>用来存储数据块中有效的行信息</li><li>空余空间<br>指数据块还没有使用的存储空间</li><li>行空间<br>表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的进程结构</title>
      <link href="/posts/35730.html"/>
      <url>/posts/35730.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-进程结构图"><a href="#Oracle-进程结构图" class="headerlink" title="Oracle 进程结构图"></a>Oracle 进程结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141407701.png" alt="Oracle 进程结构图"></p><h2 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h2><p>&emsp;&emsp;用户进程是一个与 Oracle 服务器进行交互的程序。一般的客户端软件，像 Oracle 的 sqlplus，sql developer,或者是一些驱动程序等等向数据库发送请求时即创建了用户进程。</p><h2 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h2><p>&emsp;&emsp;当监听程序监听到客户端来了一个请求，在创建会话时便会为其分配一个对应的服务器进程。服务器进程的主要作用就是处理连接到当前实例的用户进程的请求，对客户端发来的 sql 进行执行并返回执行结果。</p><h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>后台进程是 Oracle 数据库为了保持最佳系统性能和协调多个用户请求而设置的一系列后台进程。</p><h3 id="进程监控（PMON）"><a href="#进程监控（PMON）" class="headerlink" title="进程监控（PMON）"></a>进程监控（PMON）</h3><p>对故障的进程执行恢复操作，负责清理内存存储区和释放该进程所使用的资源<br>周期的检查调度进程和服务器进程的状态，对已死的进程进行重启</p><h3 id="系统监控（SMON）"><a href="#系统监控（SMON）" class="headerlink" title="系统监控（SMON）"></a>系统监控（SMON）</h3><p>当数据库实例出现故障或者系统崩溃的时候，执行恢复操作<br>定期合并字典管理的表空间中的空闲空间<br>在系统重启期间，清理表空间所有临时段<br>安装和打开数据库</p><h3 id="数据写入（DBWn）"><a href="#数据写入（DBWn）" class="headerlink" title="数据写入（DBWn）"></a>数据写入（DBWn）</h3><p>负责的将更新完的缓冲区数据写入磁盘中。以下情况发生时执行：</p><ul><li>没有可以写入的缓存空间</li><li>脏缓存达到限制（会导致搜索时间过长）1/4 满</li><li>最晚三秒钟：最晚三秒会执行一次写入</li><li>遇到检查点：遇到这个 checkpoint 便会执行写程序</li><li>表空间热备份的时候</li><li>表空间离线、只读状态</li><li>执行 Drop 操作的时候</li></ul><h3 id="日志写入（LGWR）"><a href="#日志写入（LGWR）" class="headerlink" title="日志写入（LGWR）"></a>日志写入（LGWR）</h3><p>将日志缓冲区的脏数据写进磁盘中 以下情况发生时执行：</p><ul><li>commit 写入</li><li>日志缓冲区占用率 1/3</li><li>DBWn 要写入脏缓冲区前</li></ul><h3 id="检查点进程（CKPT）"><a href="#检查点进程（CKPT）" class="headerlink" title="检查点进程（CKPT）"></a>检查点进程（CKPT）</h3><p>负责发起检查点信号，让 DBWn 开始工作<br>更新控制文件以及数据文件头</p><h3 id="归档进程（ACRn）"><a href="#归档进程（ACRn）" class="headerlink" title="归档进程（ACRn）"></a>归档进程（ACRn）</h3><p>将日志文件复制到归档日志文件中，来避免日志文件组的循环使用覆盖到已有的日志文件。<br>只有当数据库在 ARCHIVELOG 模式下，且自动归档开启的时候，系统便会启动 ARCn 进程；ARCn 包括归档方式和非归档方式。</p><h3 id="恢复器进程-RECO"><a href="#恢复器进程-RECO" class="headerlink" title="恢复器进程(RECO)"></a>恢复器进程(RECO)</h3><p>是一个用于分布式数据库配置的后台进程，它可以自动解决涉及分布式事务处理的故障。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的内存结构</title>
      <link href="/posts/14901.html"/>
      <url>/posts/14901.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-内存结构图"><a href="#Oracle-内存结构图" class="headerlink" title="Oracle 内存结构图"></a>Oracle 内存结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111341.png" alt="Oracle 内存结构图"></p><h2 id="System-Global-Aera-（SGA）"><a href="#System-Global-Aera-（SGA）" class="headerlink" title="System Global Aera （SGA）"></a>System Global Aera （SGA）</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111776.png" alt="SGA"></p><p>V$SGASTAT 视图提供有关 SGA 更详细的内存分配信息。</p><p>V$SGA 视图给出了系统全局区(System Global Area，SGA)内存结构的摘要信息。</p><h3 id="数据库缓存区（Database-Buffer-Cache）"><a href="#数据库缓存区（Database-Buffer-Cache）" class="headerlink" title="数据库缓存区（Database Buffer Cache）"></a>数据库缓存区（Database Buffer Cache）</h3><p>&emsp;&emsp;用于缓存当前或最近使用的从磁盘读取的数据块的拷贝，来优化数据库的 I/O 减少物理读/写。Oralce 依据 LRU 算法对该内存区域进行 block-level 的更新。数据高速缓存块又由以下几个缓存块组成：</p><ul><li>脏缓存块（Dirty buffers）<br>保存被修改过并且 commit 但未写入磁盘数据的缓存块，脏缓存块最终被 DBWn 进程写入到硬盘的数据文件中永久保存。</li><li>命中缓存块（Pinned buffers）<br>保存最近正在被访问的缓存块，始终被保留在数据高速缓存中，不会被写入数据文件。</li><li>空闲缓存块（Free buffers）<br>该缓存块中没有数据，等待被写入数据。oracle 从数据文件中读取数据后，寻找空闲缓存块，以便写入其中。</li></ul><h3 id="日志缓冲区（Redo-Log-Buffer）"><a href="#日志缓冲区（Redo-Log-Buffer）" class="headerlink" title="日志缓冲区（Redo Log Buffer）"></a>日志缓冲区（Redo Log Buffer）</h3><p>&emsp;&emsp;日志缓冲区是一块比较小的内存区域，它是用来短期存储将写入到磁盘中的重做日志信息。日志缓冲区也是为了减少磁盘 IO，减少用户的等待时间。</p><h3 id="共享池（Shared-Pool）"><a href="#共享池（Shared-Pool）" class="headerlink" title="共享池（Shared Pool）"></a>共享池（Shared Pool）</h3><ul><li><p>数据字典缓存区（Data Dictionary Cache）<br>用于存放 SQL 语句相关的数据文件、表、索引、列、用户、其他的数据对象的定义和权限信息等。</p></li><li><p>库缓存区（Librabry Cache）<br>共享 SQL 和 PL/SQL 代码。服务器进程在执行语句时，首先会匹配库缓存，如果存在相同语句则无需编译直接使用已编译的执行计划。<br>绑定变量不是在编译阶段赋值的，而是在运行阶段赋值的，因此含有绑定变量的 SQL 语句可以不用重新编译。</p></li><li><p>SQL 和 PL/SQL 结果缓存（Server Result Cache）<br>用于存储 SQL 查询或 PL/SQL 函数的结果，以加快其将来的执行速度。</p></li></ul><h3 id="大池（Large-Pool）"><a href="#大池（Large-Pool）" class="headerlink" title="大池（Large Pool）"></a>大池（Large Pool）</h3><p>&emsp;&emsp;大池是个可选的内存区域，可提供一个大的缓冲区供数据库的备份与恢复操作过程使用。数据库的备份恢复、执行具有大量排序操作的 SQL 语句、并行化的数据库操作时可能需要用到大池。</p><h3 id="Java-池（Java-Pool）"><a href="#Java-池（Java-Pool）" class="headerlink" title="Java 池（Java Pool）"></a>Java 池（Java Pool）</h3><p>&emsp;&emsp;JAVA 池在数据库中支持 JAVA 的运行，存放 JAVA 代码和 JAVA 语句的语法分析表。</p><h3 id="流池（Stream-Pool）"><a href="#流池（Stream-Pool）" class="headerlink" title="流池（Stream Pool）"></a>流池（Stream Pool）</h3><p>&emsp;&emsp;用于缓存流进程在数据库间移动/复制数据时使用的队列消息。一般从重做日志中提取变更记录的进程和应用变更记录的进程会用到流池。</p><h2 id="Program-Global-Aera-（PGA）"><a href="#Program-Global-Aera-（PGA）" class="headerlink" title="Program Global Aera （PGA）"></a>Program Global Aera （PGA）</h2><p>&emsp;&emsp;PGA 是指单个服务器进程或者单个后台进程所需的数据和控制信息。PGA 是在用户进程连接到数据库并创建一个会话时自动分配。该区域内保留每个与 oracle 数据库连接的用户进程所需的内存，当一个用户会话结束，PAG 就会释放。</p><ol><li>Private SQL area：包含绑定信息、运行时的内存结构。每个发出 sql 语句的会话，都有一个 private SQL area（私有 SQL 区）<br><strong>专有服务器连接私有 SQL 区在 PGA 中，共享服务器连接私有 SQL 区在 SGA 中。</strong></li><li>Session memory：为保存会话中的变量以及其他与会话相关的信息，而分配的内存区。</li></ol><ul><li>排序区<br>当用户需要对数据进行排序时，系统会将需要排序的数据保存到 PGA 中的排序区内，然后在这个排序区内对这些数据进行排序。如果发现用户的很多操作都需要用到排序，那么为用户设置比较大的排序区，可以提高用户访问数据的效率。</li><li>会话区<br>会话区保存了会话所具有的权限、角色、性能统计等信息，通常都是由数据库系统自我维护。</li><li>堆栈区<br>保存着绑定变量、会话变量、SQL 语句运行时的内存结构等重要的信息，通常都是由数据库系统自我维护</li><li>游标区<br>游标区是一个动态的区域，当用户执行游标语句打开游标时，系统会在 PGA 中创建游标区，当关闭游标时，这个区域就会被释放。创建与释放需要占用一定的系统资源，花费一定的时间，如果频繁的打开和关闭游标，就会降低语句的执行性能。</li></ul><h2 id="User-Global-Aera-（UGA）"><a href="#User-Global-Aera-（UGA）" class="headerlink" title="User Global Aera （UGA）"></a>User Global Aera （UGA）</h2><p>&emsp;&emsp;为用户进程存储会话状态。UGA 可以作为 SGA 或者 PGA 的一部分，如果通过一个共享服务器连接，UGA 包含在 SAG 中；如果通过一个专有服务器连接，UGA 就包含在专有服务器的 PGA 中。</p><h2 id="Software-code-areas"><a href="#Software-code-areas" class="headerlink" title="Software code areas"></a>Software code areas</h2><p>&emsp;&emsp;Oracle 存放自身软件代码的一部分内存区，不允许其他会话访问。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的物理结构：文件组织与作用详解</title>
      <link href="/posts/565.html"/>
      <url>/posts/565.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在Oracle数据库中，物理结构是数据库存储的基础，各种文件扮演着重要的角色。本文将为您深入介绍Oracle数据库的物理结构，特别是不同类型的文件以及它们的作用。我们将逐步介绍数据文件、控制文件、重做日志文件和参数文件，并详细解释这些文件在Oracle数据库中的重要性和功能。让我们一起来了解Oracle数据库中的物理结构与文件组织吧！</p></div><h2 id="数据文件（Data-file）"><a href="#数据文件（Data-file）" class="headerlink" title="数据文件（Data file）"></a>数据文件（Data file）</h2><p>数据文件是Oracle数据库中存储实际数据的文件。每个表空间在磁盘上都有一个或多个关联的数据文件，它们保存了表和索引的物理数据。数据文件的扩展名为.dbf。数据文件是Oracle数据库的核心组成部分。</p><h3 id="数据文件特性"><a href="#数据文件特性" class="headerlink" title="数据文件特性"></a>数据文件特性</h3><ol><li>每个数据文件对应一个数据库，一个数据库可以对应多个数据文件</li><li>数据文件可以自动扩展</li><li>数据文件专属于一个表空间，一个表空间可以拥有多个数据文件。</li></ol><h2 id="控制文件（Control-file）"><a href="#控制文件（Control-file）" class="headerlink" title="控制文件（Control file）"></a>控制文件（Control file）</h2><p>控制文件是Oracle数据库的重要组成部分，用于跟踪数据库的结构和状态。它记录了数据库的结构信息，包括数据文件、日志文件和数据库参数的位置和状态信息。控制文件还包含数据库的日志序列号，用于恢复和故障恢复。通常情况下，一个数据库有一个主控制文件和多个备用控制文件。</p><h2 id="重做日志文件（Redo-log-file）"><a href="#重做日志文件（Redo-log-file）" class="headerlink" title="重做日志文件（Redo log file）"></a>重做日志文件（Redo log file）</h2><p>重做日志文件（也称为事务日志文件）是用于保护数据库事务完整性和恢复的关键组件。重做日志文件记录了对数据库所做的所有更改，包括数据修改和结构变化。这些文件存储了对数据库的更改操作，以便在发生故障时进行恢复。重做日志文件通常以循环方式使用，即当一个日志文件被填满后，会切换到下一个日志文件。</p><h2 id="参数文件（Parameter-file）"><a href="#参数文件（Parameter-file）" class="headerlink" title="参数文件（Parameter file）"></a>参数文件（Parameter file）</h2><p>参数文件是Oracle数据库的配置文件，用于存储数据库的初始化参数设置。它包含了数据库的各种配置选项，如内存分配、日志记录级别、网络设置等。参数文件通常具有一个默认名称（如”init.ora”或”spfile.ora”），并且位于数据库实例的启动目录中。参数文件是在启动数据库实例时被读取和加载的。</p><h2 id="归档日志文件（Archived-Log-files）"><a href="#归档日志文件（Archived-Log-files）" class="headerlink" title="归档日志文件（Archived Log files）"></a>归档日志文件（Archived Log files）</h2><p>归档日志文件用来对写满的重做日志文件进行保存复制。其目的是为了长期保存日志以便于恢复。<br>数据库要运行归档模式下,如果数据不运行归档模式下,那么重做日志就循环覆盖写</p><h2 id="告警文件"><a href="#告警文件" class="headerlink" title="告警文件"></a>告警文件</h2><p>告警文件用于记录数据库启动后，用户操作上出现的问题或者数据库本身的问题，它时刻伴随着数据库。</p><div class="note info simple"><p>在Oracle数据库中，不同类型的文件起着关键的作用，确保数据库的正常运行和数据的完整性。从数据文件存储实际数据，到控制文件跟踪数据库的结构和状态，再到重做日志文件记录数据库的更改操作，以及参数文件存储数据库的各种配置选项，每个文件都具有独特的功能和重要性。了解文件的组织和作用对于维护和管理Oracle数据库至关重要。</p></div><p>希望本文的介绍能够帮助您更好地理解和应用Oracle数据库的物理结构，以及不同类型的文件在数据库中的作用。通过合理管理和配置这些文件，您可以确保数据库的稳定性和性能优化。祝您在使用Oracle数据库时取得更好的效果！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速查询优化——深入了解Oracle Hint</title>
      <link href="/posts/24522.html"/>
      <url>/posts/24522.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>引言：<br>在Oracle数据库中，查询性能的优化一直是DBA和开发人员关注的焦点。作为Oracle数据库的高级功能之一，Oracle Hint（提示）可以直接指导执行计划的生成，对于提高查询性能至关重要。</p></div><h2 id="什么是Oracle-Hint？"><a href="#什么是Oracle-Hint？" class="headerlink" title="什么是Oracle Hint？"></a>什么是Oracle Hint？</h2><p>Oracle Hint是一种以注释形式嵌入SQL语句中的指令，其目的是引导数据库优化器生成更优化的查询执行计划。通过使用Hint，我们可以直接干预执行计划的生成过程，以最大程度地提高查询性能。</p><h2 id="常用Hint"><a href="#常用Hint" class="headerlink" title="常用Hint"></a>常用Hint</h2><table><thead><tr><th>Oracle Hint</th><th>作用与使用场景</th></tr></thead><tbody><tr><td>ALL_ROWS</td><td>以最佳的性能获取所有行的方式进行查询</td></tr><tr><td>FIRST_ROWS(n)</td><td>指示优化器返回前n行结果，适用于需要快速返回部分结果的查询</td></tr><tr><td>INDEX(table_name index)</td><td>强制使用指定索引进行查询</td></tr><tr><td>FULL(table_name)</td><td>强制执行全表扫描，避免使用索引</td></tr><tr><td>ORDERED</td><td>强制按照查询中表出现的顺序连接表</td></tr><tr><td>USE_HASH(table_name)</td><td>强制使用哈希连接算法来连接表</td></tr><tr><td>USE_MERGE(table_name)</td><td>强制使用合并连接算法</td></tr><tr><td>LEADING(table_name)</td><td>指定连接的顺序</td></tr><tr><td>USE_CONCAT(table_name)</td><td>合并多个表的全表扫描</td></tr><tr><td>PARALLEL(table_name, n)</td><td>指示查询并行执行</td></tr><tr><td>INDEX_ASC(table_name)</td><td>强制使用升序索引进行查询</td></tr><tr><td>INDEX_DESC(table_name)</td><td>强制使用降序索引进行查询</td></tr><tr><td>PUSH_PRED(table_name)</td><td>提前将谓词推入到视图或子查询中进行评估</td></tr><tr><td>UNNEST(table_name)</td><td>对表的嵌套子查询进行展开</td></tr><tr><td>NO_MERGE(table_name)</td><td>禁止合并表达式计算</td></tr><tr><td>NO_PUSH_PRED(table_name)</td><td>禁止将谓词推入到视图或子查询中进行评估</td></tr><tr><td>USE_CUBE(table_name)</td><td>使用立方体优化进行查询</td></tr><tr><td>VECTOR_TRANSFORM(table_name)</td><td>使用向量转换技术进行查询</td></tr><tr><td>REWRITE(table_name)</td><td>使用查询重写技术进行优化</td></tr><tr><td>OPT_PARAM(‘optimizer_feature_enable’, ‘false’)</td><td>禁用特定的优化器功能</td></tr></tbody></table><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例子1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(orders order_date_idx) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2022-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上述查询中，我们使用Hint “INDEX(orders order_date_idx)”，强制优化器使用名为”order_date_idx”的索引来执行查询。这可以提高查询性能，尤其在处理大量数据时效果显著。</p><p>例子2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ PARALLEL(employees, 8) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “PARALLEL(employees, 8)”，指示优化器使用8个并行进程来执行查询，提高查询效率和并行处理能力。</p><p>例子3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(dept, emp) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments dept</span><br><span class="line"><span class="keyword">JOIN</span> employees emp <span class="keyword">ON</span> dept.department_id <span class="operator">=</span> emp.department_id;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “LEADING(dept, emp)”，强制优化器按照给定的连接顺序连接表，以达到更好的性能。</p><p>例子4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_HASH(customers, orders) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.customer_id <span class="operator">=</span> orders.customer_id;</span><br></pre></td></tr></table></figure><p>在以上查询中，我们使用Hint “USE_HASH(customers, orders)”，指示优化器使用哈希连接算法来连接customers表和orders表，以提升查询效率。</p><p>例子5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ OPT_PARAM(&#x27;optimizer_feature_enable&#x27;, &#x27;false&#x27;) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “OPT_PARAM(‘optimizer_feature_enable’, ‘false’)”，禁用特定的优化器功能，以便在特定情况下获得更好的查询性能。</p><h2 id="Hint使用规范"><a href="#Hint使用规范" class="headerlink" title="Hint使用规范"></a>Hint使用规范</h2><ol><li>谨慎使用：仅在需要进行特定优化时使用Hint，并在使用前进行全面测试和评估。</li><li>避免过度使用：过度使用Hint可能导致查询性能下降或不稳定。</li><li>Hint的适应性：使用Hint时要考虑数据库结构、数据规模和查询需求的特点，选择适应性强的Hint。</li><li>统计信息更新：使用Hint可能会影响优化器对表和索引的统计信息的收集和更新，应及时更新相关统计信息。</li><li>版本兼容性：不同版本的Oracle数据库对Hint的支持和效果可能有所差异，应根据具体版本权衡使用。</li></ol><blockquote><p>结语：<br>通过合理使用Oracle Hint，我们可以直接干预查询执行计划的生成过程，从而优化查询性能。在使用Hint时，我们需要根据实际需求和数据库环境进行选择和测试，并注意遵循使用Hint的最佳实践和注意事项。希望本文的介绍和示例能够帮助您更好地理解和应用Oracle Hint，并在优化查询性能的过程中取得更好的效果。祝您的查询性能优化顺利！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何根据执行计划识别低效SQL</title>
      <link href="/posts/20503.html"/>
      <url>/posts/20503.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309140949942.png" alt="总结1"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之执行顺序</title>
      <link href="/posts/12101.html"/>
      <url>/posts/12101.html</url>
      
        <content type="html"><![CDATA[<h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>  最右最上先执行</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>从上往下，第一个没有子节点的步骤先执行</li><li>对于兄弟节点，即靠上的节点先执行</li><li>所有兄弟节点执行完以后，执行父节点</li></ol><hr><ol><li>缩进最深的，最先执行</li><li>缩进深度相同的，先上后下</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>从上至下，从右向左</p><p>  由上至下：在执行计划中一般含有多个节点，相同级别(或并列)的节点，靠上的优先执行，靠下的后执行<br>  从右向左：在某个节点下还存在多个子节点，先从最靠右的子节点开始执行。</p><p>&emsp;&emsp;先从最开头一直连续往右看，直到看到最右边的并列的地方;对于不并列的，靠右的先执行;如果见到并列的，就从上往下看，对于并列的部分，靠上的先执行。</p><h2 id="格式化显示父子关系"><a href="#格式化显示父子关系" class="headerlink" title="格式化显示父子关系"></a>格式化显示父子关系</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, parent_id, operation</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> level lvl,</span><br><span class="line">               id,</span><br><span class="line">               parent_id,</span><br><span class="line">               lpad(<span class="string">&#x27; &#x27;</span>, level) <span class="operator">||</span> operation <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span> options <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span></span><br><span class="line">               object_name <span class="keyword">as</span> operation</span><br><span class="line">          <span class="keyword">from</span> plan_table</span><br><span class="line">         <span class="keyword">start</span> <span class="keyword">with</span> id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">connect</span> <span class="keyword">by</span> prior id <span class="operator">=</span> parent_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> lvl <span class="keyword">desc</span>, id;</span><br></pre></td></tr></table></figure><p>  该SQL必须同explain plan for 在同一个session（即同一个窗口执行）</p><h2 id="查看执行顺序工具"><a href="#查看执行顺序工具" class="headerlink" title="查看执行顺序工具"></a>查看执行顺序工具</h2><ul><li><p>PL/SQL Developer 快捷键 F5<br><img src="https://www.cdn.cheneyblog.com/blog/202309140926628.png" alt="示例"></p></li><li><p>XPLAN 包<br><img src="https://www.cdn.cheneyblog.com/blog/202309140927069.png" alt="XPLAN 包"><br><img src="https://www.cdn.cheneyblog.com/blog/202309140943310.png" alt="扫码获取xplan包"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划</title>
      <link href="/posts/54365.html"/>
      <url>/posts/54365.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取执行计划的方法"><a href="#获取执行计划的方法" class="headerlink" title="获取执行计划的方法"></a>获取执行计划的方法</h2><p><a href="https://cheneyblog.com//posts/16791.html">获取执行计划之 Autotrace</a><br><a href="https://cheneyblog.com//posts/21084.html">获取执行计划之 explain plan for</a><br><a href="https://cheneyblog.com//posts/8170.html">获取执行计划之 dbms_xplan.display_cursor()</a><br><a href="https://cheneyblog.com//posts/51893.html">获取执行计划之 dbms_xplan.display_awr()</a><br><a href="https://cheneyblog.com//posts/53050.html">获取执行计划之 10046 事件</a><br><a href="https://cheneyblog.com//posts/24823.html">获取执行计划之 10053 事件</a><br><a href="https://cheneyblog.com//posts/28768.html">获取执行计划之 AWR</a></p><h2 id="适用场合分析"><a href="#适用场合分析" class="headerlink" title="适用场合分析"></a>适用场合分析</h2><ol><li>简单获取执行计划的方法：explain plan for 或 set autotrace on</li><li>获取目标 SQL 的多个执行计划：dbms_xplan.display_cursor 或 AWR 报告</li><li>有函数，存在多层调用：10046 事件</li><li>表被访问次数：dbms_xplan.display_cursor 搭配 ALTER SESSION SET STATISTICS_LEVEL = ALL</li><li>获取真实执行计划：除 explain plan for 和 SET AUTOTRACE TRACEONLY EXPLAIN 外</li><li>dbms_xplan.display_cursor()与 set autotrace traceonly exp 的区别在于当 SQL 有绑定变量时，1 更准确(毕竟 sql 先执行再获取的执行计划)，2 可能不准确，其他情况下两者获取的执行计划基本一样</li></ol><h2 id="指标总结"><a href="#指标总结" class="headerlink" title="指标总结"></a>指标总结</h2><ol><li>sql 执行多次不改变 arraysize(一次提取操作在网络回路中传输的可能的数据行数)的情况下，每次的 consistent gets 不会变</li><li>sql 执行一次改变一次 arraysize 的情况下，每次的 consistent gets 会变，Arraysize 越大每次从数据块中获取的行数将得到提高，相同行数情况下，访问数据块的次数自然减小，逻辑读也就相应的降低。</li><li>arraysize 参数如果过低，会影响如 physical reads，consistent gets 还有 SQL*Net roundtrips to/from client 次数。</li><li>执行计划中的 Cost (%CPU)等于 v$sql_plan.COST</li><li>只是一个 select(非 select for update)时，db block gets 是 0</li></ol><blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309131548538.png" alt="总结1"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131550078.png" alt="总结2"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 AWR</title>
      <link href="/posts/28768.html"/>
      <url>/posts/28768.html</url>
      
        <content type="html"><![CDATA[<h2 id="AWR"><a href="#AWR" class="headerlink" title="AWR"></a>AWR</h2><p>&emsp;&emsp;AWR（Automatic Workload Repository 自动工作负载库）。AWR 报告是进行日常数据库性能评定、问题 SQL 发现的重要手段。可以自动采集 Oracle 运行中的负载信息，并生成与性能相关的统计数据。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;AWR 报告的原理是基于 Oracle 数据库的定时镜像功能。Oracle 数据库后台进程会以一定间隔收集系统的快照信息，并且保存在数据库中。AWR 通过比对两次快照收集到的统计信息来生成对应的报表数据。<br>AWR 来源：<code>V$ACTIVE_SESSION_HISTORY</code><br>AWR 开关参数：<code>CONTROL_MANAGEMENT_PACK_ACCESS</code><br>采样频率和保存时间配置表：<code>DBA_HIST_WR_CONTROL</code>。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>sqlplus 运行 awrrpt.sql 脚本</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>选择报告生成格式<br><img src="https://www.cdn.cheneyblog.com/blog/202309131531894.png" alt="报告生成格式"></p></li><li><p>选择生成报告日期，缺省值最近 7 天<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532123.png" alt="生成报告日期"></p></li><li><p>选择 snpID<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532557.png" alt="snpID"></p></li><li><p>选择报告保存路径以及名字，默认路径为当前 CMD 目录<br><img src="https://www.cdn.cheneyblog.com/blog/202309131533376.png" alt="AWR名称"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131534637.png" alt="awr完成"></p></li><li><p>根据上面的 awr 报告中，找出花费时间比较长的单条 sql 语句的执行计划<br><img src="https://www.cdn.cheneyblog.com/blog/202309131534339.png" alt="Elapsed Time"><br>我们这里以<strong>f7d3m1dh7bjkg</strong>为例</p></li><li><p>运行 awrsqrpt</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrsqrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>重复执行第二、三、四步</p></li><li><p>选择查看执行计划的 sql_id<br><img src="https://www.cdn.cheneyblog.com/blog/202309131535419.png" alt="sql_id"></p></li><li><p>默认名称生成对应 SQL 的执行计划</p></li></ol><h2 id="Awrsqrpt-报告详解"><a href="#Awrsqrpt-报告详解" class="headerlink" title="Awrsqrpt 报告详解"></a>Awrsqrpt 报告详解</h2><ul><li><p>SQL Summary<br>SQL 摘要包括 sql_id、执行时间、执行工具及 SQL 文本<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536846.png" alt="sql摘要"></p></li><li><p>SQL plan<br>SQL_ID 对应的执行计划，如果存在多个则会有多条记录，对应的 Plan Hash Value 不同<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536439.png" alt="sqlplan"></p></li><li><p>Plan Statistics<br>执行计划统计信息<br><img src="https://www.cdn.cheneyblog.com/blog/202309131537857.png" alt="plan_statistics"></p></li><li><p>Execution Plan<br>目标 SQL 对应执行步骤<br><img src="https://www.cdn.cheneyblog.com/blog/202309131538844.png" alt="Execution Plan"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_awr()</title>
      <link href="/posts/51893.html"/>
      <url>/posts/51893.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>  目标SQL的执行计划被Oracle采集到AWR Reponsitory中</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li><p>查看 <code>CONTROL_MANAGEMENT_PACK_ACCESS</code>、<code>STATISTICS_LEVEL</code> 参数</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARAMETER</span> control_management_pack_access</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> STATISTICS_LEVEL</span><br></pre></td></tr></table></figure><p> 以上两个参数用于控制诊断和调优包的使用<br> <code>CONTROL_MANAGEMENT_PACK_ACCESS</code> 应该被设置为 DIAGNOSTIC+TUNING 诊断和调优模式<br> DIAGNOSTIC 为确保启用自动数据库诊断监视器，包括 AWR、ADDM<br> TUNING 显示一 sql 推断信息和调优建议，包括 SQL Tuning Advisor,、SQLAccess Advisor</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> control_management_pack_access<span class="operator">=</span>&quot;DIAGNOSTIC+TUNING&quot;;</span><br></pre></td></tr></table></figure></li><li><p>执行测试 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查询 Shared Pool 中是否已经缓存了 <code>select count(1) from emp</code> 的执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131528480.png" alt="缓存记录"></p></li><li><p>手工收集 AWR 报告，清空 Shared Pool 缓冲池</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_workload_repository.create_snapshot();</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> flush shared_pool;</span><br><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131529745.png" alt="清空缓存池"></p></li><li><p>使用 dbms_xplan.display_awr(‘sql_id’)查看执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_awr(<span class="string">&#x27;9r5a71wx8rpr1&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><br>可以得到真实的执行计划</li><li><strong>缺点</strong><br>该方法不能显示谓词信息，是因为从 <code>V$SQL_PLAN</code> 导入 AWR 基表 <code>WRH$_SQL_PLAN</code> 时未将谓词字段 access_predicates 和 filter_predicates 导入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10053 事件</title>
      <link href="/posts/24823.html"/>
      <url>/posts/24823.html</url>
      
        <content type="html"><![CDATA[<h2 id="10053"><a href="#10053" class="headerlink" title="10053"></a>10053</h2><p>  10053事件提供了Oracle如何选择执行计划，为什么会得到这样的执行计划信息。<br>  10053事件的trace文件，只能阅读原始的trace文件，不能使用tkprof工具来处理。</p><h2 id="10053-事件级别"><a href="#10053-事件级别" class="headerlink" title="10053 事件级别"></a>10053 事件级别</h2><ul><li>Level 2<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li><li>Level 1<br>Parameters used by the optimizer<br>Index statistics<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li></ul><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>启用 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS<span class="operator">=</span><span class="string">&#x27;10053 trace name context forever, level 1&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>确定 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D.VALUE <span class="operator">||</span> <span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> <span class="built_in">LOWER</span>(RTRIM(I.INSTANCE, CHR(<span class="number">0</span>))) <span class="operator">||</span> <span class="string">&#x27;_ora_&#x27;</span> <span class="operator">||</span>P.SPID <span class="operator">||</span> <span class="string">&#x27;.trc&#x27;</span> <span class="keyword">AS</span> &quot;trace_file_name&quot;</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> P.SPID</span><br><span class="line"><span class="keyword">FROM</span> V$MYSTAT M, V$SESSION S, V$PROCESS P</span><br><span class="line">        <span class="keyword">WHERE</span> M.STATISTIC# <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> S.SID <span class="operator">=</span> M.SID</span><br><span class="line">        <span class="keyword">AND</span> P.ADDR <span class="operator">=</span> S.PADDR) P,</span><br><span class="line">    (<span class="keyword">SELECT</span> T.INSTANCE</span><br><span class="line">        <span class="keyword">FROM</span> V$THREAD T, V$<span class="keyword">PARAMETER</span> V</span><br><span class="line">        <span class="keyword">WHERE</span> V.NAME <span class="operator">=</span> <span class="string">&#x27;thread&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> (V.VALUE <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> T.THREAD# <span class="operator">=</span> TO_NUMBER(V.VALUE))) I,</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">VALUE</span> <span class="keyword">FROM</span> V$<span class="keyword">PARAMETER</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;user_dump_dest&#x27;</span>) D;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS <span class="string">&#x27;10053 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131449766.png" alt="10053"></p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10046 事件</title>
      <link href="/posts/53050.html"/>
      <url>/posts/53050.html</url>
      
        <content type="html"><![CDATA[<h2 id="10046"><a href="#10046" class="headerlink" title="10046"></a>10046</h2><p>&emsp;&emsp;10046 事件可以得到 Oracle 内部执行系统解析、调用、等待、绑定变量等详细的信息，可以帮助我们解析一条/多条 SQL、PL/SQL 语句的运行状态，这些状态包括：Parse/Fetch/Execute 三个阶段中遇到的等待事件、消耗的物理和逻辑读、CPU 时间、执行计划等，还能帮我们分析一些 DDL 维护命令的内部工作原理，RMAN、Data Pump Expdp/impdp 等工具缓慢问题。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context forever,level 12&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(m.sid),p.pid,p.tracefile <span class="keyword">from</span> v$mystat m,v$session s,v$process p <span class="keyword">where</span> m.sid<span class="operator">=</span>s.sid <span class="keyword">and</span> s.paddr<span class="operator">=</span>p.addr;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oradebug setmypid</span><br><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug tracefile_name</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131523044.png" alt="10046"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong></li></ul><ol><li>可以看出 sql 语句对应的等待事件</li><li>函数调用也会被列出</li><li>可以方便的看处理的行数，产生的逻辑物理读</li><li>可以方便的看解析时间和执行时间</li><li>可以跟踪整个程序包</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>步骤繁琐</li><li>无法判断表被访问了多少次</li><li>执行计划中的谓词部分不能清晰的展现出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_cursor()</title>
      <link href="/posts/8170.html"/>
      <url>/posts/8170.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>SQL执行计划仍在Shared Pool中</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBMS_XPLAN.DISPLAY_CURSOR(</span><br><span class="line">sql_id        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">child_number  <span class="keyword">IN</span>  NUMBER    <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">format        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="string">&#x27;TYPICAL&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>sql_id<br>指位于库缓存执行计划中 SQL 语句的父游标。默认值为 null。当使用默认值时当前会话的最后一条 SQL 语句的执行计划将被返回<br>可以通过查询 <code>V$SQL</code> 或 <code>V$SQLAREA</code> 的 SQL_ID 列来获得 SQL 语句的 SQL_ID。</li><li>child_number<br>指定父游标下子游标的序号。即指定被返回执行计划的 SQL 语句的子游标。默认值为 0。如果为 null，则 sql_id 所指父游标下所有子游标的执行计划都将被返回。</li><li>format<br>控制 SQL 语句执行计划的输出部分。</li></ul><h2 id="Format-参数详解"><a href="#Format-参数详解" class="headerlink" title="Format 参数详解"></a>Format 参数详解</h2><ul><li>官方输出格式<ol><li>BASIC: 显示最少的信息，只包括操作类型，ID 名称和选项。</li><li>TYPICAL: 默认值，显示相关信息以及某些附加的显示选项，如分区和并发使用等。</li><li>SERIAL: 与 TYPICAL 类型相似，区别是它不包括并发的信息，即使是并行执行的计划。</li><li>ALL: 显示最多的信息，包含了 TYPICAL 的全部以及更多的附加信息,如别名和远程调用等。</li></ol></li><li>附加输出格式（逗号和空格分隔来声明多个关键字，使用”+”和”-”符号来包含或排除相应的显示元素）<ol><li>ROWS – 显示被优化器估算的记录的行号</li><li>BYTES – 显示优化器估算的字节数</li><li>COST – 显示优化器计算的成本信息</li><li>PARTITION – 显示分区的分割信息</li><li>PARALLEL – 显示并行执行信息</li><li>PREDICATE – 显示谓语</li><li>PROJECTION – 显示列投影部分(每一行的那些列被传递给其父列已经这些列的大小)</li><li>ALIAS – 显示查询块名称已经对象别名</li><li>REMOTE – 显示分布式查询信息</li><li>NOTE – 显示注释</li><li>IOSTATS – 显示游标执行的 IO 统计信息</li><li>MEMSTATS – 为内存密集运算如散列联结，排序，或一些类型的位图运算显示内存管理统计信息</li><li>ALLSTATS – 与’IOSTATS MEMSTATS’等价</li><li>LAST – 显示最后执行的执行计划统计信息，默认显示为 ALL 类型，并且可以累积。</li></ol></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><code>dbms_xplan.display_cursor(null,null,&#39;advanced&#39;)</code> 仅用于 SQLplus 中查看刚执行过的 SQL 执行计划，在 PL/SQL Developer 中无法使用，因为工具在执行完 SQL 后还会执行其他的后台语句。</p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>  <code>dbms_xplan.display_cursor()</code>通常搭配<code>ALTER SESSION SET STATISTICS_LEVEL = ALL</code>或 <code>/*+ GATHER_PLAN_STATISTICS*/</code></p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131521485.png" alt="执行计划"></p><ol><li>starts：SQL 执行的次数；</li><li>E-Rows：执行计划预计返回的行数；</li><li>A-Rows：执行计划实际返回的行数；</li><li>A-Time：每一步执行的时间(HH:MM:SS.FF)，根据这一行可知 SQL 耗时在哪些地方；</li><li>Buffers：每一步实际执行的逻辑读或一致性读；</li><li>Reads：物理读；</li><li>OMem：OMem 为最优执行模式所需的内存评估值， 这个数据是由优化器统计数据以及前一次执行的性能数据估算得出的；</li><li>1Mem：1Mem 为 one-pass 模式所需的内存评估值，当工作区大小无法满足操作所需的大小时，需要将部分数据写入临时磁盘空间中(如果仅需要写入一次就可以完成操作，就称一次通过，One-Pass;否则为多次通过，Multi-Pass).该列数据为语句最后一次执行中，单次写磁盘所需要的内存大小，这个由优化器统计数据以及前一次执行的性能数据估算得出的</li><li>Used_Mem：Used-Mem 则为当前操作实际执行时消耗的内存，括号里面为(发生磁盘交换的次数,1 次即为 One-Pass,大于 1 次则为 Multi_Pass,如果没有使用磁盘，则显示 0)</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>可得到真实的执行计划</li><li>可以看出表被访问了多少次</li><li>可以通过 E-ROWS 和 A-RWS 得到预测行数和实际行数</li><li>Buffers 和 Reads 也可以显示真实的逻辑读和物理读</li></ol></li><li><strong>缺点</strong><ol><li>只有语句执行完毕才可以看到结果</li><li>看不出递归调用的次数</li><li>无法控制记录打屏输出</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 explain plan for</title>
      <link href="/posts/21084.html"/>
      <url>/posts/21084.html</url>
      
        <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br></pre></td></tr></table></figure><p>explain plan命令通常和dbms_xplan.display()命令结合使用<br>PL/SQL Developer里F5快捷键的原理就是调用explain plan命令</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;explain plan 命令的原理是 Oracle 将目标 SQL 所产生的执行计划写入 PLAN_TABLE$<br>（ON COMMIT PRESERVE ROWS 的 GLOBAL TEMPORARY TABLE 即会话级临时表仅对当前会话有效）然后再通过dbms_xplan.display()命令将PLAN_TABLE$中的具体执行步骤格式化显示出来</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>无需真正执行，快捷方便</li></ol></li><li><strong>缺点</strong><ol><li>没有输出相关统计信息</li><li>无法判断是处理了多少行</li><li>无法判断表被访问了多少次</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 Autotrace</title>
      <link href="/posts/16791.html"/>
      <url>/posts/16791.html</url>
      
        <content type="html"><![CDATA[<h2 id="Autotrace-简介"><a href="#Autotrace-简介" class="headerlink" title="Autotrace 简介"></a>Autotrace 简介</h2><pre><code>AUTOTRACE是一项SQL*Plus功能，自动跟踪为SQL语句生成一个执行计划并且提供与该语句的处理有关的统计。AUTOTRACE的好处是您不必设置跟踪文件的格式，并且它将自动为SQL语句显示执行计划。</code></pre><h2 id="Autotrace-选项说明"><a href="#Autotrace-选项说明" class="headerlink" title="Autotrace 选项说明"></a>Autotrace 选项说明</h2><table><thead><tr><th align="center">命令</th><th align="center">输出内容</th><th align="center">简写</th><th>是否真实执行</th></tr></thead><tbody><tr><td align="center">SET AUTOTRACE OFF</td><td align="center">缺省模式，只显示 SQL 执行结果</td><td align="center">SET AUTOT OFF</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE ON</td><td align="center">显示 SQL 结果、执行路径和资源消耗</td><td align="center">SET AUTOT ON</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY</td><td align="center">显示 SQL 结果数量、执行路径和资源消耗</td><td align="center">SET AUTOT TRACE</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY EXPLAN</td><td align="center">只显示 SQL 执行路径</td><td align="center">SET AUTOT TRACE EXP</td><td>Select 语句没有，DML 会被执行</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY STATISTICS</td><td align="center">只显示资源消耗</td><td align="center">SET AUTOT TRACE STAT</td><td></td></tr></tbody></table><h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309131518397.png" alt="统计信息"></p><table><thead><tr><th align="right">统计信息</th><th align="left">解释</th></tr></thead><tbody><tr><td align="right">recursive calls</td><td align="left">产生的递归 sql 调用的条数</td></tr><tr><td align="right">Db block gets</td><td align="left">从 buffer cache 中读取的 block 的数量</td></tr><tr><td align="right">consistent gets</td><td align="left">从 buffer cache 中读取的 undo 数据的 block 的数量</td></tr><tr><td align="right">physical reads</td><td align="left">从磁盘读取的 block 的数量</td></tr><tr><td align="right">redo size</td><td align="left">DML 生成的 redo 的大小</td></tr><tr><td align="right">bytes sent via SQL*Net to client</td><td align="left">数据库服务器通过 SQL*Net 向查询客户端发送的查询结果字节数</td></tr><tr><td align="right">bytes received via SQL*Net from client</td><td align="left">通过 SQL*Net 接受的来自客户端的数据字节数</td></tr><tr><td align="right">SQL*Net roundtrips to/from client</td><td align="left">服务器和客户端来回往返通信的 Oracle Net messages 条数</td></tr><tr><td align="right">sorts (memory)</td><td align="left">在内存执行的排序量</td></tr><tr><td align="right">sorts (disk)</td><td align="left">在磁盘上执行的排序量</td></tr><tr><td align="right">rows processed</td><td align="left">处理的数据的行数</td></tr></tbody></table><h2 id="Autotrace-优缺点"><a href="#Autotrace-优缺点" class="headerlink" title="Autotrace 优缺点"></a>Autotrace 优缺点</h2><ul><li><strong>优点</strong><ol><li>可以输出运行时的相关统计信息</li><li>有多种模式可供选择</li></ol></li><li><strong>缺点</strong><ol><li>必须要等 SQL 语句执行完，才出结果</li><li>无法看到表被访问了多少次</li><li>当存在绑定变量时执行计划可能不准</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解DBMS_STATS包：优化Oracle数据库统计信息管理</title>
      <link href="/posts/32449.html"/>
      <url>/posts/32449.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我来和大家分享关于Oracle数据库中DBMS_STATS包的相关知识，并通过举例详细介绍如何使用这个强大的工具包来优化数据库性能。DBMS_STATS包提供了一系列过程和函数，帮助我们管理统计信息，从而提升查询效率和数据库性能。</p><h2 id="收集统计信息"><a href="#收集统计信息" class="headerlink" title="收集统计信息"></a>收集统计信息</h2><p>首先，让我们通过一个例子来了解如何使用DBMS_STATS包收集表的统计信息。假设我们有一个名为”employees”的表，我们希望为该表收集统计信息。我们可以使用以下命令执行此操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_STATS.GATHER_TABLE_STATS(<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;EMPLOYEES&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中，’HR’为用户名，’EMPLOYEES’为表名。通过执行以上命令，DBMS_STATS包会收集’employees’表的统计信息，如行数、列的唯一值数量、索引信息等。</p><h2 id="自动收集统计信息"><a href="#自动收集统计信息" class="headerlink" title="自动收集统计信息"></a>自动收集统计信息</h2><p>除了手动收集，我们还可以让DBMS_STATS包自动定期收集统计信息，以确保数据库的最新性能。首先，我们需要创建一个统计信息收集作业。以下是一个创建作业的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_SCHEDULER.CREATE_JOB(</span><br><span class="line">      job_name        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_COLLECTION_JOB&#x27;</span>,</span><br><span class="line">      job_type        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;PLSQL_BLOCK&#x27;</span>,</span><br><span class="line">      job_action      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;BEGIN DBMS_STATS.GATHER_DATABASE_STATS(); END;&#x27;</span>,</span><br><span class="line">      start_date      <span class="operator">=</span><span class="operator">&gt;</span> SYSTIMESTAMP,</span><br><span class="line">      repeat_interval <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;FREQ=DAILY&#x27;</span>,</span><br><span class="line">      enabled         <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过这个作业，DBMS_STATS包将每天收集一次数据库的统计信息。</p><h2 id="导出和导入统计信息"><a href="#导出和导入统计信息" class="headerlink" title="导出和导入统计信息"></a>导出和导入统计信息</h2><p>另一个强大的功能是DBMS_STATS包支持统计信息的导出和导入。这在数据库升级、数据迁移或创建测试环境时非常有用。以下是一个导出统计信息的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.EXPORT_SCHEMA_STATS(</span><br><span class="line">      ownname      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;HR&#x27;</span>,</span><br><span class="line">      stattab      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_TABLE&#x27;</span>,</span><br><span class="line">      statid       <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;EMP_STATS&#x27;</span>,</span><br><span class="line">      statown      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_OWNER&#x27;</span>,</span><br><span class="line">      cascade      <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们将’HR’模式的统计信息导出到名为’STATS_TABLE’的表中。</p><h2 id="统计信息管理"><a href="#统计信息管理" class="headerlink" title="统计信息管理"></a>统计信息管理</h2><p>除了收集和导出统计信息，DBMS_STATS包还提供了其他管理功能。例如，我们可以使用以下命令锁定统计信息，防止其被自动收集或修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.LOCK_SCHEMA_STATS(<span class="string">&#x27;HR&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过上述命令，’HR’用户的统计信息将被锁定。</p><blockquote><p>总结：<br>DBMS_STATS包是Oracle数据库中一个强大的工具包，通过其提供的过程和函数，我们可以方便地收集、导出、导入和管理数据库对象的统计信息。深入了解和灵活应用DBMS_STATS包的知识，可以帮助我们优化数据库性能，提高查询效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle执行计划简介：优化数据库查询的关键</title>
      <link href="/posts/20895.html"/>
      <url>/posts/20895.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我来和大家分享关于Oracle数据库中执行计划的相关知识，执行计划在优化数据库查询中起着至关重要的作用。深入理解什么是执行计划以及它的选定依据，对于提高查询性能和数据库响应速度具有重要意义。</p><h2 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h2><p>执行计划是Oracle数据库根据查询语句、表、索引和统计信息等生成的一种执行路线图，它描述了数据库优化器在执行查询语句时的执行步骤和操作方式。执行计划包括了查询的访问方式、连接方式、操作顺序等关键信息。</p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131358420.png" alt="执行计划示例"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li><p>目标 SQL 的正文、sql_id 和执行计划对应的 plan_hash_value<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610746.png" alt="目标SQL的正文"></p></li><li><p>执行计划主体，主要有内部执行步骤、执行顺序、谓词信息、列信息、Cardinality、Cost 等<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610827.png" alt="执行计划主体"></p></li><li><p>执行计划的额外补充信息，是否动态采用（dynamic sampling）、是否 Cardinality Feedback、是否 SQL Profile<br><img src="https://www.cdn.cheneyblog.com/blog/202309131611503.png" alt="补充信息"></p></li></ol><h2 id="模块解读"><a href="#模块解读" class="headerlink" title="模块解读"></a>模块解读</h2><h3 id="主体-Header"><a href="#主体-Header" class="headerlink" title="主体 Header"></a>主体 Header</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131611458.png" alt="Header"></p><ul><li>ID：序号</li><li>Operation： 当前操作的内容</li><li>Rows： 当前操作的 Cardinality，Oracle 估计当前操作的返回结果集。</li><li>Cost：SQL 执行的代价</li><li>Time：Oracle 估计当前操作的时间</li></ul><h3 id="Query-Block-Name"><a href="#Query-Block-Name" class="headerlink" title="Query Block Name"></a>Query Block Name</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131612236.png" alt="Query Block Name"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Query Block Name <span class="operator">/</span> Object Alias (identified <span class="keyword">by</span> operation id):           <span class="comment">--这部分显示的为查询块名和对象别名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> SEL$<span class="number">1</span>                                                            <span class="comment">--SEL$为select 的缩写，位于块1,相应的还有DEL$,INS$,UPD$等</span></span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span>                                               <span class="comment">--DEPT@SEL$1，对应到执行计划中的操作ID为3上，即在表DEPT上的查询，DEPT为别名，下面类同</span></span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> EMP<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> J<span class="variable">@SEL</span>$<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Outline-Data"><a href="#Outline-Data" class="headerlink" title="Outline Data"></a>Outline Data</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613271.png" alt="Outline Data"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Outline Data                                                            <span class="comment">--提纲部分，这部分将执行计划中的图形化方式以文本形式来呈现，即转换为提示符方式</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*+</span></span><br><span class="line"><span class="comment">      BEGIN_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">      IGNORE_OPTIM_EMBEDDED_HINTS</span></span><br><span class="line"><span class="comment">      OPTIMIZER_FEATURES_ENABLE(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      DB_VERSION(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      ALL_ROWS</span></span><br><span class="line"><span class="comment">      OUTLINE_LEAF(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      INDEX(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; (&quot;DEPT&quot;.&quot;DEPTNO&quot;))                  --指明对于DEPT上的访问方式为使用索引</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                      --指明对于EMP上的访问方式为全表扫描</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      LEADING(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)        --指明前导表</span></span><br><span class="line"><span class="comment">      USE_MERGE(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                 --使用USE_MERGE提示，即MERGE SORT排序合并连接</span></span><br><span class="line"><span class="comment">      USE_HASH(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)                                    --使用USE_HASH提示，即HASH连接</span></span><br><span class="line"><span class="comment">      END_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="Predicate-Information"><a href="#Predicate-Information" class="headerlink" title="Predicate Information"></a>Predicate Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613212.png" alt="Predicate Information"></p><ul><li>Access</li></ul><ol><li>通过某种方式定位了需要的数据，然后读取出这些结果集，叫做 Access。</li><li>表示这个谓词条件的值将会影响数据的访问路劲（表还是索引）。</li></ol><ul><li>Filter</li></ul><ol><li>把所有的数据都访问了，然后过滤掉不需要的数据，这种方式叫做 filter 。</li><li>表示谓词条件的值不会影响数据的访问路劲，只起过滤的作用。</li></ol><h3 id="Column-Projection-Information"><a href="#Column-Projection-Information" class="headerlink" title="Column Projection Information"></a>Column Projection Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131614629.png" alt="Column Projection Information"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Column</span> Projection Information (identified <span class="keyword">by</span> operation id):             <span class="comment">--执行时每一步骤所返回的列，下面的不同步骤返回了不同的列</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br><span class="line">   <span class="number">2</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>]</span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> &quot;DEPT&quot;.ROWID[ROWID,<span class="number">10</span>], &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">5</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>], &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> &quot;J&quot;.&quot;JOB_NAME&quot;[VARCHAR2,<span class="number">50</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131615740.png" alt="Note"><br>&emsp;&emsp;动态采样（dynamic sampling）是 Oracle CBO 优化器的一种特性。如果相关数据表没有收集过统计量，又要使用 CBO 的机制，就会引起动态采样。</p><h2 id="执行计划的选定依据"><a href="#执行计划的选定依据" class="headerlink" title="执行计划的选定依据"></a>执行计划的选定依据</h2><p>在选择执行计划时，数据库优化器会考虑以下几个关键依据：</p><ol><li>统计信息：执行计划的选定依赖于表、索引和列的统计信息。这些统计信息包括表的行数、列的唯一值数目、索引的高度等。通过准确的统计信息，优化器能够评估不同执行计划的成本和效率，并选择最佳的执行路径。</li><li>查询语句和条件：执行计划的选定还考虑了查询语句和条件的影响。优化器会分析查询涉及的表、索引、连接方式以及查询条件的复杂性和选择性。根据这些因素，优化器会评估执行计划的成本和效率，以选择最佳的执行路径。</li><li>系统资源：执行计划的选定还会受到系统资源的限制和优化目标的影响。优化器会考虑系统可用的资源（例如CPU和内存）以及管理员设置的优化目标，以选择适当的执行计划，以平衡查询性能和系统负载。</li></ol><blockquote><p>总结：<br>执行计划在优化数据库查询性能中起着关键的作用。它能够帮助我们理解查询的执行过程、优化查询语句和提高数据库的响应速度。执行计划的选定依据主要包括统计信息、查询语句和条件，以及系统资源的限制和优化目标。通过深入理解和应用执行计划，我们能够更好地优化查询性能，提升数据库的整体效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升数据库性能的关键：Oracle统计信息</title>
      <link href="/posts/26508.html"/>
      <url>/posts/26508.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我想和大家分享关于数据库性能优化的重要方面之一：Oracle统计信息。在我们的应用程序中，数据库的性能直接影响着用户体验和系统的稳定性。而统计信息作为一种关键的工具，可以帮助我们更好地优化数据库性能。</p><h2 id="什么是统计信息？"><a href="#什么是统计信息？" class="headerlink" title="什么是统计信息？"></a>什么是统计信息？</h2><p>统计信息是数据库中关于表、索引和列的统计数据，用于优化查询计划的生成。Oracle数据库会定期收集这些统计信息，并据此进行优化决策，以提供最佳的查询性能。统计信息主要包括表的行数、列的唯一值个数、索引高度等。</p><h2 id="为什么统计信息如此重要"><a href="#为什么统计信息如此重要" class="headerlink" title="为什么统计信息如此重要"></a>为什么统计信息如此重要</h2><p>统计信息的准确性直接影响着查询的执行效率。如果统计信息不准确，数据库可能会选择错误的查询计划，导致查询性能下降甚至出现严重的性能问题。因此，及时收集和更新统计信息是提升数据库性能的关键步骤之一。</p><h2 id="如何收集统计信息"><a href="#如何收集统计信息" class="headerlink" title="如何收集统计信息"></a>如何收集统计信息</h2><p>Oracle提供了多种方式来收集统计信息：</p><ol><li>自动收集：Oracle会自动定期收集表的统计信息，可以通过设置相关参数来调整收集的频率和深度。</li><li>手动收集：可以使用DBMS_STATS包中的过程来手动收集统计信息，可以选择对整个数据库、表、索引或列进行统计信息的收集。</li><li>统计信息导入导出：可以将统计信息导出为统计信息的XML格式文件，然后在其他数据库中导入使用。</li></ol><h2 id="如何使用统计信息优化性能"><a href="#如何使用统计信息优化性能" class="headerlink" title="如何使用统计信息优化性能"></a>如何使用统计信息优化性能</h2><p>在收集统计信息后，Oracle优化器会根据统计信息进行查询计划的生成。有几点需要注意：</p><ol><li>统计信息的准确性：确保收集的统计信息准确无误，可以使用DBMS_STATS包提供的过程对统计信息进行评估和修正。</li><li>统计信息的更新：当表的数据发生较大变化时，需要及时更新统计信息，以保证优化器生成最新且最适合的查询计划。</li><li>数据库参数的设置：合理配置相关的数据库参数，如optimizer_mode、optimizer_index_cost_adj等，以便优化器更好地利用统计信息进行查询优化。</li></ol><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>大家可能注意到LAST_ANALYZED字段的取值，似乎时间有点早，不像每天都收集的样子，原来Oracle可以专门对表的记录变化量进行管理，当某表一天记录变化量没有超过指定的阈值时，Oracle就不会对该表进行统计信息收集，所以很多时候不少表被<br>第一次收集统计信息后，由于一直很少更新，故很少再有针对该表收集信息的动作。</p></div><blockquote><p>总结：<br>Oracle统计信息在数据库性能的优化中起着至关重要的作用。通过准确收集和更新统计信息，我们可以使数据库选择最佳的查询计划，从而提升查询性能。同时，定期的统计信息维护也是保证数据库长期稳定运行的重要环节。希望以上的内容对你们理解和应用统计信息有所帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组解析：探索数据存储与操作的利器</title>
      <link href="/posts/50102.html"/>
      <url>/posts/50102.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我们来深入探讨Java中的数组这一数据结构，它是数据存储与操作的利器。通过本文，我们将全面了解Java数组的特性和用法。</p><h2 id="数组的基础知识"><a href="#数组的基础知识" class="headerlink" title="数组的基础知识"></a>数组的基础知识</h2><p>数组是一种存储连续数据的结构，它由相同类型的元素组成。在Java中，数组的长度是固定的，一旦创建后，无法改变。每个元素都通过索引访问，索引从0开始。这个特性使得数组在很多编程任务中非常有用。</p><h2 id="数组的声明和初始化"><a href="#数组的声明和初始化" class="headerlink" title="数组的声明和初始化"></a>数组的声明和初始化</h2><p>在Java中，声明和初始化数组可以分为两步，首先声明数组变量，然后使用<code>new</code>关键字为数组分配内存并初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个整数数组</span></span><br><span class="line"><span class="type">int</span>[] numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个长度为5的整数数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化一个字符串数组</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简化的语法初始化一个字符数组</span></span><br><span class="line"><span class="type">char</span>[] vowels = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过指定数组的大小和类型，我们可以声明一个数组，然后使用<code>new</code>关键字为其分配内存空间。</p><h2 id="数组的访问和遍历"><a href="#数组的访问和遍历" class="headerlink" title="数组的访问和遍历"></a>数组的访问和遍历</h2><p>通过索引，我们可以访问数组中的元素。索引从0开始，最后一个元素的索引为数组长度减1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">firstNumber</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">// 访问数组的第一个元素</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">10</span>; <span class="comment">// 修改数组的第三个元素</span></span><br></pre></td></tr></table></figure><p>除了直接访问数组元素，我们还可以使用循环结构（如<code>for</code>循环或<code>foreach</code>循环）来遍历数组中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><p>Java提供了许多有用的数组操作方法。例如，我们可以使用<code>Arrays</code>类中的<code>sort()</code>方法对数组进行排序，使用<code>binarySearch()</code>方法查找元素，使用<code>copyOf()</code>方法复制数组等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们深入了解了Java数组的基础知识，包括声明和初始化、访问和遍历以及常见操作。数组作为一种重要的数据结构，广泛应用于各种编程场景。通过掌握数组的特性和用法，我们可以更加灵活地处理数据，并编写出高效的程序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧妙运用Java表达式：编程中的算术与逻辑之道</title>
      <link href="/posts/37227.html"/>
      <url>/posts/37227.html</url>
      
        <content type="html"><![CDATA[<p>作为一门广泛应用于软件开发领域的高级编程语言，Java为我们提供了丰富的表达式和操作符，使我们能够轻松进行算术计算和逻辑推理。在本文中，我们将深入探讨Java表达式的基础知识和技巧，帮助你在编程中更加熟练地使用这些强大的功能。</p><h2 id="算术表达式：实现精确计算"><a href="#算术表达式：实现精确计算" class="headerlink" title="算术表达式：实现精确计算"></a>算术表达式：实现精确计算</h2><p>在Java中，算术表达式用于进行数学运算，例如加法、减法、乘法和除法等。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> a - b; <span class="comment">// 减法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法</span></span><br></pre></td></tr></table></figure><p>另外，Java还提供了取模运算符（%），用于获取两个数相除的余数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><p>合理利用算术表达式的组合和嵌套，可以实现复杂的数学计算，并在编程中达到精确计算的目的。</p><h2 id="逻辑表达式：实现条件判断"><a href="#逻辑表达式：实现条件判断" class="headerlink" title="逻辑表达式：实现条件判断"></a>逻辑表达式：实现条件判断</h2><p>逻辑表达式在编程中非常重要，它用于实现条件判断和逻辑控制。我们常用的逻辑操作符有：</p><ul><li>逻辑与（&amp;&amp;）：当两个操作数都为true时，结果为true。</li><li>逻辑或（||）：当两个操作数中有一个为true时，结果为true。</li><li>逻辑非（！）：用于取反操作，将true变为false，将false变为true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFalse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> isTrue &amp;&amp; isFalse; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> isTrue || isFalse; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result3</span> <span class="operator">=</span> !isTrue; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>逻辑表达式通常与条件语句（如if语句）结合使用，根据条件的真假执行相应的逻辑操作。</p><h2 id="提高表达式的可读性和效率"><a href="#提高表达式的可读性和效率" class="headerlink" title="提高表达式的可读性和效率"></a>提高表达式的可读性和效率</h2><p>在编程中，良好的代码习惯对于表达式的编写非常重要。以下是一些有效的建议，可帮助提高表达式的可读性和效率：</p><ol><li><p>使用括号：使用括号明确表达式的执行顺序，避免歧义。</p></li><li><p>命名变量：使用有意义的变量名，使表达式更易理解。</p></li><li><p>避免过度复杂化：尽量避免编写过于复杂的表达式，以免降低代码的可读性和可维护性。</p></li><li><p>避免除数为0的情况：在进行除法操作时，务必考虑除数为0的异常情况。</p></li><li><p>使用短路求值：对于逻辑与（&amp;&amp;）和逻辑或（||）操作，利用短路求值的特性，可以提高代码的效率。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在编程中，掌握Java表达式的基础知识和技巧对于构建复杂的程序非常重要。通过灵活运用算术表达式，我们可以实现精确的数学计算；逻辑表达式则允许我们根据条件进行逻辑判断和流程控制。并且，良好的编码习惯和优化技巧可以提高代码的可读性和执行效率。</p><p>希望本文能为你提供关于Java表达式的详细解释和实践建议。通过深入学习和不断练习，相信你将能够熟练地使用Java表达式，并在编程过程中发挥其强大的功能。祝你编程愉快，取得优秀的成就！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程语言：优雅而强大的编程利器</title>
      <link href="/posts/42473.html"/>
      <url>/posts/42473.html</url>
      
        <content type="html"><![CDATA[<p>Java作为一门广泛应用于软件开发和企业级应用的编程语言，以其优雅的语法、强大的跨平台性能和丰富的生态系统而广受欢迎。本文将为您全面介绍Java的起源、特点和发展历程，带您走进这门受众众多开发者推崇的编程利器。</p><h2 id="起源和背景"><a href="#起源和背景" class="headerlink" title="起源和背景"></a>起源和背景</h2><p>Java诞生于20世纪90年代初，由Sun Microsystems的詹姆斯·高斯林（James Gosling）及其团队创作。当时，Sun Microsystems致力于开发一种能在家用电视和其他家电设备上运行的机器语言，他们让这个项目称为“绿色计划”。然而，由于电视技术的限制，这个项目没能实现，但是却为创建一种通用的编程语言奠定了基础。</p><h2 id="Java的特点与优势"><a href="#Java的特点与优势" class="headerlink" title="Java的特点与优势"></a>Java的特点与优势</h2><p>Java具备诸多独特的特点和优势，使它成为了如今广泛使用的编程语言之一：</p><ol><li><p>跨平台性：Java的最大特点之一是“一次编写，到处运行”。它的程序可以在各种操作系统上运行，如Windows、Mac、Linux等，这是通过Java虚拟机（JVM）实现的。</p></li><li><p>简单易学：Java采用了C++语言的面向对象编程理念，但去除了C++中的复杂和难以理解的部分。Java提供了清晰而易于理解的语法，使初学者也能够轻松入门。</p></li><li><p>安全性：Java注重安全性，它提供了一些机制用于防止程序中的潜在安全漏洞。Java的安全性主要通过Java安全管理器、类加载机制以及字节码验证等来实现。</p></li><li><p>面向对象：Java是一种纯面向对象的编程语言，它支持类、继承、多态等面向对象的特性。这种特点使得Java开发更加模块化、易于维护和扩展。</p></li><li><p>强大的生态系统：Java拥有丰富的类库和开发工具，比如Java标准库（Java API）提供了大量已经实现的类和方法，开发者可以直接使用这些类来实现复杂的功能。此外，Java还有大量的开源框架和工具，如Spring、Hibernate等，能够帮助开发者更高效地进行开发。</p></li></ol><h2 id="发展历程和应用领域"><a href="#发展历程和应用领域" class="headerlink" title="发展历程和应用领域"></a>发展历程和应用领域</h2><p>Java的成功得益于其出色的设计和适用性，在过去的几十年中不断发展壮大。</p><ol><li><p>初期发展（1995-2000）：Java 1.0发布后迅速引起了开发者们的关注，在互联网的应用和Web开发中得以迅速推广。Java Servlet和Java Server Pages（JSP）的引入使得Java在Web应用开发领域占据了重要的地位。</p></li><li><p>中期发展（2000-2010）：Java 2（J2SE）、Java 2 Enterprise Edition（J2EE）和Java 2 Micro Edition（J2ME）等版本陆续发布，Java的应用范围进一步扩大。同时，大型企业应用和金融系统中广泛采用Java，使其成为企业级应用的首选语言。</p></li><li><p>当代发展（2010至今）：Java 8的发布引入了函数式编程的特性，使得Java更加现代化和强大。Java继续保持其领先地位，广泛应用于大数据处理、云计算、物联网和移动应用等领域。</p></li></ol><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>随着技术的发展和需求的变化，Java仍然保持着强大的生命力。目前，Java继续推进语言和库的更新，提供更好的性能和安全性。同时，Java也在不断发展与演进，如引入模块化系统（Java模块化系统）和提供更好的开发工具支持等。</p><blockquote><p>总结：<br>Java是一门具备优雅语法和强大能力的编程语言，它的跨平台性、面向对象特性和丰富的生态系统使其得到了广泛应用。无论是开发大型企业级应用还是小型移动应用，Java都能为开发者提供可靠的解决方案。相信未来，在技术的推动下，Java将继续成为企业级开发和大规模系统构建的首选语言。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精通Java流程控制：玩转条件和循环，打造高效编程之路！</title>
      <link href="/posts/42343.html"/>
      <url>/posts/42343.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，流程控制是一种重要的技术，用于根据不同的条件执行不同的代码块，或者通过循环重复执行一段代码。掌握流程控制语句可以使程序更具灵活性和可控性。本文将深入探究Java流程控制的相关概念和应用。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句用于根据条件的成立与否决定是否执行某个代码块。Java中常用的条件语句有<code>if</code>语句、<code>if-else</code>语句和<code>switch</code>语句。</p><ol><li><p><code>if</code>语句</p><p> <code>if</code>语句用于在条件成立时执行某个代码块，语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>condition</code>是一个布尔表达式，当其结果为<code>true</code>时，执行代码块。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>if-else</code>语句</p><p> <code>if-else</code>语句用于在条件成立和不成立时分别执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行条件为true时的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行条件为false时的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num小于等于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>语句</p><p> <code>switch</code>语句用于根据不同的取值，执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 执行值为value1的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 执行值为value2的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 执行默认情况的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>expression</code>是一个表达式，根据其值来匹配不同的<code>case</code>。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行一段代码，直到某个条件不再成立。Java中常用的循环语句有<code>for</code>循环、<code>while</code>循环和<code>do-while</code>循环。</p><ol><li><p><code>for</code>循环</p><p> <code>for</code>循环用于在已知循环次数的情况下重复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>while</code>循环</p><p> <code>while</code>循环用于在条件成立时反复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>do-while</code>循环</p><p> <code>do-while</code>循环和<code>while</code>循环类似，不同之处在于它先执行一次循环体，然后在判断条件是否成立。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="流程控制的嵌套和跳转"><a href="#流程控制的嵌套和跳转" class="headerlink" title="流程控制的嵌套和跳转"></a>流程控制的嵌套和跳转</h2><p>在实际编程中，我们常常会在流程控制语句内部进行嵌套，以实现更复杂的逻辑。此外，Java还提供了跳转语句<code>break</code>和<code>continue</code>，用于跳出循环或跳过本次循环。</p><ul><li><code>break</code>语句用于跳出当前循环，结束循环执行。</li><li><code>continue</code>语句用于跳过本次循环，继续执行下一次循环。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<br>通过本文的介绍，我们深入探究了Java流程控制的相关概念和应用场景。条件语句和循环语句是实现程序流程控制的重要工具，能够根据不同的条件和需求，灵活地执行对应的代码块。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Java运算符：理解常用运算符及其应用场景</title>
      <link href="/posts/37240.html"/>
      <url>/posts/37240.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，运算符是一种用来进行数学、逻辑和位操作的符号。通过运算符，我们可以对数据进行各种计算和操作，完成复杂的逻辑判断和数据处理。本文将深入解析Java中常用的运算符，帮助你理解运算符的概念和使用场景。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用于执行基本的数学运算，包括加法、减法、乘法、除法、取模等。对于整型和浮点型变量，可以使用如下算术运算符：</p><ul><li><code>+</code> ：用于执行加法运算；</li><li><code>-</code> ：用于执行减法运算；</li><li><code>*</code> ：用于执行乘法运算；</li><li><code>/</code> ：用于执行除法运算；</li><li><code>%</code> ：用于执行取模（求余）运算。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">subtract</span> <span class="operator">=</span> a - b; <span class="comment">// 减法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符用于将一个值赋给变量。Java中的常用赋值运算符是<code>=</code>，表示将右边的值赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>a</code>变量被赋值为10，然后将<code>a</code>的值赋给了<code>b</code>变量。</p><p>另外，赋值运算符还有一些简化的形式，如<code>+=</code>、<code>-=</code>、<code>*=</code>等，表示将右边的值和左边的变量进行特定运算后再赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">num += <span class="number">10</span>; <span class="comment">// 等价于num = num + 10;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>num</code>的值先加上10，再赋给<code>num</code>。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符用于比较两个值之间的关系，返回一个布尔值（<code>true</code>或<code>false</code>）。常见的关系运算符包括：</p><ul><li><code>==</code> ：判断相等；</li><li><code>!=</code> ：判断不等；</li><li><code>&gt;</code> ：大于；</li><li><code>&lt;</code> ：小于；</li><li><code>&gt;=</code> ：大于等于；</li><li><code>&lt;=</code> ：小于等于。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (a &gt; b); <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符用于执行逻辑操作，常用的逻辑运算符有：</p><ul><li><code>&amp;&amp;</code> ：逻辑与运算符，当两个条件都为<code>true</code>时，返回<code>true</code>；</li><li><code>||</code> ：逻辑或运算符，当两个条件其中一个为<code>true</code>时，返回<code>true</code>；</li><li><code>!</code> ：逻辑非运算符，用于取反操作。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">condition1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">condition2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> condition1 &amp;&amp; condition2; <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符用于对整数类型的数据进行位操作，常见的位运算符包括：</p><ul><li><code>&amp;</code> ：按位与运算，对每一位进行与操作；</li><li><code>|</code> ：按位或运算，对每一位进行或操作；</li><li><code>^</code> ：按位异或运算，对每一位进行异或操作；</li><li><code>~</code> ：按位取反运算，对每一位进行取反操作；</li><li><code>&lt;&lt;</code> ：左移运算符，将二进制表示的数向左移动指定位数；</li><li><code>&gt;&gt;</code> ：右移运算符，将二进制表示的数向右移动指定位数。</li></ul><p>位运算符常用于处理二进制数据，例如位操作、图像处理、加密算法等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们深入解析了Java中常用的运算符，包括算术运算符、赋值运算符、关系运算符、逻辑运算符和位运算符。不同类型的运算符在不同的场景中发挥着重要的作用。灵活运用运算符，可以让我们更高效地进行数据处理、逻辑判断和位操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS配置：将域名连接到IP地址的关键步骤</title>
      <link href="/posts/59495.html"/>
      <url>/posts/59495.html</url>
      
        <content type="html"><![CDATA[<p>在互联网世界中，DNS（Domain Name System）是一项至关重要的技术，它将人们可读的域名转换为机器可理解的 IP 地址，为用户提供访问网站和服务的便利性。本文将介绍DNS配置的基本知识以及常见的配置方法，帮助你更好地理解和配置DNS。</p><h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 是一个分布式的命名系统，用于将域名转换为 IP 地址。在用户输入网址访问网站时，计算机将通过 DNS 查询来找到相应的 IP 地址，然后建立连接并获取网页内容。</p><h2 id="DNS配置的基本概念"><a href="#DNS配置的基本概念" class="headerlink" title="DNS配置的基本概念"></a>DNS配置的基本概念</h2><ol><li><p>域名注册：首先，你需要选择并注册一个域名，可以通过各大域名注册服务商进行购买和管理。</p></li><li><p>域名服务器（名称服务器）：域名服务器是存储和管理域名解析信息的服务器。当用户访问一个域名时，域名服务器将负责将域名解析为对应的 IP 地址。</p></li><li><p>DNS解析：DNS 解析是指将域名解析为 IP 地址的过程。它是通过查找域名服务器中存储的相关记录（如A记录、CNAME记录等）来进行的。</p></li></ol><h2 id="常见的DNS配置方法"><a href="#常见的DNS配置方法" class="headerlink" title="常见的DNS配置方法"></a>常见的DNS配置方法</h2><ol><li><p>A记录配置：A记录将域名直接映射到一个 IPv4 地址。在域名服务器的管理界面，创建一个A记录，设置域名和对应的IP地址，即可完成配置。</p></li><li><p>CNAME记录配置：CNAME记录允许将一个域名指向另一个域名。这在需要将多个域名指向同一个 IP 地址时非常有用。在域名服务器的管理界面，创建一个CNAME记录，设置域名和目标域名，即可完成配置。</p></li><li><p>MX记录配置：MX记录用于指定电子邮件服务器的地址。在域名服务器的管理界面，创建一个MX记录，设置邮件服务器的优先级和对应的域名或IP地址，即可完成配置。</p></li><li><p>TXT记录配置：TXT记录可以用于存储任意文本信息，常用于验证域名所有权、设置 SPF（发件人策略框架）等。在域名服务器的管理界面，创建一个TXT记录，并设置相应的文本信息，即可完成配置。</p></li><li><p>AAAA记录配置：AAAA记录用于将域名映射到一个 IPv6 地址。在域名服务器的管理界面，创建一个AAAA记录，设置域名和对应的IPv6地址，即可完成配置。</p></li></ol><h2 id="DNS配置生效时间及调试方法"><a href="#DNS配置生效时间及调试方法" class="headerlink" title="DNS配置生效时间及调试方法"></a>DNS配置生效时间及调试方法</h2><ol><li><p>DNS配置生效时间：DNS配置的生效时间可能需要一段时间（通常为数小时到一天），全球各地的 DNS 服务器需要时间来获取和更新新的配置。</p></li><li><p>DNS调试方法：可以使用 DNS 查询工具（如 Dig、Nslookup、mxtoolbox 等）进行 DNS 查询和调试，验证域名解析是否生效，并检查相关记录是否正确配置。</p></li></ol><p>DNS配置是构建互联网基础设施的关键步骤，通过正确配置和管理DNS，确保域名解析和服务访问的稳定性和可靠性。通过本文的介绍，你应该对DNS的基本概念和常见的配置方法有了初步了解，希望对你进行DNS配置提供一定的帮助。如果你想深入了解更多细节，可以参考相关文档和教程，或者咨询专业的DNS服务提供商。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升网站设计的绝佳选择：教你如何使用 FontAwesome 图标库</title>
      <link href="/posts/21975.html"/>
      <url>/posts/21975.html</url>
      
        <content type="html"><![CDATA[<p>在网站设计中，图标起着非常重要的作用，它们可以帮助传达信息、增加可视化吸引力和提升用户体验。本文将向你介绍如何使用 FontAwesome 这一流行的图标库，让你轻松地实现出色而引人注目的图标效果。</p><h2 id="FontAwesome-简介"><a href="#FontAwesome-简介" class="headerlink" title="FontAwesome 简介"></a>FontAwesome 简介</h2><p>FontAwesome 是一个免费的开源图标库，拥有超过一万多个矢量图标供你使用。它以 CSS 和字体文件的形式提供图标，可以轻松地自定义图标的样式、大小、颜色和动画效果。</p><h2 id="使用-FontAwesome-的步骤"><a href="#使用-FontAwesome-的步骤" class="headerlink" title="使用 FontAwesome 的步骤"></a>使用 FontAwesome 的步骤</h2><ol><li><p>下载和引入 FontAwesome：首先，你需要在官方网站 (fontawesome.com) 上下载最新版本的 FontAwesome。解压文件，复制所需的 CSS 文件或字体文件到你的项目文件夹中。在 HTML 文件的 <code>&lt;head&gt;</code> 标签中引入 CSS 文件。</p></li><li><p>添加图标到你的网页：FontAwesome 提供了丰富的图标选择。在需要添加图标的地方，使用 <code>&lt;i&gt;</code> 或 <code>&lt;span&gt;</code> 标签，并添加相应的类名，例如 <code>&lt;i class=&quot;fas fa-heart&quot;&gt;&lt;/i&gt;</code>。这将在页面上显示一个带有心形图标的元素。</p></li><li><p>定制图标样式：FontAwesome 提供了多种方式来自定义图标的外观。通过添加额外的类名，可以更改图标的大小、颜色和样式。例如，要增加图标的大小，可以使用 <code>fa-lg</code> 或 <code>fa-2x</code> 类名。</p></li><li><p>添加动画效果：FontAwesome 还支持添加动画效果，使图标更加生动和引人注目。通过添加 <code>fa-spin</code> 类名，可以使图标旋转起来。还可以使用其他类名，如 <code>fa-pulse</code>（脉冲效果）和 <code>fa-pulse</code>（跳动效果）。</p></li></ol><h2 id="技巧和注意事项"><a href="#技巧和注意事项" class="headerlink" title="技巧和注意事项"></a>技巧和注意事项</h2><ol><li><p>参考 FontAwesome 文档：FontAwesome 提供详细的文档，包括图标的类名、使用示例和定制选项。参考官方文档可以帮助你更好地了解和使用 FontAwesome。</p></li><li><p>结合其他 CSS 框架或库：FontAwesome 可以与其他流行的 CSS 框架和库（如Bootstrap）无缝集成。通过结合使用，可以进一步扩展和定制你的图标效果。</p></li><li><p>考虑兼容性：在使用 FontAwesome 时，要考虑到不同浏览器和设备的兼容性。确保在不同的环境中，图标正常显示且不影响页面的加载和性能。</p></li></ol><p>FontAwesome 是一个强大而灵活的图标库，为网站设计带来了无限的可能性。通过掌握基本的使用步骤和技巧，你可以轻松地为你的网站添加优秀的图标效果，提升用户体验和设计质量。</p>]]></content>
      
      
      <categories>
          
          <category> HtmlCss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlCss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析Java变量：理解变量的本质与使用技巧</title>
      <link href="/posts/36533.html"/>
      <url>/posts/36533.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，变量是一个非常基础和重要的概念。它可以用来存储和操作数据，是程序中的核心元素之一。本文将深入剖析Java变量的本质和使用技巧，帮助你更好地理解和运用变量。</p><h2 id="变量的定义与声明"><a href="#变量的定义与声明" class="headerlink" title="变量的定义与声明"></a>变量的定义与声明</h2><p>在Java中，变量是用来存储数据的容器。在使用变量之前，需要先进行声明和定义。变量的声明指的是告诉编译器我们要使用一个变量，并指定变量的类型和名称。变量的定义指的是实际为变量分配内存空间，并可以给变量赋初值。</p><p>Java的变量名是由字母、数字、下划线（_）和美元符号（$）组成的，不能以数字开头，不能使用Java的关键字作为变量名。例如，下面是一个声明和定义一个整型变量的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>int</code>表示整型数据类型，<code>num</code>是变量的名称，<code>10</code>是变量的初值。</p><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><p>变量的作用域指的是变量在程序中可见和可访问的范围。在Java中，变量的作用域可以分为局部变量和成员变量两种。</p><p>局部变量是在某个特定的代码块（如方法、循环体）中定义的变量，它的作用域限制在该代码块内。当代码执行离开该代码块时，局部变量的内存空间会被释放。</p><p>成员变量是定义在类中的变量，它的作用域限制在整个类中。成员变量在对象创建时被分配内存空间，并在对象销毁时释放。</p><h2 id="变量的赋值和使用"><a href="#变量的赋值和使用" class="headerlink" title="变量的赋值和使用"></a>变量的赋值和使用</h2><p>在Java中，变量可以被赋值和使用。变量的赋值可以通过直接赋值、表达式赋值、方法返回值赋值等方式进行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getMax(a, b);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>a</code>变量直接赋值为10，<code>b</code>变量通过表达式<code>a + 5</code>赋值，<code>c</code>变量通过方法返回值赋值。</p><p>变量的使用可以通过变量名直接引用变量的值。例如，可以使用<code>System.out.println(a)</code>来打印变量<code>a</code>的值。</p><h2 id="变量的命名规范和约定"><a href="#变量的命名规范和约定" class="headerlink" title="变量的命名规范和约定"></a>变量的命名规范和约定</h2><p>良好的变量命名可以提高代码的可读性和可维护性。在命名变量时，应遵循以下规范和约定：</p><ol><li>变量名应具有描述性，能够清晰地表达变量的含义；</li><li>变量名采用驼峰命名法，即首个单词小写，后续单词首字母大写，不含下划线；</li><li>常量名使用全大写，并使用下划线分隔单词；</li><li>避免使用单个字符作为变量名，除非表示计数或临时变量。</li></ol><h2 id="变量的类型和转换"><a href="#变量的类型和转换" class="headerlink" title="变量的类型和转换"></a>变量的类型和转换</h2><p>Java中的变量有多种类型，包括整型、浮点型、字符型、布尔型等。不同类型的变量在存储和使用上有所区别，开发人员需要根据实际需求选择合适的变量类型。</p><p>在程序中，有时需要进行变量类型的转换。例如，将一个整型变量赋给浮点型变量时，会发生自动类型转换。而将一个浮点型变量赋给整型变量时，需要进行强制类型转换。</p><h2 id="常见变量错误和注意事项"><a href="#常见变量错误和注意事项" class="headerlink" title="常见变量错误和注意事项"></a>常见变量错误和注意事项</h2><p>在使用变量时，有一些常见的错误和需要注意的事项：</p><ol><li>变量使用前未初始化：在使用变量之前，要确保为其赋予初值，否则会导致编译错误；</li><li>变量作用域错误：在使用局部变量时，要注意其生命周期和作用域，避免超出范围的引用；</li><li>变量类型不匹配：在进行变量赋值和计算时，要确保类型匹配，避免编译错误或运行时异常。</li></ol><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>通过本文的介绍，我们深入剖析了Java变量的本质和使用技巧。变量作为Java编程中的核心概念之一，对于掌握Java语言和编写优秀的代码具有重要意义。</p><p>良好的变量定义、命名和使用习惯能够提升代码质量和开发效率。希望本文对你理解和运用Java变量有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探索Java引用数据类型：从基础到进阶</title>
      <link href="/posts/39770.html"/>
      <url>/posts/39770.html</url>
      
        <content type="html"><![CDATA[<p>Java是一门面向对象的编程语言，引用数据类型是其核心概念之一。在Java中，除了基本数据类型外，我们还会常常使用引用数据类型来表示复杂的数据结构和对象。本文将带你深入探索Java引用数据类型的基础知识，并介绍一些进阶的应用场景。</p><h2 id="引用数据类型的定义与声明"><a href="#引用数据类型的定义与声明" class="headerlink" title="引用数据类型的定义与声明"></a>引用数据类型的定义与声明</h2><p>引用数据类型是Java中用来表示对象、类和接口的数据类型。与基本数据类型（如int、double等）不同，引用数据类型在内存中存储的是对象的引用，而非对象本身。</p><p>在Java中，我们可以通过类名或接口名来声明一个引用变量。例如，声明一个<code>Person</code>类的对象引用变量可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person;</span><br></pre></td></tr></table></figure><p>这样的声明并不会在内存中实际创建对象，而只是为引用变量分配了存储空间，使得它可以引用一个<code>Person</code>类的对象。</p><h2 id="引用数据类型的初始化与赋值"><a href="#引用数据类型的初始化与赋值" class="headerlink" title="引用数据类型的初始化与赋值"></a>引用数据类型的初始化与赋值</h2><p>要创建一个具体的对象，需要使用<code>new</code>关键字来为引用变量实例化一个对象。例如，创建一个<code>Person</code>类的对象可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>上述代码中，<code>new Person()</code>创建了一个<code>Person</code>类的对象，并通过赋值操作将对象的引用赋给了<code>person</code>引用变量。</p><h2 id="引用数据类型的特性和操作"><a href="#引用数据类型的特性和操作" class="headerlink" title="引用数据类型的特性和操作"></a>引用数据类型的特性和操作</h2><p>引用数据类型在内存中存储的是对象的引用，通过引用变量可以访问和操作对象的属性和方法。例如，通过<code>person.getName()</code>可以获取<code>Person</code>对象的名称属性值。</p><p>与基本数据类型不同，引用数据类型的大小在内存中是固定的，无论对象本身的大小是多少。因为引用数据类型所占空间的大小与对象本身的大小无关，而是由引用变量的大小决定的。</p><h2 id="引用数据类型的内存管理"><a href="#引用数据类型的内存管理" class="headerlink" title="引用数据类型的内存管理"></a>引用数据类型的内存管理</h2><p>Java中的垃圾回收机制负责管理引用数据类型的内存。当一个对象不再被引用时，垃圾回收器会自动将其标记为垃圾，并进行内存回收。开发人员无需手动释放对象所占用的内存，这样一方面减轻了内存管理的负担，另一方面也避免了内存泄漏的问题。</p><p>需要注意的是，Java中的引用数据类型是存在空指针的可能性的。当一个引用变量没有指向任何对象时，它的值为<code>null</code>。使用空指针引用变量访问对象的属性或方法将导致空指针异常的发生。因此，在使用引用数据类型时，要注意进行空指针判断，以避免程序的异常终止。</p><h2 id="引用数据类型的进阶应用"><a href="#引用数据类型的进阶应用" class="headerlink" title="引用数据类型的进阶应用"></a>引用数据类型的进阶应用</h2><p>除了基本的使用方式外，引用数据类型还有许多进阶的应用场景。例如，使用数组来存储多个对象的引用，通过循环遍历数组可以批量操作对象；使用集合类来管理动态对象集合，提供更丰富的数据操作方法；使用泛型来提高代码的可重用性和类型安全性等等。</p><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>通过本文的介绍，我们对Java引用数据类型有了更深入的了解。引用数据类型在Java中是非常重要的，它提供了灵活且强大的对象操作能力。合理地运用引用数据类型，可以编写出更加高效、可维护的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型揭秘：数据的奥义与转换技巧</title>
      <link href="/posts/33481.html"/>
      <url>/posts/33481.html</url>
      
        <content type="html"><![CDATA[<p>今天，让我们一起深入探索Java的基本数据类型，并详细了解它们的特点、取值范围以及适用场景。对于Java开发者来说，熟悉基本数据类型是编写高效和可靠代码的关键。现在就跟随我一同揭开Java基本数据类型背后的内幕吧！</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>在Java中，有四种整数类型：</p><ol><li><p>byte：占用1个字节，范围在-128至127之间。适用于节省内存的情况，如存储一个很小的整数值。</p></li><li><p>short：占用2个字节，范围在-32768至32767之间。适用于需要中等范围的整数值存储，如计数和数量。</p></li><li><p>int：占用4个字节，范围在-2147483648至2147483647之间。是Java中使用最广泛的整数类型，适用于大多数整数计算和变量存储。</p></li><li><p>long：占用8个字节，范围在-9223372036854775808至9223372036854775807之间。适用于特别大范围的整数值，如时间戳操作和位运算等。</p></li></ol><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>在Java中，有两种浮点数类型：</p><ol><li><p>float：占用4个字节，精度为7位有效数字。适用于存储较大的浮点数值，并且对精度要求不是十分严格的情况，如科学计算、图形处理等。</p></li><li><p>double：占用8个字节，精度为15位有效数字。是Java中使用最广泛的浮点数类型，适用于需要更高精度的浮点数计算，如财务计算、物理学等。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>在Java中，字符类型使用char来表示，占用2个字节。它用于存储单个字符，如字母、数字、标点符号等。可以用单引号括起来，例如：<code>char ch = &#39;A&#39;;</code>。字符类型适用于处理文本和字符操作，如密码输入、字符串处理等。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>Java的布尔类型用boolean来表示，只占用1个字节。它只有两个值：true（真）和false（假）。布尔类型适用于判断条件和控制流程，如条件判断、循环控制等。例如：<code>boolean isTrue = true;</code>。</p><h2 id="常量类型和字面常量"><a href="#常量类型和字面常量" class="headerlink" title="常量类型和字面常量"></a>常量类型和字面常量</h2><p>在Java中，常量类型指的是用final关键字声明的不可变的变量。常量类型可以是任何基本数据类型，并且在声明时必须进行初始化，并且初始化后不能再修改常量的值。例如：<code>final int MAX_VALUE = 100;</code>。</p><p>此外，还有字面常量，它们是直接写入代码的常量值。例如，整数常量<code>int num = 10;</code>、浮点数常量<code>float num = 3.14;</code>、字符常量<code>char ch = &#39;A&#39;;</code>、布尔常量<code>boolean isTrue = true;</code>等。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Java中，数据类型之间的转换分为两种类型：</p><ol><li><p>自动类型转换：当容量小的数据类型和容量大的数据类型进行运算时，会自动将小类型转换为大类型，以避免数据丢失。例如，int类型可以自动转换为long类型。</p></li><li><p>强制类型转换：当将容量大的数据类型赋值给容量小的数据类型时，需要进行强制类型转换。强制类型转换可能会导致数据精度的损失或溢出，需要谨慎使用。</p></li></ol><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>本文详细介绍了Java的基本数据类型，包括整数类型、浮点数类型、字符类型和布尔类型。同时，我们还了解了常量类型和字面常量的概念，并简要讨论了数据类型之间的转换。</p><p>通过深入学习和实践，我们能够更好地应用和理解Java的基本数据类型。熟悉不同数据类型的特点和使用场景，将帮助我们编写高效、可靠和易于维护的代码。</p><p>希望本文对您在Java编程中理解和应用基本数据类型有所帮助。愿您在编程的世界中不断探索、不断进步！感谢大家的阅读与支持！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Java数据类型：探索数据存储的多样性</title>
      <link href="/posts/41318.html"/>
      <url>/posts/41318.html</url>
      
        <content type="html"><![CDATA[<p>今天，让我们一起深入探索Java数据类型，了解不同数据类型的特点和应用场景。作为Java开发者，熟悉选择合适的数据类型将使您的程序更加高效和可靠。让我们开始探索Java数据类型的多样性吧！</p><h2 id="什么是数据类型？"><a href="#什么是数据类型？" class="headerlink" title="什么是数据类型？"></a>什么是数据类型？</h2><p>在编程中，数据类型是用来声明变量和解释内存中存储数据的方式。Java是一种静态类型的编程语言，每个变量都需要被指定数据类型。数据类型决定了变量可存储的数据类型和所占用的内存空间。</p><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><p>Java提供了一组基本数据类型，用于存储简单的值。以下是Java的基本数据类型：</p><ol><li><p>整数类型：byte、short、int、long</p></li><li><p>浮点数类型：float、double</p></li><li><p>字符类型：char</p></li><li><p>布尔类型：boolean</p></li></ol><p>这些基本数据类型直接存储在内存中，具有固定的大小和取值范围。您可以根据需求选择最合适的数据类型。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>除了基本数据类型，Java还提供了引用数据类型，用于存储复杂的对象。引用数据类型包括类、接口、数组等，它们在内存中存储的是对象的引用。</p><ol><li><p>类：通过关键字<code>class</code>定义，可以包含属性（变量）和方法。</p></li><li><p>接口：通过关键字<code>interface</code>定义，声明了一组方法的规范。</p></li><li><p>数组：通过使用<code>[]</code>来声明，可以存储多个相同类型的元素。</p></li></ol><p>引用数据类型在内存中存储的是对象的地址，而不是实际的数据本身。这使得Java能够有效地管理和操作复杂的数据结构。</p><h2 id="常量和常量类型"><a href="#常量和常量类型" class="headerlink" title="常量和常量类型"></a>常量和常量类型</h2><p>除了变量，Java还提供了常量和常量类型。常量是不可修改的值，常量类型是指可以保存常量的数据类型。</p><ol><li><p>字面常量：直接写入代码的常量，如整数常量、浮点数常量、字符串常量等。</p></li><li><p>final常量：使用关键字<code>final</code>声明的常量，一旦赋值后就无法更改。</p></li><li><p>枚举常量：通过关键字<code>enum</code>声明的常量，用于定义一组有限的值。</p></li></ol><p>常量提供了在程序中使用不变值的方法，可以提高代码的可维护性和可读性。</p><h2 id="数据类型的选择和使用注意事项"><a href="#数据类型的选择和使用注意事项" class="headerlink" title="数据类型的选择和使用注意事项"></a>数据类型的选择和使用注意事项</h2><p>在选择和使用数据类型时，需要考虑以下因素：</p><ol><li><p>取值范围：选择合适的数据类型以确保变量能够存储所需的值范围。</p></li><li><p>内存占用：不同的数据类型占用不同大小的内存，应根据数据量和性能需求进行选择。</p></li><li><p>类型转换：在不同数据类型之间进行转换时，确保类型兼容，并注意数据丢失的可能性。</p></li><li><p>数据精度：浮点数类型的精度有限，需要注意精确计算时的误差问题。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java的基本数据类型、引用数据类型和常量类型，以及选择和使用数据类型的注意事项。</p><p>进一步学习Java数据类型，请阅读Java官方文档、Java编程书籍和在线教程，深入理解数据类型的细节和使用技巧。同时，通过编写代码和实践项目来锻炼自己的数据类型选择和使用能力。</p><p>希望本文对您理解和应用Java数据类型有所帮助。掌握数据类型是成为一名优秀的Java开发者的重要基础。愿您在编程的旅程中不断学习和进步！谢谢各位读者的支持！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密Java关键字：探索Java语言的特殊力量</title>
      <link href="/posts/29193.html"/>
      <url>/posts/29193.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将深入探讨Java关键字，探索这些特殊的标识符在Java语言中的重要意义和作用。作为Java开发者，了解和正确使用关键字将为您的代码提供更强大的功能和更高的效率。让我们一同探索Java关键字的魅力！</p><h2 id="什么是关键字？"><a href="#什么是关键字？" class="headerlink" title="什么是关键字？"></a>什么是关键字？</h2><p>在Java中，关键字是一组被保留并且具有特殊意义的标识符。这些关键字在Java编程语言中有特定的用途，不能用作标识符（比如变量、方法或类名）。Java关键字是由语言规范定义的，每个关键字都有其独特的功能和语法。</p><h2 id="常用的Java关键字"><a href="#常用的Java关键字" class="headerlink" title="常用的Java关键字"></a>常用的Java关键字</h2><ol><li><p>public、private、protected：访问修饰符，用于定义类、方法和变量的可访问性范围。</p></li><li><p>class、interface：用于声明类和接口。</p></li><li><p>extends、implements：继承和实现，用于实现类之间的继承和接口的实现。</p></li><li><p>static、final：用于定义静态成员和常量，可以通过类名直接访问。</p></li><li><p>void：用于方法签名中，表示方法没有返回值。</p></li><li><p>new、this、super：用于创建新对象、引用当前对象和引用父类对象。</p></li><li><p>if、else、switch、case、default：条件语句和分支控制关键字，用于控制程序的执行路径。</p></li><li><p>for、while、do-while：循环语句的关键字，用于重复执行一段代码。</p></li><li><p>break、continue：用于在循环或switch语句中改变程序的执行流程。</p></li><li><p>try、catch、finally：异常处理的关键字，用于捕获和处理异常。</p></li></ol><h2 id="特殊的关键字"><a href="#特殊的关键字" class="headerlink" title="特殊的关键字"></a>特殊的关键字</h2><p>除了常用的关键字外，Java还有一些特殊的关键字，具有特定的作用：</p><ol><li><p>native：用于标识本地方法，即由其他语言（如C、C++）实现的Java方法。</p></li><li><p>synchronized：用于实现线程安全的同步访问。</p></li><li><p>transient、volatile：用于定义变量的特殊属性，分别标识变量不被序列化和变量的可见性。</p></li><li><p>enum：用于定义枚举类型，提供一组有限的值。</p></li><li><p>package、import：用于声明包和导入类。</p></li></ol><h2 id="关键字的使用注意事项"><a href="#关键字的使用注意事项" class="headerlink" title="关键字的使用注意事项"></a>关键字的使用注意事项</h2><ol><li><p>大小写敏感：Java关键字是大小写敏感的，需以正确的大小写形式使用。</p></li><li><p>不作为标识符：关键字不能用作变量、方法、类名等标识符。</p></li><li><p>命名规范：建议避免与关键字同名的标识符，以免引起混淆和错误。</p></li><li><p>版本差异：Java的不同版本可能对关键字进行扩展或修改，需要根据使用的Java版本来选择适当的关键字。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java关键字的概念、常见的关键字以及一些特殊关键字。了解和正确使用Java关键字将使您更好地理解和编写Java代码。</p><p>进一步学习Java关键字的知识，您可以阅读Java官方文档、Java编程书籍和在线教程。此外，参与Java社区的讨论和交流也是提升自己的好方式。</p><p>在使用Java关键字时，请确保理解其用法和限制，并在编码过程中遵循最佳实践。通过不断的学习和实践，相信您将能够熟练掌握Java关键字，并在编程中发挥它们的特殊力量。</p><p>感谢各位读者的阅读，希望本文能为您提供有价值的Java关键字知识。愿您在编程的旅程中越走越远！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JDK：解锁编程之门，探索Java开发必备利器</title>
      <link href="/posts/55389.html"/>
      <url>/posts/55389.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将带您进入Java开发的精彩世界，为您介绍Java Development Kit（JDK）这个必备利器。如果您是一个初学者，或者对Java开发感兴趣，那么本文将为您提供入门所需的关键信息和指导。让我们一同探索Java开发中的JDK吧！</p><h2 id="什么是Java-JDK？"><a href="#什么是Java-JDK？" class="headerlink" title="什么是Java JDK？"></a>什么是Java JDK？</h2><p>Java JDK是Java开发中的核心工具包，包含了一系列开发和运行Java应用程序所需的工具和库。它提供了编译、调试、运行和部署Java代码的功能，是Java开发的不可或缺的组成部分。</p><h2 id="为什么需要了解JDK？"><a href="#为什么需要了解JDK？" class="headerlink" title="为什么需要了解JDK？"></a>为什么需要了解JDK？</h2><p>了解JDK的重要性在于它对于Java开发的基础和核心功能提供了支持。以下是为什么要了解JDK的几个重要原因：</p><ol><li><p>编译和运行Java代码：JDK中包含了Java编译器（javac），可以将Java源代码编译成可执行的字节码文件。同时，JDK提供了Java Virtual Machine（JVM）来执行这些字节码文件。</p></li><li><p>开发工具和库：JDK提供了丰富的开发工具和库，包括调试器、性能分析工具、图形界面库等。这些工具和库能够提升您的开发效率和代码质量。</p></li><li><p>版本管理和兼容性：JDK的不同版本之间可能存在一些差异，了解各个版本的特性和变化对于代码的迁移和兼容性非常重要。</p></li></ol><h2 id="JDK版本介绍"><a href="#JDK版本介绍" class="headerlink" title="JDK版本介绍"></a>JDK版本介绍</h2><p>Java JDK经历了多个版本的演进和迭代，每个版本都引入了新的功能和改进。以下是几个常见的JDK版本：</p><ol><li><p>JDK 8：这个版本引入了很多重要的特性，如Lambda表达式、Stream API、新的Date/Time API等。</p></li><li><p>JDK 11：此版本是一个长期支持（LTS）版本，提供了新的特性和性能优化，同时降低了内存占用。</p></li><li><p>JDK 15：此版本引入了包括记录类型（Records）、Pattern Matching for instanceof等在内的多项新功能。</p></li></ol><h2 id="安装JDK的步骤"><a href="#安装JDK的步骤" class="headerlink" title="安装JDK的步骤"></a>安装JDK的步骤</h2><p>安装JDK是开始Java开发的第一步。以下是安装JDK的一般步骤：</p><ol><li><p>下载JDK安装包：您可以从Oracle官网（<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a>）下载合适的JDK安装包。</p></li><li><p>安装JDK：按照下载的安装包的指引执行安装操作。根据不同的操作系统，可能需要配置环境变量（如JAVA_HOME）以使JDK可用。</p></li><li><p>验证安装：安装完成后，可以在命令行运行<code>java -version</code>命令来验证JDK的安装是否成功。</p></li></ol><h2 id="学习资源和练习"><a href="#学习资源和练习" class="headerlink" title="学习资源和练习"></a>学习资源和练习</h2><p>学习Java开发需要不断学习和练习。以下是一些提升Java开发技能和知识的资源：</p><ol><li><p>官方文档和教程：Oracle官方提供了丰富的文档和教程，适合初学者入门和进阶学习。</p></li><li><p>在线课程和教学视频：诸如Coursera、Udemy、Codecademy等在线学习平台提供了许多Java开发相关的课程和教学视频。</p></li><li><p>开发工具和IDE：使用流行的开发工具和集成开发环境（IDE），如Eclipse、IntelliJ IDEA等，可以提供更多支持信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业数字化：引领未来商业发展的关键</title>
      <link href="/posts/64847.html"/>
      <url>/posts/64847.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><p>​  随着信息技术的飞跃发展，企业数字化已成为引领未来商业发展的关键要素。本文将探讨企业数字化的含义、重要性以及实施数字化转型的关键策略，旨在帮助企业把握数字化机遇，迈向全面发展的新高度。</p><h2 id="企业数字化的含义和重要性"><a href="#企业数字化的含义和重要性" class="headerlink" title="企业数字化的含义和重要性"></a>企业数字化的含义和重要性</h2><p>​  企业数字化是指将传统的商业活动以数字化方式进行，通过技术和网络平台来实现管理、运营和创新的转型过程。它涵盖了包括业务流程、组织结构、客户关系、市场营销等方面的数字化化改造，旨在提高效率、降低成本、提升竞争力。</p><p>​  企业数字化的重要性不可忽视。首先，数字化能够实现业务流程的高度自动化和集成化，提升企业的运营效率和灵活性。其次，数字化极大地扩展了企业的市场触角，打破了地域限制，带来全球范围内的商机和合作伙伴。再次，数字化为企业创新提供了无限可能，通过大数据分析和人工智能等技术手段，企业能够更加准确地洞察市场需求，开发出高质量的产品和服务。</p><h2 id="实施数字化转型的关键策略"><a href="#实施数字化转型的关键策略" class="headerlink" title="实施数字化转型的关键策略"></a>实施数字化转型的关键策略</h2><ol><li><p>制定清晰的数字化战略：企业需要明确数字化的目标和方向，制定可行的战略计划，并将其与企业的整体战略相衔接。数字化战略应该包括改造业务流程、优化组织结构、提升客户体验等方面。</p></li><li><p>投资适当的技术和平台：企业需要评估和选择适合自身需求的技术和平台，例如云计算、大数据分析、人工智能等。同时，企业还需要建立健全的信息技术基础设施，确保数字化转型的顺利进行。</p></li><li><p>建设高效的数字化团队：企业应该拥有一支专业的数字化团队，包括技术人员、数据分析师、数字营销专家等。这支团队能够推动数字化战略的实施，提供相关的技术支持和培训，确保数字化转型的成功。</p></li><li><p>提升组织文化和员工意识：企业数字化的成功还取决于组织文化和员工意识的转变。企业应该鼓励创新思维和信息共享，提供培训和奖励机制，激发员工参与到数字化转型中来。</p></li></ol><blockquote><p>Conclusion</p><p>企业数字化已经成为未来商业发展的不可或缺的一部分。通过实施数字化转型，企业能够提高效率、拓展市场、实现创新，并保持竞争优势。然而，在数字化转型的过程中，企业需要制定清晰的战略、选择适当的技术、建设强大的团队以及改变组织文化和员工意识。只有通过实施一系列的关键策略，企业才能在数字时代中立足并持续发展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Digitalize </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digitalize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Java开发的专有名词：掌握专有术语，驾驭编程世界！</title>
      <link href="/posts/4785.html"/>
      <url>/posts/4785.html</url>
      
        <content type="html"><![CDATA[<p>Java是一种广泛应用的编程语言，在Java开发中有一些必须了解的专有名词。对于初学者来说，这些名词可能有些陌生，但理解它们对于掌握Java开发是至关重要的。在本文中，我们将简单明了地介绍这些专有名词。</p><ol><li><p>JDK（Java Development Kit）<br>JDK是Java开发工具包，它是开发Java应用程序所必需的核心工具集。其中包括了编译器（用于将Java源代码编译为字节码）、调试器（用于调试程序）、类库（提供各种Java类和方法）等。JDK是开发Java应用程序的基石，必须安装和配置好才能开始编写Java代码。</p></li><li><p>JVM（Java Virtual Machine）<br>JVM是Java虚拟机，它是Java程序运行的环境。JVM会将Java字节码解释或编译成机器码，并执行程序。JVM具有跨平台特性，使得Java程序在不同的操作系统上能够运行。</p></li><li><p>OOP（Object-Oriented Programming）<br>OOP是面向对象编程的缩写，是一种编程范式。在Java中，一切都是对象，通过封装、继承和多态等概念，以对象为基本单位进行软件设计和开发。OOP使得代码更加模块化、可维护和可扩展。</p></li><li><p>IDE（Integrated Development Environment）<br>IDE是集成开发环境，它提供了一站式的开发工具。IDE包含代码编辑器、编译器、调试器和其他辅助工具，使得开发者可以更高效地编写、调试和测试代码。常见的Java IDE有Eclipse、IntelliJ IDEA等。</p></li><li><p>API（Application Programming Interface）<br>API是应用程序接口，它定义了软件组件之间的通信规范。通过API，开发者可以调用其他软件组件提供的方法和函数，访问其功能和数据。Java提供了丰富的API，包括图形界面、网络通信、数据库访问等方面。</p></li><li><p>MVC（Model-View-Controller）<br>MVC是一种软件架构模式，将应用程序分成三个核心部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据逻辑，视图负责展示数据和用户界面，控制器负责处理用户的输入和交互。这种分离有助于提高代码的可维护性和可扩展性。</p></li><li><p>Servlet<br>在Java Web开发中，Servlet是运行在服务器端的Java程序。它接收和处理HTTP请求，并生成响应。Servlet通常用于构建动态的Web应用程序，可以与HTML、CSS、JavaScript等前端技术结合使用。</p></li><li><p>JDBC（Java Database Connectivity）<br>JDBC是Java数据库连接，它是一种Java API，用于连接和操作数据库。通过JDBC，开发者可以与各种数据库建立连接，并执行SQL查询、更新等操作。JDBC给予开发者对数据库的灵活控制能力。</p></li></ol><p>了解这些专有名词对于Java开发者而言是非常重要的。它们是Java开发中的基础，深入学习和理解将有助于提高编程能力和开发效率。通过不断实践和探索，你会发现Java是一个强大而广泛应用的开发语言。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL执行过程</title>
      <link href="/posts/65435.html"/>
      <url>/posts/65435.html</url>
      
        <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202307291635919.png" alt="SQL语句执行流程图"></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>  用户在客户端输入执行SQL，该SQL语句通过session传输到服务器端，服务器通过Server Process接收SQL语句。客户端无需再做其他的操作，只是将SQL语句发送给服务端。</p><h3 id="查看Lib-Cache"><a href="#查看Lib-Cache" class="headerlink" title="查看Lib Cache"></a>查看Lib Cache</h3><p>  服务器进程在接到客户端传送过来的 SQL 语句后，不会直接去数据库查询。服务器进程会把这个 SQL 语句的字符进行转码，将转码后的值传递给一个 HASH 函数，并返回一个 hash 值，然后服务器进程将到 shared pool 的 library cache （高速缓存）中去查找是否存在相同的 hash 值。如果存在，服务器进程将使用这条语句已高速缓存在 library cache 中的已分析过的解析树和执行计划，省去后续的解析工作，这便是软解析。若高速缓存中不存在，则仍需要继续解析SQL、生成最佳执行计划，这便是硬解析，硬解析通常是昂贵的操作，大约占整个 SQL 执行的 70% 左右的时间。<br>​  所以，采用高速数据缓存的话，可以提高 SQL 语句的查询效率。其原因有两方面：一方面是从内存中读取数据要比从硬盘中的数据文件中读取数据效率要高，另一方面也是因为避免语句解析而节省了时间。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>  分析SQL语句的语法是否符合规范，如果服务器进程认为这条 SQL 语句不符合语法规则的时候，就会把这个错误信息反馈给客户端。在这个语法检查的过程中，不会对 SQL 语句中所包含的表名、列名等等进行检查，只是检查语法。</p><h3 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h3><p>  服务器进程接下去会对语句中涉及的表、索引、视图等对象进行解析，并对照数据字典检查这些对象的名称以及相关结构，看看这些字段、表、视图等是否在数据库中。如果存在问题的话，则数据库就会反馈错误信息给客户端。</p><h3 id="对象解析锁"><a href="#对象解析锁" class="headerlink" title="对象解析锁"></a>对象解析锁</h3><p>  系统会对我们需要查询的对象加锁，主要是为了保障数据的一致性，防止我们在查询的过程中，其他用户对这个对象的结构发生改变。</p><h3 id="权限核对"><a href="#权限核对" class="headerlink" title="权限核对"></a>权限核对</h3><p>  服务器进程还会检查连接用户是否有语句涉及对象的相关权限，若用户不具备相应权限的话则也会返回客户端。</p><h3 id="查询转换"><a href="#查询转换" class="headerlink" title="查询转换"></a>查询转换</h3><p>  视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>​  表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。</p><h3 id="选定执行计划"><a href="#选定执行计划" class="headerlink" title="选定执行计划"></a>选定执行计划</h3><p>  选择优化器，不同的优化器一般产生不同的“执行计划”。<br>​  选择连接方式，ORACLE有四种连接方式，对多表连接ORACLE可选择适当的连接方式。<br>​  选择连接顺序，对多表连接ORACLE选择驱动表和被驱动表。<br>​  选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>​  在生成的多个执行计划中，按统计信息带入，找出执行成本最小的执行计划，作为执行此SQL语句的执行计划。<br>​  将SQL文本、解析树、执行计划缓存到库缓存，存放地址以及SQL语句的哈希值，以便下次执行该SQL时可直接获取相关信息。</p><h2 id="语句执行"><a href="#语句执行" class="headerlink" title="语句执行"></a>语句执行</h2><h3 id="查询语句（Select）"><a href="#查询语句（Select）" class="headerlink" title="查询语句（Select）"></a>查询语句（Select）</h3><p>  首先服务器进程要判断所需数据是否在 db buffer 存在，如果存在且可用，则直接获取该数据而不是从数据库文件中去查询数据，同时根据 LRU 算法增加其访问计数；</p><p>  若数据不在缓冲区中，则服务器进程将从数据库文件中查询相关数据，并把这些数据放入到数据缓冲区中（ buffer cache ）。</p><p>  其中，判断数据的存在性和可用性检查方式为：查看 db buffer 块的头部是否有事务，如果有事务，则从回滚段中读取数据；如果没有事务，则比较 select 的 scn 和 db buffer 块头部的 scn ，如果前者小于后者，仍然要从回滚段中读取数据；如果前者大于后者，说明这是一非脏缓存，可以直接读取这个 db buffer 块的中内容。<br><strong>SQL Select语句完整的执行顺序</strong></p><ol><li>from子句组装来自不同数据源的数据；</li><li>where子句基于指定的条件对记录行进行筛选；</li><li>group by子句将数据划分为多个分组；</li><li>使用聚集函数进行计算；</li><li>使用having子句筛选分组；</li><li>计算所有的表达式；</li><li>使用order by对结果集进行排序；</li><li>执行select。</li></ol><h3 id="DML语句（Insert、Update、Delete）"><a href="#DML语句（Insert、Update、Delete）" class="headerlink" title="DML语句（Insert、Update、Delete）"></a>DML语句（Insert、Update、Delete）</h3><ol><li><p>检查所需的数据是否已经被读取到缓冲区中。如果已经存在缓冲区，则跳过第2部；</p></li><li><p>若所需的数据库并不在缓冲区缓存中，则服务器将数据块从数据文件读取到缓冲区中缓存；</p></li><li><p>对想要修改的表取得的数据行锁定（ Row Exclusive Lock ），之后对所需要修改的数据行取得独占锁；</p></li><li><p>将数据的 Redo 记录复制到 redo log buffer ；</p></li><li><p>产生数据修改的 undo 数据；</p></li><li><p>修改 db buffer ；</p></li><li><p>dbwr 将修改写入数据文件；</p></li></ol><h2 id="返回客户端"><a href="#返回客户端" class="headerlink" title="返回客户端"></a>返回客户端</h2><p>SQL语句被处理完成后Select语句会将查询结果返回给客户端，DML语句执行完后数据库会将对应的执行结果返回给客户端。最终客户端按照不同的方式呈现给用户。至此该SQL语句的生命周期完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDSQL For MySQL认证-单选题</title>
      <link href="/posts/3039.html"/>
      <url>/posts/3039.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.cdn.cheneyblog.com/blog/202307291510322.png" alt="关注公众号回复TDSQL认证获取更多资源"></p><ol><li><p>TDSQL(mysql)下列关于主键错误的是().</p><p>A. InnoDB表必须指定主键<br>B. 尽量游免更新主键字段<br>C. 如果存在多个唯一健，考虑最常用的唯一键作为主键<br>D. 主键值可以为空</p><blockquote><p>D. 主键值不可以为空，是错误的，应该修改为主键值不允许为空。</p><blockquote><p>在TDSQL中，主键是数据库表中的一个特殊字段，它的值必须是唯一的，且不允许为空，用来唯一标识一条记录。因此，选项D是错误的。选项A是正确的，在使用InnoDB存储引擎的表中，必须指定主键。选项B是正确的，尽量避免对主键字段进行更新操作，以减少索引维护的成本。选项C是合理的建议，根据最常用的唯一键作为主键可以提高查询效率和数据存储的规范性。</p></blockquote></blockquote></li><li><p>在mysql 中innodb引擎表T1，执行update t1 set a=2 where id =1；语句，id列有索引，下面描述正确的是（）.<br>A. 加表锁<br>B. 不加锁<br>C. 加行锁<br>D. 加字段锁</p><blockquote><p>C. 加行锁。</p><blockquote><p>在MySQL中，InnoDB引擎支持行级锁，当执行类似 <code>update t1 set a=2 where id =1</code> 的语句时，根据id列的索引，InnoDB引擎会为该行加上行锁。行锁是最细粒度的锁，只会锁定执行语句中涉及到的行，而不是整张表。这样可以避免不必要的锁竞争，提高并发性能。<br>如果涉及到多行数据的更新，InnoDB引擎会根据语句的执行计划，采用不同的锁策略。如果更新的行数少于等于当前隔离级别下的自增长值，那么会采用行锁；否则会采用表锁，避免出现死锁和性能下降的问题。因此，在具体的开发中需要根据实际情况进行测试和优化。</p></blockquote></blockquote></li><li><p>负责mysqld 进程存活检查并进行拉起的进程是（）.<br>A. Oc agent<br>B. Scheduer.<br>C. manager<br>D. hdfs</p><blockquote><p>B. Scheduler。</p><blockquote><p>MySQL是一个长时间运行的进程，如果因为某种原因意外退出，需要及时拉起，以保证服务的可用性。在腾讯云数据库TDSQL中，负责mysqld进程存活检查并进行拉起的进程是Scheduler。Scheduler是TDSQL的一个重要组件，它负责管理MySQL实例的启动、停止、重启、配置变更等操作，并通过监控Agent对MySQL进程进行存活检查，一旦发现MySQL进程异常退出，就会及时拉起，以保证服务的高可用性和可靠性。选项A的Oc agent是腾讯云的一种云原生容器服务，用于应用的容器化部署；选项C的manager和选项D的hdfs都与MySQL进程的运行管理没有直接的联系。</p></blockquote></blockquote></li><li><p>使用mysql客户端透传登方式录后，可以查看库中有哪些表是分表的语句是（）.<br>A. <code>/*proxy*/show table with shardkey;</code><br>B. <code>show shardkey tables;</code><br>C. <code>/*proxy*/show tables;</code><br>D. <code>/*proxy*/show shardkey tables;</code></p><blockquote><p>A. <code>/*proxy*/show table with shardkey;</code></p><blockquote><p>当使用MySQL客户端透传登方式登录到腾讯云数据库TDSQL分布式实例时，需要在SQL语句前加上注释<code>/*proxy*/</code>，以便将该SQL语句透传到分片节点执行。查看分表信息的语句是<code>show table with shardkey;</code>，加上透传登注释后即为<code>/*proxy*/show table with shardkey;</code>。该语句将返回数据库中所有分表的信息，包括表名、鉴别键类型、分表数量及分表的节点信息等。选项B和D的语法有误；选项C返回了所有表的信息，而不是分表的信息。</p></blockquote></blockquote></li><li><p>TDSQL 修改字段类型命令正确的是（）.<br>A. alter table t1 alter e varchar(20);<br>B. alter table t1 modify e varchar(30);<br>C. alter table t1.e modify varchar(30);<br>D. alter table t1.e alter varchar(30);</p><blockquote><p>B. alter table t1 modify e varchar(30);</p><blockquote><p>在腾讯云数据库TDSQL中，要修改表字段的数据类型，可以使用ALTER TABLE语句。正确的语法是<code>alter table 表名 modify 字段名 字段类型</code>，即选项B。该语句将修改t1表中e字段的类型为varchar(30)。选项A的语法错误，缺少modify关键字；选项C语法错误，应该为<code>alter table t1 modify e varchar(30)</code>；选项D的语法错误，应该为<code>alter table t1 modify e varchar(30)</code>。</p></blockquote></blockquote></li><li><p>使用mysql客户端登录TDSQL时，加哪个参数可以使用透传功能?<br>A. -a<br>B. -b<br>C. -c<br>D. -d</p><blockquote><p>C. <code>-c</code></p><blockquote><p>在使用MySQL客户端登录腾讯云数据库TDSQL时，如果要使用透传功能，需要在登录命令中添加<code>-c</code>参数。使用该参数后，在SQL语句中添加<code>/*proxy*/</code>注释，即可将该SQL语句透传给后端节点执行。例如，使用以下命令登录MySQL客户端，可以开启透传功能：<code>mysql -h hostname -u user -p -P port -c</code><br>其中，<code>hostname</code>是TDSQL实例的内网地址，<code>user</code>是数据库用户名，<code>port</code>是数据库端口，添加了<code>-c</code>参数后，就可以在SQL语句前添加<code>/*proxy*/</code>注释，实现透传功能。</p></blockquote></blockquote></li><li><p>当检测到死锁时，TDSQL InnoDB 存储引擎如何处理它们?<br>A. 两个受影响的事务都将回滚。<br>B. 受职响的事务等待inodb lock wait 超时，然后回滚。<br>C. 一个受影响的事务将回滚，另一个允许继续.<br>D. 事务隔离级别决定回滚哪个事务.</p><blockquote><p>C. 一个受影响的事务将回滚，另一个允许继续.</p><blockquote><p>答案解释如下：<br>A. 两个受影响的事务都将回滚<br>这个选项是错误的。当检测到死锁时，TDSQL InnoDB 存储引擎只需要选择一个牺牲者回滚，不需要把所有事务都回滚。回滚所有事务会导致所有事务的更改都被撤销，可能会导致严重的数据一致性问题。<br>B. 受影响的事务等待 InnoDB lock wait 超时，然后回滚<br>这个选项也是错误的。等待 InnoDB lock wait 超时的事务并不知道它是在等待死锁的解决。等待超时后可能会自行回滚事务，但如果其他事务继续增加锁等待，则问题仍将存在。<br>D. 事务隔离级别决定回滚哪个事务<br>这个选项是错误的。事务隔离级别影响并发操作的方式，但不会决定哪个事务应该被回滚。在 TDSQL 中，当 InnoDB 检测到死锁时，根据其自己的规则选择牺牲者回滚事务，而不考虑事务隔离级别。</p></blockquote></blockquote></li><li><p>存在表T1，有a，b，c三个字段，c 字段有普通索引，下面查询可以使用到索引的是（）.<br>A. <code>select * from t1 where b=1 and c=2</code><br>B. <code>select * from t1 where c+1=2</code><br>C. <code>select * from t1 where c like %2</code><br>D. <code>select * from t1 where c!=2</code></p><blockquote><p>A. <code>select * from t1 where b=1 and c=2</code></p><blockquote><p>B. <code>select * from t1 where c+1=2</code><br>这个查询中的 c + 1 表达式不能使用 c 列上的索引，因为这个表达式不是一个普通的列名。MySQL 在查询解析时，无法直接判断 c+1 表达式的结果。如果你想在查询中使用到 c 列上的索引，可以考虑修改查询条件或者采用 MySQL 的可计算列技术来实现。<br>C. <code>select * from t1 where c like %2</code><br>像前面所说的，因为 % 通配符是以 c 列值开头，且在查询计划时无法确定符合条件的数据行，因此不能使用 c 列上的索引。<br>D. <code>select * from t1 where c!=2</code><br>在这个查询中，该条件不能使用 c 列上的普通索引。这是因为对于索引来说，无法直接响应「不等于」操作符。如果你需要使用不等于查询，并且期望内部使用到索引来处理 WHERE 从句，你可以考虑使用覆盖索引或是使用聚簇索引。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）关于强同步策略描述正确的是?<br>A. 主机不等从机应答直接返客户端成功<br>B. 主机等待多数从机应答再返回客户端成功<br>C. 主机等待至少一台从机应答成功后才返回客户端成功<br>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>强同步策略需要确保每个从机节点都写入成功后，才返回给客户端成功，这就要求所有从机节点都要可用。虽然强同步策略能够提供最高的数据可靠性，但由于要等待所有从机节点写入成功后才能返回客户端成功，所以会增加写入时延，并且在高并发写入场景下可能会出现瓶颈，因此，应根据实际需求选择合适的同步策略。</p></blockquote></blockquote></li><li><p>MysQL查询哪些进程正在执行().<br>A. <code>show process;</code><br>B. <code>show processlist;</code><br>C. <code>list process;</code><br>D. <code>list processe;</code></p><blockquote><p>B. <code>show processlist;</code></p></blockquote></li><li><p>TDSQL（MySQL版）分布式支持哪种类型的表?<br>A. 分表<br>B. 单表<br>C. 广播表<br>D. 以上都支持</p><blockquote><p>D. 以上都支持</p><blockquote><p>A. 分表是指将一个表的数据按照某种方式拆分成多个表，分布到多个节点上。不同的节点上存储同一张表的不同分片，可以水平扩展表的存储和查询性能。TDSQL（MySQL版）支持分片表。<br>B. 单表是指一个库中只有一张表，这种表类型不涉及到分布式问题。任何一种数据库都支持单表。<br>C. 广播表是指将一个表的数据复制到所有的节点中，每个节点都有该表的完整数据。广播表主要用于数据量较小、对查询性能要求较高、且需要高可靠性的场景。TDSQL（MySQL版）同样支持广播表。</p></blockquote></blockquote></li><li><p>查看InnoDB内存参数设置的命今是（）.<br>A. <code>show variables like &quot;innodb%;</code><br>B. <code>show parameter like &quot;innodb%;</code><br>C. <code>list variables like &quot;innodb%;</code><br>D. <code>list parameter like inodb%;</code></p><blockquote><p>A. <code>show variables like &quot;innodb%;</code></p></blockquote></li><li><p>关于mysql 主从同步中Slave_IO_Running线程描述不正确的是.<br>A. 可以判断I/O线程是否被启动，并成功地连接到主服务器上。<br>B. 备库回放relay log的线程<br>C. 存在备库上面的线程<br>D. 接收到主库binlog 并写入中继日志的线程</p><blockquote><p>B. 备库回放relay log的线程</p><blockquote><p>备库回放 relay log 的线程是 Slave SQL Running 线程完成的。Slave SQL Running 线程是负责执行中继日志中的事件，将这些事件应用到备库上的线程，因此 B 选项描述是错误的。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）的路由信息是保存在哪里的?<br>A. 数据库中<br>B. Scheduler<br>C. Zookeper<br>D. oss</p><blockquote><p>C. Zookeper</p><blockquote><p>ZooKeeper 是一个分布式的、开放源代码的分布式应用程序协调服务，它是 TDSQL（MySQL版）中的重要组件，用于保存和管理集群中的元数据信息和路由信息，包括数据库实例的地址、分片和拆分等信息。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）分布式实例中哪些表只存在第一个set上?<br>A. 单表<br>B. 分表<br>C. 广播表<br>D. 所有表</p><blockquote><p>A. 单表</p></blockquote></li><li><p>TDSQL中自增字段描述正确的是（）.<br>A. TDSQL只保证在单个分片内部递增<br>B. TDSQL 可以保证在全局递增，但不是单调递增<br>C. TDSQL不支持自增字段<br>D. TDSQL 可以保证在全局严格单调递增</p><blockquote><p>B. TDSQL 可以保证在全局递增，但不是单调递增</p><blockquote><p>自增字段是一种在插入记录时自动递增的字段。在 TDSQL 中，自增字段可以使用 AUTO_INCREMENT 关键字来定义。当插入记录时，TDSQL 会为自增字段赋一个新值，以便保证每条记录都有唯一的值。<br>在 TDSQL 中，自增字段的递增方式取决于表的分片设置。如果表被水平分片到多个节点上，那么自增字段的递增方式可能是局部递增的，也就是说，在每个节点上自增字段的值都是递增的，但是不同节点上的自增字段值可能会重复。如果表没有被分片或者只被分片到一个节点上，那么自增字段的递增方式将是全局递增的。<br>需要注意的是，在 TDSQL 中，自增字段的递增方式并不一定是单调递增的。这是因为在分片环境下，不同节点上自增字段的值可能会有交错。然而，TDSQL 会保证自增字段在全局上是递增的，也就是说，每个自增字段的值都比之前插入的记录的自增字段的值大。</p></blockquote></blockquote></li><li><p>关于TDSQL 广播表说法正确的是（）?<br>A. 广播表可以将表数据均匀拆分到各个set<br>B. 广播表一般适合数据量较大的表<br>C. 广播表适合用于频繁更新的表<br>D. 广播表适用于更新较少的小表</p><blockquote><p>D. 广播表适用于更新较少的小表</p><blockquote><p>TDSQL 的广播表是将一个表完全复制到集群的所有 Set 上。数据拷贝是在数据变更时同步进行的，因此对数据的读写操作在所有 Set 上都是相同的。由于广播表在所有 Set 上都有完整副本，所以广播表能够提供非常高的查询性能，对于 join、group by 等操作尤为显著。<br>由于广播表拷贝的是完整的数据，所以其适用场景是数据量较小、更新较少的表，如一些配置表、元数据表等。这些表通常不会有太多的数据变动，可以在集群启动时快速拷贝所有数据，然后在之后的运行中进行读取操作。</p></blockquote></blockquote></li><li><p>查看MySQL服务进程是存在?<br>A. ps -ef|grep 端口号<br>B. fs -ef|grep 端口号<br>C. ns-ef|grep 端口号<br>D. ys-ef|grep 端口号</p><blockquote><p>A. ps -ef|grep 端口号</p><blockquote><p>ps命令可以列出当前所有进程的信息，包括进程ID（PID）、进程状态、运行时间等信息。通过grep命令可以过滤出包含指定端口号的进程。因此，在Linux或Unix系统中，可以通过ps -ef|grep 端口号命令来查看MySQL服务进程是否存在。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL)中主备数据一致性检查的工具是？<br>A. pt-online-schema-change<br>B. pt-pmp<br>C. pt-table-checksum<br>D. pt-mysql-summary</p><blockquote><p>C. pt-table-checksum</p><blockquote><p>pt-table-checksum是Percona Toolkit中的一个工具，可以检查MySQL主库和从库之间的数据一致性。它通过对比主库和从库的数据行数、校验和等信息，来确定两个库之间是否存在数据不一致的情况。如果发现不一致，就可以通过其他工具（例如pt-table-sync）来修复数据。因此，pt-table-checksum对于保证TDSQL（MySQL）主从数据一致性非常有用。</p></blockquote></blockquote></li><li><p>下面哪个命令可以通过透传的方式查看tdsql 集群的消息（）.<br>A. <code>show status;</code><br>B. <code>/*proxy*/show status</code><br>C. <code>/*proxy*/cluster status;</code><br>D. <code>/*cluster*/show status;</code></p><blockquote><p>B. <code>/*proxy*/show status</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> TDSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDSQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发学习路线</title>
      <link href="/posts/11880.html"/>
      <url>/posts/11880.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将为大家分享自学Java开发的学习路线，助力您步入编程的精彩世界。无论您是对编程感兴趣的新手，还是希望升级自己技能的开发者，本文将为您提供一份简明扼要的指南。让我们一起探索自学Java开发的学习之旅吧！</p><h2 id="掌握Java基础知识"><a href="#掌握Java基础知识" class="headerlink" title="掌握Java基础知识"></a>掌握Java基础知识</h2><p>Java是一门广泛应用的编程语言，熟练掌握其基础知识是成为合格Java开发者的第一步。以下是您应该着重学习的内容：</p><ol><li><p>语法基础：了解Java的关键词、数据类型、变量、运算符、流程控制等基本语法。</p></li><li><p>面向对象编程（OOP）：掌握类、对象、继承、多态、封装等OOP的核心概念。</p></li><li><p>Java集合框架：学习常用的集合类如List、Set、Map等，掌握它们的用法和特性。</p></li><li><p>异常处理：了解异常的概念、处理机制和异常处理的最佳实践。</p></li></ol><h2 id="深入学习Java核心技术"><a href="#深入学习Java核心技术" class="headerlink" title="深入学习Java核心技术"></a>深入学习Java核心技术</h2><p>除了基础知识外，了解Java核心技术将帮助您更全面地应用和理解Java开发。以下是您应该关注的主题：</p><ol><li><p>IO操作和文件处理：学习Java中的输入输出操作，包括文件读写、流操作、序列化等。</p></li><li><p>多线程编程：掌握多线程的概念、线程同步、锁机制等，以提高程序的并发性能。</p></li><li><p>网络编程：了解Socket编程、HTTP协议等，为构建网络应用打下基础。</p></li><li><p>数据库操作：学习Java与数据库的交互，掌握SQL语句的编写和数据库连接的使用方式。</p></li></ol><h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><p>Web开发是Java的一个重要应用领域。学习相关技术将带给您更广阔的发展前景。以下是您需要学习的内容：</p><ol><li><p>Servlet和JSP：了解Servlet的原理和用法，学习JSP的页面开发和动态内容生成。</p></li><li><p>Web框架：研究主流的Java Web框架，如Spring MVC、Struts等，掌握它们的工作原理和使用方式。</p></li><li><p>前端技术：学习HTML、CSS、JavaScript等前端技术，使您能够构建漂亮的用户界面。</p></li><li><p>数据库框架：掌握数据库框架，如Hibernate、MyBatis等，简化与数据库的交互操作。</p></li></ol><h2 id="提升开发效率"><a href="#提升开发效率" class="headerlink" title="提升开发效率"></a>提升开发效率</h2><p>成为一名高效的Java开发者，除了掌握核心技术外，还需要掌握一些工具和技巧：</p><ol><li><p>开发工具：熟练使用开发工具，例如Eclipse、IntelliJ IDEA等。熟悉调试技巧和代码重构。</p></li><li><p>版本控制：学习使用Git等版本控制工具，管理代码的版本和团队协作。</p></li><li><p>构建工具：了解Maven或Gradle等构建工具的使用，自动化依赖管理和项目构建。</p></li><li><p>测试与调试：学习单元测试和集成测试的方法，进行代码调试和性能优化。</p></li></ol><h2 id="实践与项目"><a href="#实践与项目" class="headerlink" title="实践与项目"></a>实践与项目</h2><p>在学习过程中，通过实践项目来应用所学知识是非常重要的。以下是一些建议：</p><ol><li><p>自主开发小项目：尝试独立完成一个小型项目，如个人博客、待办事项管理系统等，锻炼实际应用能力。</p></li><li><p>参与开源项目：加入开源社区，学习借鉴他人的经验，并为项目贡献自己的代码。</p></li><li><p>进行代码审查：与其他开发者交流，互相审查和改进代码，提高质量和可维护性。</p></li></ol><h2 id="持续学习和保持激情"><a href="#持续学习和保持激情" class="headerlink" title="持续学习和保持激情"></a>持续学习和保持激情</h2><p>Java发展日新月异，作为一名Java开发者，需要跟上技术的脚步。以下是一些持续学习的建议：</p><ol><li><p>阅读技术博客和书籍：关注Java技术的最新动态，通过阅读优秀的技术博客和书籍来不断学习。</p></li><li><p>参加技术交流活动：参加技术研讨会、开发者大会等活动，与其他开发者进行交流和分享经验。</p></li><li><p>学习新的技术领域：探索其他相关技术领域，如云计算、人工智能等，丰富自己的技能树。</p></li></ol><p>无论您的目标是在职场中找到更好的机会，还是追求个人技术成长，自学Java开发是一条值得追求的道路。相信通过持续的努力和实践，您将逐渐成为一名优秀的Java开发者。祝您在学习Java开发的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作手册</title>
      <link href="/posts/34671.html"/>
      <url>/posts/34671.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><ul><li><p>Hexo官网：<a href="https://hexo.io/zh-cn/">Hexo</a></p></li><li><p>Hexo是一款基于Node.js的静态网站生成器，可用于快速搭建个人博客或静态网站。</p></li></ul><h2 id="安装前配置"><a href="#安装前配置" class="headerlink" title="安装前配置"></a>安装前配置</h2><ol><li><p>Node.js</p><p>Hexo是基于Node.js开发的，因此需要先安装Node.js。</p><p>Node.js官方：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><p>Windows安装Node.js教程</p><iframe src="//player.bilibili.com/player.html?aid=412728509&bvid=BV11V411o7Zh&cid=177010975&page=1" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li><li><p>Git</p><p>如果您想使用Hexo主题或插件，可能需要使用Git进行下载和管理。</p><p>Git官网：<a href="https://git-scm.com/">Git (git-scm.com)</a></p><p>Windows安装Git教程</p><iframe src="//player.bilibili.com/player.html?aid=426532004&bvid=BV133411A7zU&cid=721246198&page=1" weight = 100% height = "500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol><h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><ol><li><p>打开命令行，使用npm安装Hexo<br><code>npm install hexo-cli -g</code></p></li><li><p>初始化Hexo<br>进入需要存放博客的目录，然后右键选择Git Bash Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init HenryCheney</span><br><span class="line"><span class="built_in">cd</span> HenryCheney</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>博客目录：G:\blog\HenryCheney</p></li><li><p>配置Hexo</p><p>进入博客目录，修改<code>_config.yml</code>文件以配置Hexo。在该文件中，你可以设置博客标题、描述、作者信息、主题、链接等内容。<br><img src="https://www.cdn.cheneyblog.com/blog/202307291429384.png" alt="博客配置"></p></li><li><p>编写文章<br><code>hexo new &quot;My New Post&quot;</code><br>新创建一个名为My New Post的文章存放在G:\blog\HenryCheney\source\_posts目录下</p></li><li><p>生成静态文件<br><code>hexo generate</code><br>简写：<code>hexo g</code></p></li><li><p>预览网站</p><p><code>hexo server</code><br>简写：<code>hexo s</code><br>然后在浏览器中访问<code>http://localhost:4000</code>，就可以访问到自己的博客了。</p></li><li><p>网站推送到GitHub<br>A. 首先安装hexo-deployer-git<br>   <code>npm install hexo-deployer-git --save</code><br>B. 修改 _config.yml 文件</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repository: git@github.com <span class="comment"># 仓库地址</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>C. 部署项目到GitHub</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
