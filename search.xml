<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>构建现代Web应用的核心技术剖析</title>
      <link href="/posts/41485.html"/>
      <url>/posts/41485.html</url>
      
        <content type="html"><![CDATA[<p>Web技术作为构建现代互联网世界的基石，不仅给人们带来了无限的便利，也推动了互联网的不断发展。本文将对几个关键的Web核心技术进行总结，帮助您更好地了解和应用这些技术，为Web应用的开发和优化提供指导。</p><ol><li><a href="https://cheneyblog.com//posts/11682.html">域名：互联网命名系统</a></li><li><a href="https://cheneyblog.com//posts/330.html">域名解析：连接互联网的关键枢纽</a></li><li><a href="https://cheneyblog.com//posts/44850.html">DNS：互联网底层通信的重要基石</a></li><li><a href="https://cheneyblog.com//posts/59495.html">DNS配置：将域名连接到IP地址的关键步骤</a></li><li><a href="https://cheneyblog.com//posts/26748.html">HTTP与HTTPS：保障Web通信安全的重要技术</a></li><li><a href="https://cheneyblog.com//posts/34621.html">SSL证书：构建安全可信的Web通信环境</a></li><li><a href="https://cheneyblog.com//posts/31314.html">CDN：实现高速可靠的网络内容分发</a></li></ol><p>通过深入理解和熟练应用这些Web核心技术，开发者可以构建功能强大、性能卓越、用户友好的Web应用。同时，这些技术也提供了不断学习和创新的机会，让我们能够驾驭Web技术的潮流，不断迭代和改善我们的应用。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发学习指南：从入门到精通，掌握高效编程的利器！</title>
      <link href="/posts/16531.html"/>
      <url>/posts/16531.html</url>
      
        <content type="html"><![CDATA[<p>Java作为一门广泛应用的编程语言，其在企业级应用和软件开发领域拥有广泛的影响力。学习Java开发能够让你掌握高效编程的利器，并为你未来的职业发展提供坚实的基础。本文将持续为你提供一个全面的Java开发学习目录，帮助你系统地学习并掌握这一领域的知识和技能。</p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><ul><li><a href="https://cheneyblog.com//posts/42473.html">Java简介</a></li><li><a href="https://cheneyblog.com//posts/4785.html">Java开发你必须了解的专有名词</a></li><li><a href="https://cheneyblog.com//posts/55389.html">解锁Java开发之JDK</a></li><li><a href="https://cheneyblog.com//posts/29193.html">Java关键字：“Foundation of Power”（权力基石）</a></li><li><a href="https://cheneyblog.com//posts/41318.html">解析Java数据类型</a></li><li><a href="https://cheneyblog.com//posts/33481.html">Java基本数据类型揭秘</a></li><li><a href="https://cheneyblog.com//posts/39770.html">探索Java引用数据类型</a></li><li><a href="https://cheneyblog.com//posts/36533.html">剖析Java变量</a></li><li><a href="https://cheneyblog.com//posts/37240.html">Java运算符：逻辑与算术的连接器</a></li><li><a href="https://cheneyblog.com//posts/42343.html">高效编程利器：Java流程控制</a></li><li><a href="https://cheneyblog.com//posts/37227.html">Java表达式：算与术的巧妙结合</a></li><li><a href="https://cheneyblog.com//posts/50102.html">Java数组：一种新的数据结构</a></li></ul><blockquote><p>持续更新中，敬请期待！！！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle开发学习指南：从入门到精通，打造高效数据库应用</title>
      <link href="/posts/50904.html"/>
      <url>/posts/50904.html</url>
      
        <content type="html"><![CDATA[<p>当涉及到Oracle开发学习，有一些关键的指南可以帮助你更好地掌握这个数据库管理系统。在本文中，我将向大家分享一些有关Oracle开发学习的重要指南。</p><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li><a href="https://cheneyblog.com//posts/565.html">物理结构</a></li><li><a href="https://cheneyblog.com//posts/14901.html">内存结构</a></li><li><a href="https://cheneyblog.com//posts/35730.html">进程结构</a></li><li><a href="https://cheneyblog.com//posts/24947.html">逻辑结构</a></li><li><a href="https://cheneyblog.com//posts/47150.html">体系结构总结</a></li><li><a href="https://cheneyblog.com//posts/39514.html">Library Cache 的基本结构</a></li><li><a href="https://cheneyblog.com//posts/27399.html">Library Cache 详解</a></li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><ul><li><a href="https://cheneyblog.com//posts/65435.html">SQL语句执行过程</a></li><li><a href="https://cheneyblog.com//posts/22532.html">Cursor（游标）</a></li><li><a href="https://cheneyblog.com//posts/55163.html">Session Cursor</a></li><li><a href="https://cheneyblog.com//posts/22265.html">硬解析、软解析和软软解析</a></li></ul><h2 id="优化篇"><a href="#优化篇" class="headerlink" title="优化篇"></a>优化篇</h2><h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><ul><li><a href="https://cheneyblog.com//posts/20895.html">执行计划简介</a></li><li><a href="https://cheneyblog.com//posts/26508.html">Oracle统计信息</a></li><li><a href="https://cheneyblog.com//posts/32449.html">统计信息管理工具：DBMS_STATS包</a></li><li><a href="https://cheneyblog.com//posts/54365.html">获取执行计划</a></li><li><a href="https://cheneyblog.com//posts/12101.html">看懂执行计划之执行顺序</a></li><li><a href="https://cheneyblog.com//posts/65395.html">看懂执行计划之基于规则的优化器（RBO）</a></li><li><a href="https://cheneyblog.com//posts/61.html">看懂执行计划之基于成本的优化器（CBO）</a></li><li><a href="https://cheneyblog.com//posts/49498.html">看懂执行计划之优化器的模式</a></li><li><a href="https://cheneyblog.com//posts/46535.html">看懂执行计划之表相关执行计划</a></li><li><a href="https://cheneyblog.com//posts/9739.html">看懂执行计划之索引介绍</a></li><li><a href="https://cheneyblog.com//posts/26997.html">看懂执行计划之B-tree索引</a></li><li><a href="https://cheneyblog.com//posts/35895.html">看懂执行计划之位图索引</a></li><li><a href="https://cheneyblog.com//posts/10468.html">看懂执行计划之表连接</a></li><li><a href="https://cheneyblog.com//posts/44822.html">看懂执行计划之其他执行计划</a></li><li><a href="https://cheneyblog.com//posts/1085.html">看懂执行计划之稳定执行计划</a></li><li><a href="https://cheneyblog.com//posts/24522.html">加速查询优化——深入了解Oracle Hint</a></li><li><a href="https://cheneyblog.com//posts/20503.html">如何根据执行计划识别低效SQL</a></li></ul><h3 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h3><ul><li><a href="https://cheneyblog.com//posts/30060.html">简介</a></li><li><a href="https://cheneyblog.com//posts/10092.html">绑定变量PL/SQL中的应用</a></li><li><a href="https://cheneyblog.com//posts/6732.html">绑定变量窥探</a></li></ul><p>通过以上的指南，你可以更好地学习和掌握Oracle开发技能。无论是作为初学者还是有一定经验的开发者，这些指南都能够为你提供有价值的指导和帮助。祝你在Oracle开发学习的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速查询性能,探秘Oracle常量游标共享</title>
      <link href="/posts/54542.html"/>
      <url>/posts/54542.html</url>
      
        <content type="html"><![CDATA[<p>大家好！在数据库应用开发中，查询性能一直是我们关注的焦点。Oracle数据库引入了常量游标共享（cursor_sharing），旨在通过共享相同查询逻辑的执行计划，提高查询性能。本文将深入探讨常量游标共享的由来、解决的问题，使用方法以及不同参数配置下的优势和弊端。</p><h2 id="为什么会有常量游标共享"><a href="#为什么会有常量游标共享" class="headerlink" title="为什么会有常量游标共享"></a>为什么会有常量游标共享</h2><p>在实际的数据库应用中，我们常常遇到相似的查询逻辑，但实际参数值有所差异的情况。传统的方式是为每个不同参数值编译不同的查询语句，这种重复劳动造成了资源的浪费和性能的下降。为了解决这个问题，Oracle引入了常量游标共享。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>当开启了常规游标共享后，Oracle在实际解析目标SQL之前，会先用系统产生的绑定变量（”SYS_B_n”(n=0,1,2……)”）来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值，这样替换后实际执行的SQL就已经是使用了绑定变量的改写后的等价SQL,这样就可以做到既有效降低系统硬解析的数量又对应用透明。</p><h2 id="解决了什么问题"><a href="#解决了什么问题" class="headerlink" title="解决了什么问题"></a>解决了什么问题</h2><p>常量游标共享通过将查询中的实际参数替换为常量值，实现相同查询逻辑的共享。它解决了以下问题：</p><ol><li><p>减少了重复编译：常量游标共享避免了为每个不同参数值编译新的查询语句，减少了重复编译的开销和数据库的负载。</p></li><li><p>提高了内存利用率：共享执行计划的使用减少了存储执行计划所需的内存空间，释放了宝贵的内存资源，从而提升了整体的数据库性能。</p></li><li><p>加速了查询速度：重复使用共享的执行计划，减少了缓冲区中存储查询结果的次数，提高了查询速度，增强了系统的响应能力。</p></li></ol><h2 id="如何使用常量游标共享"><a href="#如何使用常量游标共享" class="headerlink" title="如何使用常量游标共享"></a>如何使用常量游标共享</h2><p>在Oracle数据库中，可以通过修改系统参数或会话参数的方式来配置常量游标共享。</p><ol><li><p>修改系统参数：通过修改<code>CURSOR_SHARING</code>参数来启用常量游标共享。可选的参数值如下：</p><ul><li><code>EXACT</code>：要求查询中所有参数与常量完全匹配才能共享游标。</li><li><code>SIMILAR</code>：只要查询中的实际参数与常量有相似的值（经过转换后），就可以共享游标。</li><li><code>FORCE</code>：强制使用常量游标共享，无论实际参数的值如何。</li></ul></li><li><p>修改会话参数：可以在会话级别上修改<code>CURSOR_SHARING</code>参数的值，仅对当前会话生效。例如：</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> CURSOR_SHARING <span class="operator">=</span> <span class="keyword">SIMILAR</span>;</span><br></pre></td></tr></table></figure><h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><ol><li><p><code>EXACT</code>模式：<br>Oracle不会用系统产生的绑定变量来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值。</p></li><li><p><code>SIMILAR</code>模式：<br>Oracle会用系统产生的绑定变量来替换目标SQL的SQL文本中where条件或者values子句(适用于INSERT语句)中的具体输入值，  但Oracle只会对那些它认为是安全的谓词条件在替换后重用解析树和执行计划，对于它认为的不安全的谓词条件，即便用系统产生的绑定变量替换后的SQL文本是一模一样的，对于每一个不同的输入值，Oracle都会执行一次硬解析，即此时会出现一个Parent Cursor下挂一堆Child Cursor的现象，而这些Child Cursor中存储的解析树和执行计划很可能是一样的(注意，因为自适应游标共享的引入，这种行为不再适用于Oracle 11g及其后续的版本)。</p><blockquote><p>所谓“安全的谓词条件”,是指如果一个谓词条件所在的目标SQL的执行计划并不随该谓词条件的输入值的变化而变化，那么该谓词条件就是安全的。与之相反的是，如果目标SQL的执行计划可能会隨着谓词条件的输入值的不同而发生变化，那么该谓词条件就是一个不安全的谓词条件。<br>Oracle数据库中典型的不安全的谓词条件有范围查询(使用了&gt;、&gt;=、&lt;、&lt;=、between的谓词条件),使用了帶通配符(%)的LIKE,以及对有直方图统计信息的目标列施加的等值查询等(关于直方图统计信息，会在“第5章Oracle里的统计信息”中详细描述，这里不再赘述)。</p></blockquote></li><li><p><code>FORCE</code>模式：<br>不管是“安全的谓词条件”还是“不安全的谓词条件”,当CURSOR_SHARING的值为FORCE时，替换后同一类型的SQL总是会无条件地重用之前硬解析时的解析树和执行计划(注意，因为自适应游标共享的引入，这种行为不再适用于Oracle 11g及其后续的版本)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绑定变量窥探：提升SQL查询性能的利器</title>
      <link href="/posts/6732.html"/>
      <url>/posts/6732.html</url>
      
        <content type="html"><![CDATA[<div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>在Oracle数据库中，优化查询性能是每个数据库管理员和开发人员关注的焦点之一。而绑定变量窥探（Bind Peeking）作为一项重要的优化技术，可以帮助我们提升SQL查询的性能以及执行计划的选择。本文将深入解析Oracle绑定变量窥探，带您了解其原理、使用方法以及注意事项，助您在数据库优化的道路上取得更好的成果。</p></div><h2 id="什么是绑定变量窥探"><a href="#什么是绑定变量窥探" class="headerlink" title="什么是绑定变量窥探"></a>什么是绑定变量窥探</h2><p>绑定变量是SQL语句中使用的占位符，用于在执行时绑定实际的值。而绑定变量窥探是Oracle数据库中的一项优化技术，通过观察绑定变量的值来选择最佳的执行计划。它避免了SQL语句的重复编译，提高了数据库的性能和响应速度。</p><h2 id="绑定变量窥探的原理"><a href="#绑定变量窥探的原理" class="headerlink" title="绑定变量窥探的原理"></a>绑定变量窥探的原理</h2><p>在执行一条SQL语句时，Oracle会对绑定变量进行窥探，观察其值。根据绑定变量的值，Oracle会选择一个执行计划，该计划在当前查询的情况下被认为是最佳的。之后，Oracle会重复使用这个执行计划，避免重新编译SQL语句。</p><h2 id="绑定变量窥探的优点"><a href="#绑定变量窥探的优点" class="headerlink" title="绑定变量窥探的优点"></a>绑定变量窥探的优点</h2><ul><li>减少SQL语句的重复编译：绑定变量窥探可以显著降低SQL语句的重复编译次数，提升数据库的性能。</li><li>提高执行计划的选择：根据绑定变量的值，Oracle可以选择合适的执行计划，优化查询性能。</li></ul><h2 id="绑定变量窥探的限制和注意事项"><a href="#绑定变量窥探的限制和注意事项" class="headerlink" title="绑定变量窥探的限制和注意事项"></a>绑定变量窥探的限制和注意事项</h2><ul><li>数据分布的不均匀性：绑定变量窥探的选择依赖于绑定变量的值，如果数据分布不均匀，可能会选择到一个不适合当前查询的执行计划。</li><li>SQL语句多样性：对于多样性的SQL语句，绑定变量窥探可能无法有效选择最佳的执行计划。</li></ul><h2 id="如何使用绑定变量窥探"><a href="#如何使用绑定变量窥探" class="headerlink" title="如何使用绑定变量窥探"></a>如何使用绑定变量窥探</h2><p>在大多数情况下，Oracle会自动进行绑定变量窥探。但在一些特殊情况下，我们可以通过使用HINT或修改SESSION级别的优化参数来控制绑定变量窥探的行为。然而，这些方法需要谨慎使用，并且需要在特定的情况下进行评估和测试。</p><blockquote><p>绑定变量窥探是Oracle数据库中的一项重要的优化技术，通过观察绑定变量的值来选择最佳的执行计划，从而提升SQL查询性能。然而，在使用绑定变量窥探时，需要注意数据分布的不均匀性和SQL语句多样性所带来的限制。通过合理的使用和评估，我们可以最大程度地发挥绑定变量窥探的优势，对数据库性能进行优化。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升 PL/SQL 执行效率的利器：绑定变量与批量绑定</title>
      <link href="/posts/10092.html"/>
      <url>/posts/10092.html</url>
      
        <content type="html"><![CDATA[<p>大家好！在本文中，我们将带您深入了解 PL/SQL 中的一个重要技巧，即绑定变量的应用。绑定变量是优化代码执行效率和提高系统性能的秘密利器，让我们一起来探索其背后的力量。</p><h2 id="绑定变量"><a href="#绑定变量" class="headerlink" title="绑定变量"></a>绑定变量</h2><p>绑定变量是一种通过使用占位符代替具体数值或变量来减少重复解析和编译 SQL 语句开销的技术。它在 PL/SQL 中有着广泛的应用。让我们通过一个普通的例子来说明绑定变量的用法。</p><p>假设我们需要查询特定员工的工资信息，并进行更新操作。传统的方法是在 SQL 语句中直接使用员工的 ID 和工资数值。然而，这种方式容易导致 SQL 注入攻击，并且每次执行 SQL 语句都需要重新解析和编译，浪费了系统资源和时间。</p><p>现在，我们使用绑定变量来改进代码：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  v_employee_id EMPLOYEES.EMPLOYEE_ID<span class="operator">%</span>TYPE :<span class="operator">=</span> <span class="number">100</span>; <span class="comment">-- 绑定变量</span></span><br><span class="line">  v_salary      EMPLOYEES.SALARY<span class="operator">%</span>TYPE;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> v_salary <span class="keyword">FROM</span> EMPLOYEES <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_id;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 执行其他 PL/SQL 逻辑或业务处理</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">UPDATE</span> EMPLOYEES <span class="keyword">SET</span> salary <span class="operator">=</span> v_salary <span class="operator">+</span> <span class="number">1000</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;工资更新成功&#x27;</span>);</span><br><span class="line">EXCEPTION</span><br><span class="line">  <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;出现错误: &#x27;</span> <span class="operator">||</span> SQLERRM);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用 <code>v_employee_id</code> 这个绑定变量来替代具体的员工 ID。通过使用绑定变量，我们可以带来以下好处：</p><ol><li><p>缓存重用：数据库可以重用已经编译好的执行计划，避免每次都重新解析和编译 SQL 语句，从而提高执行效率。</p></li><li><p>数据安全：绑定变量可以防止 SQL 注入攻击，确保数据的安全性和完整性。</p></li><li><p>减少网络传输：绑定变量只需要传输一次，而不需要每次都传输具体数值，减少了网络传输的开销，提高了读写数据的效率。</p></li></ol><p>除了普通的绑定变量，我们还可以使用批量绑定来优化大批量数据的处理。批量绑定是一种同时处理多个数据的技术，通过减少与数据库的交互次数来提高代码的执行效率。</p><h2 id="批量绑定"><a href="#批量绑定" class="headerlink" title="批量绑定"></a>批量绑定</h2><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>PL/SQL 是一种用于编写存储过程、触发器和函数等数据库程序的过程式编程语言，而 SQL 引擎则负责执行 SQL 查询和 DML（数据操作语言）语句。当在 PL/SQL 中执行 SQL 语句时，会涉及 PL/SQL 引擎和 SQL 引擎之间的上下文切换。频繁的上下文切换会增加系统的开销，降低性能。</p></div><p>批量绑定的使用是减少上下文切换的一种有效策略。绑定变量是指在 SQL 语句中使用占位符代替具体的数值或变量，这样可以减少重复解析和编译 SQL 语句的开销。</p><p>以下是一个批量绑定的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  TYPE emp_id_list <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> EMPLOYEES.EMPLOYEE_ID<span class="operator">%</span>TYPE INDEX <span class="keyword">BY</span> PLS_INTEGER;</span><br><span class="line">  TYPE sal_list <span class="keyword">IS</span> <span class="keyword">TABLE</span> <span class="keyword">OF</span> EMPLOYEES.SALARY<span class="operator">%</span>TYPE INDEX <span class="keyword">BY</span> PLS_INTEGER;</span><br><span class="line"></span><br><span class="line">  v_employee_ids emp_id_list;</span><br><span class="line">  v_salaries sal_list;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="comment">-- 初始化绑定变量</span></span><br><span class="line">  v_employee_ids(<span class="number">1</span>) :<span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  v_employee_ids(<span class="number">2</span>) :<span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">  v_employee_ids(<span class="number">3</span>) :<span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 查询员工的薪水</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary BULK <span class="keyword">COLLECT</span> <span class="keyword">INTO</span> v_salaries</span><br><span class="line">  <span class="keyword">FROM</span> EMPLOYEES</span><br><span class="line">  <span class="keyword">WHERE</span> employee_id <span class="keyword">MEMBER</span> <span class="keyword">OF</span> v_employee_ids;</span><br><span class="line"></span><br><span class="line">  <span class="comment">-- 更新员工薪水</span></span><br><span class="line">  FORALL i <span class="keyword">IN</span> v_employee_ids.FIRST .. v_employee_ids.LAST</span><br><span class="line">    <span class="keyword">UPDATE</span> EMPLOYEES</span><br><span class="line">    <span class="keyword">SET</span> salary <span class="operator">=</span> v_salaries(i) <span class="operator">*</span> <span class="number">1.1</span> <span class="comment">-- 加薪 10%</span></span><br><span class="line">    <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> v_employee_ids(i);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">COMMIT</span>;</span><br><span class="line">  DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;薪资更新成功&#x27;</span>);</span><br><span class="line">EXCEPTION</span><br><span class="line">  <span class="keyword">WHEN</span> OTHERS <span class="keyword">THEN</span></span><br><span class="line">    <span class="keyword">ROLLBACK</span>;</span><br><span class="line">    DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;出现错误: &#x27;</span> <span class="operator">||</span> SQLERRM);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用了一个类型为 <code>emp_id_list</code> 的批量绑定变量 <code>v_employee_ids</code>，并根据员工 ID 更新对应的薪水信息。通过批量绑定，我们可以在一次操作中同时处理多个数据，减少了与数据库的交互次数，提升了代码的执行效率。</p><blockquote><p>总结一下，绑定变量和批量绑定是 PL/SQL 中优化代码执行效率和提升系统性能的重要工具。通过减少重复解析和编译的开销、优化资源利用和减少与数据库的交互次数，这两种技术帮助我们编写更高效的代码。<br>绑定变量和批量绑定是 PL/SQL 开发者必备的技能，它们能够显著提高代码的执行效率和系统性能。在实际开发中，根据具体场景的需求，灵活运用这两种技术，将为您的项目带来明显的优势。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绑定变量：优化查询性能的利器</title>
      <link href="/posts/30060.html"/>
      <url>/posts/30060.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>摘要：Oracle数据库中的绑定变量是提升查询性能和安全性的重要工具。本文将详细介绍绑定变量的含义、优势，解析绑定变量如何通过减少SQL解析开销和查询重编译次数来提升数据库查询效率的原理，并提供简单的用法举例，帮助读者更好地理解和应用绑定变量的优势。</p></div><p>在数据库开发中，查询性能一直是一项关键任务，而Oracle数据库提供了诸多优化工具和技术。其中，绑定变量被广泛应用，通过减少SQL解析开销和查询重编译次数等手段，显著提升数据库查询效率。本文将解析绑定变量的含义、优势、提升效率的原理，并提供一些简单的用法举例。</p><h2 id="绑定变量的含义"><a href="#绑定变量的含义" class="headerlink" title="绑定变量的含义"></a>绑定变量的含义</h2><p>绑定变量是一种机制，将SQL语句中需要动态输入的参数或值与具体的参数值分离开来。它使用占位符来代表参数，通过此机制实现了SQL语句的重用、减少了SQL解析开销和查询重编译次数，进而提升了查询性能和安全性。</p><h2 id="绑定变量的优势"><a href="#绑定变量的优势" class="headerlink" title="绑定变量的优势"></a>绑定变量的优势</h2><ol><li>提升查询性能：绑定变量能够减少SQL解析开销和查询重编译次数。当使用绑定变量时，数据库可以重用已经解析过的SQL语句的执行计划，而无需重新解析和编译，从而显著提高查询性能。</li><li>增强安全性：通过将参数值与SQL语句分离，绑定变量可以有效避免SQL注入攻击。由于参数值不会直接拼接到SQL语句中，攻击者无法通过篡改参数值来执行恶意代码。</li><li>减少资源消耗：绑定变量避免了每次执行SQL语句都需要创建新的SQL语句的情况，从而减少了内存的消耗。</li></ol><h2 id="绑定变量提升查询效率的原理"><a href="#绑定变量提升查询效率的原理" class="headerlink" title="绑定变量提升查询效率的原理"></a>绑定变量提升查询效率的原理</h2><ol><li>SQL解析开销减少：数据库在解析SQL语句时，绑定变量的值为占位符，而不是具体的参数值。因此，当相同的SQL语句有不同的参数值时，数据库可以重用已经解析过的语法树和执行计划，避免了重复解析的开销。</li><li>查询重编译次数减少：使用绑定变量时，数据库不需要为每个不同的参数值重新编译SQL语句，而是将新的参数值与SQL语句进行绑定，从而避免了查询重编译的过程，提升了查询效率。</li></ol><h2 id="绑定变量的简单用法举例"><a href="#绑定变量的简单用法举例" class="headerlink" title="绑定变量的简单用法举例"></a>绑定变量的简单用法举例</h2><p>以下是几个绑定变量的简单用法示例：</p><ol><li><p>查询语句中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> :dept_id;</span><br></pre></td></tr></table></figure><p> 其中，<code>:dept_id</code> 是绑定变量，我们可以在执行查询之前为其提供实际的参数值。</p></li><li><p>插入语句中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> employees (employee_id, first_name, last_name) <span class="keyword">VALUES</span> (:emp_id, :first_name, :last_name);</span><br></pre></td></tr></table></figure><p> 在执行插入操作之前，我们可以为绑定变量 <code>:emp_id</code>、<code>:first_name</code> 和 <code>:last_name</code> 提供实际的参数值。</p></li><li><p>在PL/SQL代码块中使用绑定变量：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">  v_salary NUMBER;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> v_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> :emp_id;</span><br><span class="line">  <span class="comment">-- 其他操作</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p> 在PL/SQL代码块中，我们可以使用绑定变量 <code>:emp_id</code> 来接收查询结果或传递参数。</p></li></ol><blockquote><p>绑定变量是Oracle数据库中提升查询性能和安全性的重要工具。它通过减少SQL解析开销和查询重编译次数的方式，显著提高了数据库的查询效率。通过正确应用绑定变量，开发人员可以优化查询操作并提升数据库性能。在实际应用中，我们应充分利用绑定变量的优势，并遵循最佳实践，以获得最佳的性能和安全性。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探索Oracle数据库中的Session Cursor</title>
      <link href="/posts/55163.html"/>
      <url>/posts/55163.html</url>
      
        <content type="html"><![CDATA[<p>在本文中，我们将更深入地探讨Oracle数据库中的Session Cursor（会话游标），包括定义、分类、常用属性与使用方法举例，助您更好地理解和应用这一重要概念。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Session Cursor是与会话（Session）相关联的游标，用于在数据库中执行SQL语句和处理查询结果集。它提供了一个可以在会话期间重用和共享的游标，用于多次执行相同或类似的SQL语句，以提高效率和性能。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>在Oracle数据库中，Session Cursor根据它们的来源和用途可以分为以下几种类型：</p><ol><li><p>隐式游标（Implicit Cursors）：隐式游标由Oracle数据库自动创建和管理，用于处理简单的SQL语句，如单条查询语句和DML语句。它们无需手动声明或关闭，数据库会自动处理隐式游标的生命周期。</p></li><li><p>显式游标（Explicit Cursors）：显式游标需要开发人员手动声明、使用和关闭。它们适用于处理复杂的SQL语句，允许在程序中对结果集进行更灵活的处理，同时也可以绑定变量和参数。</p></li><li><p>参考游标（Reference Cursors）：参考游标是一种特殊类型的游标，可以作为参数传递或作为函数返回值使用。它们通常在存储过程或函数中使用，允许在不同的会话之间共享游标结果集。</p></li></ol><h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>Session Cursor具有一些常用的属性，可用于检查和处理游标的状态和结果，包括：</p><ol><li><p>FOUND：用于检查游标是否有可用的查询结果，返回TRUE或FALSE。</p></li><li><p>NOTFOUND：用于检查游标是否没有可用的查询结果，返回TRUE或FALSE。</p></li><li><p>ISOPEN：用于检查游标是否打开（Open），返回TRUE或FALSE。</p></li><li><p>ROWCOUNT：返回最后一个SELECT查询返回的行数，或者最后一个DML语句影响的行数。</p></li></ol><h2 id="使用方法举例"><a href="#使用方法举例" class="headerlink" title="使用方法举例"></a>使用方法举例</h2><p>以下是使用Session Cursor的一般方法举例，包括属性的使用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span></span><br><span class="line">    cursor_name SYS_REFCURSOR;</span><br><span class="line">    result_variable TABLE_NAME.COLUMN_NAME<span class="operator">%</span>TYPE;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">OPEN</span> cursor_name <span class="keyword">FOR</span> <span class="keyword">SELECT</span> COLUMN_NAME <span class="keyword">FROM</span> TABLE_NAME;</span><br><span class="line">    <span class="comment">-- 使用游标属性进行判断和处理结果</span></span><br><span class="line">    IF cursor_name<span class="operator">%</span>FOUND <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">FETCH</span> cursor_name <span class="keyword">INTO</span> result_variable;</span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;Result: &#x27;</span> <span class="operator">||</span> result_variable);</span><br><span class="line">    <span class="keyword">ELSE</span></span><br><span class="line">        DBMS_OUTPUT.PUT_LINE(<span class="string">&#x27;No result found.&#x27;</span>);</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">    IF cursor_name<span class="operator">%</span>ISOPEN <span class="keyword">THEN</span></span><br><span class="line">        <span class="keyword">CLOSE</span> cursor_name;</span><br><span class="line">    <span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>以上示例中，我们声明了一个显式游标”cursor_name”，然后打开游标、使用游标属性%FOUND来判断是否有查询结果，进而处理结果。最后，我们还使用了%ISOPEN属性来检查游标是否打开，并在需要时关闭游标。</p><blockquote><p>Session Cursor是Oracle数据库中一种重要的工具，用于执行SQL语句并处理查询结果集。通过了解其定义、分类、常用属性和使用方法举例，我们可以更好地利用Session Cursor提供的灵活性和高效性，优化数据库操作，并提高性能和开发效率。作为数据库开发人员和管理员，熟练掌握Session Cursor的概念和使用方法将为您的工作带来巨大的帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬解析、软解析和软软解析</title>
      <link href="/posts/22265.html"/>
      <url>/posts/22265.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>&emsp;&emsp;在 Oracle 中，每条 SQL 语句在执行之前都需要经过解析（Parse），根据解析的过程可以分为 3 种类型：硬解析（Hard Parse）、软解析（Soft Parse）和软软解析（Soft Soft Parse），软软解析也叫快速解析（Fast Parse）。DDL 语句每次执行都需要进行硬解析，DML 语句和 SELECT 语句会根据情况选择是进行硬解析，还是进行软解析或者进行软软解析。</p><blockquote><p>判断硬解析和软解析的依据在于 sga 中的 share cursor 的缓存情况<br>判断软解析和软软解析的依据在于 pga 中的 session cursor 是否可以重用</p></blockquote><h2 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h2><p><a href="https://cheneyblog.com//posts/22532.html">【Oracle】Oracle Cursor（游标）</a></p><h2 id="SQL-执行过程"><a href="#SQL-执行过程" class="headerlink" title="SQL 执行过程"></a>SQL 执行过程</h2><p>&emsp;&emsp;客户端进程将 SQL 语句通过监听器发送到 Oracle, 触发一个 Server process 生成，来对该客户进行服务。Server process 得到 SQL 语句之后，对 SQL 语句进行 Hash 运算，然后根据 Hash 值先到当前会话的 PGA 中查找是否存在匹配的缓存会话游标（Session Cursor），如果 PGA 中不存在则到 library cache 中查找是否存在匹配的父游标（Parent Cursor）和子游标（Child Cursor），如果都不存在则重新开始解析目标 SQL，选择最优执行计划，执行 SQL 并将结果返回给客户端。<br><img src="https://www.cdn.cheneyblog.com/blog/202309221612022.png" alt="SQL 执行过程"></p><h2 id="硬解析"><a href="#硬解析" class="headerlink" title="硬解析"></a>硬解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找不到匹配的缓存会话游标，在 SGA 的库缓存（Library Cache）中没有找到匹配的父游标或是找到了匹配的父游标没有找到对应子游标。那么 oracle 就会重新开始解析该目标 SQL，那么 Oracle 就会新生成一个会话游标和一对共享游标（即父游标和子游标）解析目标 SQL，这种方式我们称之为硬解析。</p><h3 id="硬解析执行步骤"><a href="#硬解析执行步骤" class="headerlink" title="硬解析执行步骤"></a>硬解析执行步骤</h3><ol><li>语法检查</li><li>权限与对象检查</li><li>优化器生成多个执行计划</li><li>选择最优的执行计划</li><li>将执行计划，SQL 文本等装载进 library cache 中的 heap 中</li></ol><h2 id="软解析"><a href="#软解析" class="headerlink" title="软解析"></a>软解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找不到匹配的缓存会话游标，但在库缓存中找到了匹配的父游标和子游标，那么 Oracle 会新生成一个会话游标并重用刚刚找到的父游标和子游标，直接调用解析树和执行计划解析目标 SQL，这种方式我们称之为软解析。</p><h2 id="软软解析"><a href="#软软解析" class="headerlink" title="软软解析"></a>软软解析</h2><p>&emsp;&emsp;在当前会话的 PGA 中找到了匹配的缓存会话游标，那么此时 Oracle 就不再需要新生成一个会话游标，并且也不再需要像软解析那样得去 SGA 的库缓存中查找匹配的父游标了，因为 Oracle 此时可以重用找到的匹配会话游标，并且可以通过这个会话游标直接访问到该 SQL 对应的父游标获取解析树和执行计划解析目标 SQL，这种方式我们称之为软软解析。</p><pre><code>软软解析的必要条件：1. 参数session_cached_cursors的值是大于02. 同一个session中执行过三次以上目标SQL</code></pre><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><table><thead><tr><th>类型</th><th>硬解析</th><th>软解析</th><th>软软解析</th></tr></thead><tbody><tr><td>优缺点</td><td>硬解析可能会导致 Shared Pool Latch 争用，会消耗大量 CPU 资源以及 SGA 资源，OLTP 系统硬解析是万恶之源</td><td>软解析也可能会导致库缓存相关 Latch 的争用，但持有次数少时间短</td><td>省去了 Open 一个新游标和 Close 一个现有会话游标消耗的资源和时间</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cursor（游标）</title>
      <link href="/posts/22532.html"/>
      <url>/posts/22532.html</url>
      
        <content type="html"><![CDATA[<pre><code>Cursour(游标)是Oracle数据库中解析SQL和执行SQL的载体。</code></pre><h2 id="Shared-Cursor"><a href="#Shared-Cursor" class="headerlink" title="Shared Cursor"></a>Shared Cursor</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>Shared Cursor 是指缓存在库缓存里 SQL 语句和匿名 PL/SQL 对应的 SQL 文本、解析树、目标 SQL 涉及的对象、目标 SQL 中的绑定变量及 SQL 的执行计划等信息。</p><h3 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h3><p>Shared Cursor 又细分为 Parent Cursor（父游标）和 Child Cursor（子游标）两种。<code>V$SQLAREA</code> 可查看 Parent Cursor，<code>V$SQL</code> 可查看 Child Cursor（CHILD_NUMBER 值从 0 开始）。Parent Cursor 和 Child Cursor 均已库缓存对象句柄的方式缓存在库缓存中，Namespace 为 CRSR。</p><h3 id="父子游标的区别和联系"><a href="#父子游标的区别和联系" class="headerlink" title="父子游标的区别和联系"></a>父子游标的区别和联系</h3><ol><li>目标 SQL 的 SQL 文本存储在 Parent Cursor 所对应库缓存对象句柄的 Name 属性中，Child Cursor 的 Name 属性为空；</li><li>目标 SQL 的解析树和执行规则会存储在 Child Cursor 对应库缓存对象句柄的 Heap 6 中；</li><li>Parent Cursor 的 Heap 0 中存储了该父游标对应的所有子游标库缓存对象句柄地址。</li></ol><h3 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h3><p>由于不同目标 SQL 的文本对应的哈希值可能相同，且同一个目标 SQL 也可能存在多份不同的解析树和执行计划。为了尽量减少对应 Hash Bucket 中库缓存对象句柄链表的长度，同时减少 Oracle 检索库缓存对象句柄链表所消耗的时间和工作量，Oracle 父子游标并存的结构一直延续至今。</p><h2 id="Session-Cursor"><a href="#Session-Cursor" class="headerlink" title="Session Cursor"></a>Session Cursor</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>Session Cursor 是解析和执行 SQL 的载体，Session Cursor 也是以哈希表的方式缓存起来，只不过是缓存在 PGA 中。</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ol><li>Session Cursor 和 Session 一一对应，不同的 Session 的 Session Cursor 之间没法共享</li><li>Session Cursor 有生命周期，在使用过程中都至少会经历一次 Open、Parse、Bind、Execute、Fetch 和 Close 中的一个或多个阶段</li><li>Session Cursor 也是以哈希表的方式缓存在 PGA 中，Oracle 会同样根据哈希运算来存储和访问当前 Session 对应 PGA 中 Session Cursor</li><li>一个 Session Cursor 对应一个 Shared Cursor，一个 Shared Cursor 可以同时对应多个 Session Cursor</li><li>一个 Session Cursor 能够被缓存在 PGA 中的必要条件是该 Session Cursor 所对应的 SQL 解析和执行次数要超过 3 次</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>解析和执行目标 SQL</li><li>Oracle 依靠 Session Cursor 将目标 SQL 所涉及的数据从 Buffer Cache 的对应数据块读到 PGA，然后 PGA 做后续处理（排序、表连接）</li></ul><h3 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>OPEN_CURSORS</td><td>设定单个 Session 中同时以 Open 状态并存的 Session Cursor 的总数</td></tr><tr><td>SESSION_CACHED_CURSORS</td><td>设定单个 Session 中能够以 Soft Closed 状态并存的 Session Cursor 总数</td></tr><tr><td>CURSOR_SPACE_FOR_TIME</td><td>Oracle 11gR1 之前的版本用来减少库缓存相关 Latch 争用，副作用是增加 Shared Pool 压力</td></tr></tbody></table><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li>隐式游标（Implicit Cursor）</li><li>显式游标（Explicit Cursor）</li><li>参考游标（Ref Cursor）</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星球资源</title>
      <link href="/posts/28703.html"/>
      <url>/posts/28703.html</url>
      
        <content type="html"><![CDATA[<h2 id="特邀嘉宾"><a href="#特邀嘉宾" class="headerlink" title="特邀嘉宾"></a>特邀嘉宾</h2><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://www.cdn.cheneyblog.com/blog/202307291649261.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">Cheney</div>  <p>八年数据开发，熟悉多种编程语言和数据处理工具，擅长数据分析及数据治理</p>  <a href='https://www.cheneyblog.com/'></a>  </figcaption>  </figure>  </div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>理解SSL证书：构建安全可信的Web通信环境</title>
      <link href="/posts/34621.html"/>
      <url>/posts/34621.html</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，在Web开发中了解和应用SSL证书是非常重要的。SSL证书是用于验证网站身份并保障数据传输安全的数字证书。本文将深入解析SSL证书的作用、原理和部署，帮助您构建安全可信的Web通信环境。</p><h2 id="SSL证书的作用"><a href="#SSL证书的作用" class="headerlink" title="SSL证书的作用"></a>SSL证书的作用</h2><p>SSL证书有以下重要作用：</p><ul><li>网站身份验证：SSL证书由权威的证书颁发机构（CA）签发，用于验证网站的真实性和合法性。用户可以通过浏览器对证书的验证结果来判断网站的可信度。</li><li>数据传输加密：SSL证书使用加密技术，将传输的数据进行加密，防止第三方窃取和篡改敏感信息。</li><li>数据传输完整性保护：SSL证书使用消息摘要和数字签名等技术，确保传输过程中数据的完整性，防止数据被篡改。</li></ul><h2 id="SSL证书的原理"><a href="#SSL证书的原理" class="headerlink" title="SSL证书的原理"></a>SSL证书的原理</h2><p>SSL证书采用公钥加密技术，涉及以下几个关键组件：</p><ul><li>公钥：SSL证书中包含网站的公钥，用于加密传输数据。</li><li>私钥：私钥是与公钥对应的解密密钥，由网站的服务器保管。只有拥有私钥的服务器才能解密加密的数据。</li><li>数字签名：CA使用自己的私钥对证书进行签名，确保证书的真实性和完整性。验证证书时，可以使用CA的公钥来验证签名，从而判断证书的有效性。</li></ul><h2 id="SSL证书的部署"><a href="#SSL证书的部署" class="headerlink" title="SSL证书的部署"></a>SSL证书的部署</h2><p>SSL证书部署包括以下步骤：</p><ul><li>选择证书类型：根据实际需求选择适合的SSL证书类型，如域名验证证书、组织验证证书或扩展验证证书。</li><li>生成证书请求：在服务器上生成证书请求文件（CSR），包含相关信息，如域名、组织信息等。</li><li>购买SSL证书：将CSR文件提交给CA，购买SSL证书，并通过身份验证流程获得证书。</li><li>安装和配置证书：将获得的SSL证书安装在服务器上，并进行相应的配置，以启用HTTPS协议和加密通信。</li><li>定期更新证书：SSL证书的有效期通常为1年或更长，确保定期更新证书以保障持续的安全通信。</li></ul><p>通过理解SSL证书的作用、原理以及部署流程，程序员能够更好地保障Web应用的安全性和用户的隐私。SSL证书的应用不仅提升网站的可靠性和信任度，也符合现代Web安全的最佳实践。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解HTTP与HTTPS：保障Web通信安全的重要技术</title>
      <link href="/posts/26748.html"/>
      <url>/posts/26748.html</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，了解HTTP（超文本传输协议）和HTTPS（安全的超文本传输协议）是非常重要的。它们是构建以及保障Web通信安全的关键技术。本文将深入解析HTTP与HTTPS，帮助您更好地理解这些协议的作用和应用场景。</p><h2 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h2><p>HTTP是Web通信的基础协议，用于客户端（如浏览器）与服务器之间的数据传输。它采用明文传输，存在以下特点：</p><ol><li>无状态协议：每个请求和响应都是相互独立的，不保留任何状态信息。</li><li>明文传输：请求和响应中的数据传输是明文的，容易被第三方窃取和篡改。</li><li>请求方法：HTTP定义了多种请求方法，如GET、POST、PUT、DELETE等，以满足不同的处理需求。</li></ol><h2 id="HTTPS（安全的超文本传输协议）"><a href="#HTTPS（安全的超文本传输协议）" class="headerlink" title="HTTPS（安全的超文本传输协议）"></a>HTTPS（安全的超文本传输协议）</h2><p>HTTPS在HTTP基础上添加了安全层，通过SSL（安全套接层）或TLS（传输层安全）协议对数据进行加密和保护。它解决了HTTP不安全的问题，具有以下特点：</p><ol><li>数据加密：HTTPS使用加密技术对数据进行加密，使得第三方无法直接获取明文内容。</li><li>身份验证：HTTPS通过SSL证书对服务端进行身份验证，确保数据传输的安全性和源的可信度。</li><li>数据完整性：HTTPS使用消息摘要和数字签名等技术确保数据在传输过程中的完整性，防止数据被篡改。</li><li>SEO优化：搜索引擎对HTTPS网站有更高的权重，使用HTTPS可提升网站的排名和可信度。</li></ol><h2 id="HTTP、HTTPS对比"><a href="#HTTP、HTTPS对比" class="headerlink" title="HTTP、HTTPS对比"></a>HTTP、HTTPS对比</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309181420777.webp" alt="HTTP、HTTPS对比"></p><h2 id="HTTPS的部署"><a href="#HTTPS的部署" class="headerlink" title="HTTPS的部署"></a>HTTPS的部署</h2><p>在实际应用中，部署HTTPS需要以下步骤：</p><ol><li>购买SSL证书：选择可信、权威的证书颁发机构（CA）购买SSL证书，用于对服务端进行身份验证。</li><li>证书绑定与配置：将SSL证书绑定到Web服务器上，并进行相应的配置，以启用HTTPS协议。</li><li>重定向配置：将HTTP请求自动重定向至HTTPS，确保用户访问始终通过安全通道。</li><li>安全加固：配置服务器安全性和加密算法，采取防护措施防范潜在的安全威胁。</li></ol><p>HTTP和HTTPS是Web通信的关键协议，对保障信息的安全性和保护用户隐私起着重要作用。了解它们的特点、区别和部署流程，对于保护数据安全、提升用户体验和符合搜索引擎优化有着重要意义。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析DNS：互联网底层通信的重要基石</title>
      <link href="/posts/44850.html"/>
      <url>/posts/44850.html</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，我们不能忽视域名系统（DNS）在互联网通信中的重要性。本文将深入解析DNS，剖析其在互联网底层通信中扮演的重要角色。</p><p>DNS（Domain Name System）是一个分布式的、层次化的命名系统，用于将易于记忆的域名映射到对应的IP地址。它充当了一个“电话簿”或“黄页”的角色，提供了一个将域名转化为IP地址的服务。了解DNS的工作原理对于理解互联网通信以及开发和维护网络应用程序至关重要。</p><p>以下是DNS的关键组成部分和工作原理：</p><ol><li><p>域名空间：域名空间是域名按照层次结构组织的方式。域名由多个部分组成，以点分隔，从右向左逐级精确到更具体的标识。例如，<a href="http://www.example.com中,com是顶级域名,example是二级域名,www是三级域名./">www.example.com中，com是顶级域名，example是二级域名，www是三级域名。</a></p></li><li><p>域名服务器：域名服务器是存储域名和对应IP地址映射关系的服务器。域名服务器分为多个层次，包括根域名服务器、顶级域名服务器和权威域名服务器。它们通过递归和迭代查询的方式来解析域名。</p></li><li><p>域名解析过程：当用户在浏览器中输入一个域名时，本地计算机首先向本地域名服务器发起解析请求。如果本地域名服务器没有缓存该域名的IP地址，它将依次向根域名服务器、顶级域名服务器和权威域名服务器发起查询请求，直到找到正确的IP地址。</p></li><li><p>缓存和TTL：为了提高域名解析的速度和效率，本地域名服务器会将解析结果缓存一段时间。TTL（Time-To-Live）确定缓存的有效时间，在TTL过期之前，本地域名服务器将直接返回缓存的结果，而不再重新查询。</p></li><li><p>域名安全性：DNSSEC（DNS Security Extensions）是一种用于增强DNS安全性的扩展机制。它通过数字签名和验证来确保域名解析过程中信息的完整性和真实性，防止DNS劫持和欺骗等安全威胁。</p></li></ol><p>总结起来，DNS作为互联网底层通信的重要基石，为我们提供了域名到IP地址的映射服务。了解DNS的工作原理有助于我们更好地理解互联网通信机制，并在开发和维护网络应用程序时能够更好地利用DNS技术。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名技术：解密互联网命名系统</title>
      <link href="/posts/11682.html"/>
      <url>/posts/11682.html</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，我们经常接触和使用域名，但你知道域名背后的技术原理吗？在本文中，我们将深入探讨域名技术，揭示它们在互联网中的重要性和背后的工作原理。</p><p>域名技术是建立在互联网命名系统（DNS）之上的。DNS是一个分布式的、层次化的命名系统，用于将域名映射到与之关联的IP地址。它实现了将易于记忆的域名转换为计算机能够理解的IP地址的过程。</p><p>域名技术在互联网中起着重要作用：</p><ol><li><p>域名解析：域名解析是将域名转换为IP地址的过程。当用户在浏览器中输入一个域名时，计算机需要通过域名解析来找到该域名对应的IP地址，从而建立连接。</p></li><li><p>域名注册与管理：域名技术涉及域名的注册和管理。域名可以通过域名注册商购买，并与相应的IP地址进行关联。域名注册商负责维护域名的注册信息并提供域名管理服务。</p></li><li><p>域名服务器：域名技术涉及到域名服务器的建立和管理。域名服务器存储着域名和对应IP地址的映射关系。当用户发起域名解析请求时，域名服务器会返回对应的IP地址。</p></li><li><p>域名安全性：域名技术还与域名的安全性密切相关。域名可以成为网络攻击的目标，例如域名劫持和域名欺诈。因此，域名技术需要包括安全机制来防止域名被滥用。</p></li></ol><p>域名技术的工作原理可以简要概括如下：</p><ol><li><p>递归查询：当用户输入一个域名时，计算机首先发送查询请求给本地域名服务器。如果本地域名服务器不知道该域名对应的IP地址，它会依次向根域名服务器、顶级域名服务器和权限域名服务器发起查询请求，直到找到对应的IP地址。</p></li><li><p>域名解析链路：在查询过程中，域名服务器会根据域名的层次结构依次查询相关的域名服务器，以获取最终的IP地址。</p></li><li><p>缓存和更新：一旦域名解析完成，本地域名服务器会将结果缓存，以加快之后对相同域名的访问速度。同时，域名注册商也会提供域名管理服务，允许域名所有者更改IP地址和其他相关信息。</p></li></ol><p>总结起来，作为程序员，对域名技术的了解至关重要。域名技术涉及域名解析、域名注册与管理、域名服务器和域名安全等领域。深入理解域名技术的工作原理和安全机制，有助于我们更好地管理和保护域名，确保用户能够顺利地访问我们的网站和应用程序。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析：连接互联网的关键枢纽</title>
      <link href="/posts/330.html"/>
      <url>/posts/330.html</url>
      
        <content type="html"><![CDATA[<p>作为一名程序员，在我们日常开发和维护网站或应用程序的过程中，域名解析是一个不可或缺的环节。在本文中，我们将深入探讨域名解析的工作原理，解析其在连接互联网的过程中的关键作用。</p><p>域名解析是将易于记忆的域名转化为对应的IP地址的过程。当用户在浏览器中输入一个域名时，计算机并不知道如何直接连接到该域名对应的服务器，需要通过域名解析来找到正确的IP地址，从而建立连接。</p><p><img src="https://www.cdn.cheneyblog.com/blog/202309181411003.png" alt="域名解析的过程"></p><p>域名解析的过程可以大致分为以下几个步骤：</p><ol><li><p>发起解析请求：当用户输入一个域名时，计算机会向本地域名服务器发起解析请求。本地域名服务器通常由互联网服务提供商（ISP）或其他DNS（域名系统）服务提供商提供。</p></li><li><p>迭代查询：如果本地域名服务器不知道该域名对应的IP地址，它会向根域名服务器发起查询请求。根域名服务器存储着顶级域名服务器的地址。</p></li><li><p>顶级域名服务器查询：根域名服务器会告知本地域名服务器该域名对应的顶级域名服务器的地址。本地域名服务器再向顶级域名服务器发起查询请求。</p></li><li><p>权限域名服务器查询：顶级域名服务器会继续指引本地域名服务器向权限域名服务器发起查询请求。权限域名服务器通常由域名注册商提供。</p></li><li><p>查询结果返回：权限域名服务器会将域名对应的IP地址返回给本地域名服务器，然后由本地域名服务器将结果返回给用户的计算机。</p></li><li><p>结果缓存：为了提高解析效率，本地域名服务器会将解析结果缓存一段时间。下次用户再访问相同域名时，可以直接返回缓存的结果，从而减少查询时间。</p></li></ol><p>域名解析的过程中，还涉及到TTL（存活时间）的概念。TTL表示在重新查询之前，缓存在本地域名服务器中对应域名解析结果的有效时间。TTL的设置由域名所有者或域名注册商控制，适当的TTL设置可以提高解析效率并确保及时更新。</p><p>总结起来，作为一名程序员，深入理解域名解析的工作原理是非常重要的。域名解析将用户输入的易于记忆的域名转化为与之关联的IP地址，从而实现连接互联网的关键一步。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN：实现高速可靠的网络内容分发</title>
      <link href="/posts/31314.html"/>
      <url>/posts/31314.html</url>
      
        <content type="html"><![CDATA[<p>今天将为您介绍CDN（内容分发网络），这是一项在互联网发展中起着重要作用的技术。随着网络内容的不断增长和用户对快速、稳定访问体验的需求，CDN成为了许多网站和应用的首选解决方案。</p><p>CDN是一种分布式的网络架构，通过将内容存储在离用户更近的服务器上，实现了快速可靠的内容分发。大多数传统的网络架构采用单一服务器来存储和提供内容。当用户请求访问该服务器时，可能出现带宽瓶颈和延迟等问题。而CDN通过部署位于全球各地的边缘节点，使内容在离用户更近的地方就近提供，从而显著提高了用户体验。</p><h2 id="CDN的工作原理"><a href="#CDN的工作原理" class="headerlink" title="CDN的工作原理"></a>CDN的工作原理</h2><ol><li><p>内容复制和缓存：CDN将内容复制到分布在不同地理位置的服务器上，并根据用户访问模式进行缓存。这样，当用户请求访问某个内容时，CDN会将内容分发到离用户最近的节点上。</p></li><li><p>路由选择：CDN通过智能路由算法选择最佳的节点来提供内容。算法会考虑节点的性能、可用带宽和用户位置等因素，确保用户能够从最佳的服务器获取内容。</p></li><li><p>动态负载均衡：CDN能够根据服务器的负载情况和用户请求的分布，动态调整内容的分发策略，以保证各个节点的负载均衡，提高整体服务的可靠性和响应速度。</p></li></ol><h2 id="CDN的优势"><a href="#CDN的优势" class="headerlink" title="CDN的优势"></a>CDN的优势</h2><ul><li><p>提供快速访问体验：CDN的分布式网络架构确保内容就近存放，减少了数据传输的距离和延迟，提高了用户访问速度和响应时间。</p></li><li><p>应对网络拥塞：在大型事件、热门活动或突发事件期间，用户访问量激增可能导致服务器拥塞。CDN通过将流量分散到各个节点，减轻了服务器的负荷，保证服务的稳定性。</p></li><li><p>提高故障恢复能力：当某个节点出现故障时，CDN可以快速切换到其他正常的节点，确保内容正常提供，减少故障对用户体验的影响。</p></li><li><p>防御网络攻击：CDN可以通过分散流量和筛选非法请求等方式，帮助网站抵御大规模DDoS攻击和其他恶意行为。</p></li></ul><p>总结起来，CDN是一项为用户和网站提供高速、可靠内容传输的重要技术。它通过整合全球的网络资源和部署分布式的边缘节点，实现了内容就近分发，提高了用户的访问速度和体验，同时也增强了网站的性能和可靠性。</p><p>随着互联网的快速发展和用户对高质量内容的需求不断增长，CDN无疑将继续发挥重要作用，成为网站和应用的核心架构之一。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之稳定执行计划</title>
      <link href="/posts/1085.html"/>
      <url>/posts/1085.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-Hint"><a href="#Oracle-Hint" class="headerlink" title="Oracle Hint"></a>Oracle Hint</h2><p>&emsp;&emsp;Oracle Hints 是一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划，它允许用户在 SQL 语句中插入相关的语法，从而影响 SQL 的执行方式。</p><h3 id="Hint-的作用"><a href="#Hint-的作用" class="headerlink" title="Hint 的作用"></a>Hint 的作用</h3><ol><li>调整目标 SQL 使用的优化器类型</li><li>调整优化器的优化目标</li><li>调整表的访问路径</li><li>调整表的连接类型</li><li>调整表的连接顺序</li><li>提高语句的并行程度</li></ol><h3 id="Hint-的弊端"><a href="#Hint-的弊端" class="headerlink" title="Hint 的弊端"></a>Hint 的弊端</h3><ul><li>Hint 是比较”暴力”的一种解决方式，不是很优雅。需要开发人员手工修改代码。</li><li>Hint 不会去适应新的变化，只是在现有的基础上产生更优的执行计划。</li><li>Hint 随着数据库版本的变化，可能会有一些差异、甚至废弃的情况。</li></ul><h2 id="Oracle-stored-outline"><a href="#Oracle-stored-outline" class="headerlink" title="Oracle stored outline"></a>Oracle stored outline</h2><p>&emsp;&emsp;Oracle stored outline（存储提纲）是最早的基于提示来控制 SQL 执行计划的机制，也是 9i 以及之前版本唯一可以用来稳定和控制 SQL 执行计划的工具。主要的作用是用来保持固定 sql 语句的执行计划，让 sql 语句的执行计划在数据库环境变更（统计信息、优化器参数、表结果变更等）后还能保持原来的执行计划。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>避免 SQL 的执行计划在统计数据不准确的情况（如未能及时收集表或索引的统计信息）下导致变化从而引起的性能降低。</li><li>避免容易因为 Bind Peeking 导致 SQL 执行计划变差从而引起的性能降低。</li><li>避免大规模分布实施的应用出现数据库版本、配置等区别引起的优化器产生不同的执行计划。</li></ol><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>从 10g 以后，outline 基本已经被 Oracle 废弃并且不在维护。</li><li>只有设置 use_stored_outlines 参数后才能启用 outline。</li><li>创建 outline 需要 create any outline or execute_catelog_role 权限 。</li></ul><h2 id="SQL-Profile"><a href="#SQL-Profile" class="headerlink" title="SQL Profile"></a>SQL Profile</h2><p>&emsp;&emsp;SQL Profile 是 stored outline 的进化版，是为目标 SQL 提供除了统计信息之外的其他信息，比如运行环境、更准确的执行路径等，以帮助优化器为 SQL 语句选择更合适的执行计划。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>更容易生成、更改和控制</li><li>适用范围广</li><li>在不改变目标 SQL 文本的情况下达到稳定执行计划的效果</li></ol><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul><li>Automatic 类型的 SQL Profile<br>Automatic 类型的 SQL Profile 其实是目标 SQL 一些额外的调整信息，这些信息存储在数据字典中。Oracle 会使用类似于动态采样的方法来支持 Automatic 类型的 SQL Profile，在生成执行计划的时候 Oracle 会将调整信息同原 SQL 的相关统计信息等内容一起作用从而得到最新的执行计划</li><li>Manual 类型的 SQL Profile<br>Manual 类型 SQL Profile 的本质是一堆来源 Outline Data 部分的 Hint 组合，可以在不改变目标 SQL 文本的情况下调整其执行计划</li></ul><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>&emsp;&emsp;SQL Profile 实际上只是一种亡羊补牢、被动的技术手段，应用在那些执行计划已经发生了不好的变更的 SQL 上，即当我们发现这些 SQL 的执行计划已经出了问题时通过创建 SQL Pofle 来纠正、稳定这些 SQL 的执行计划。也就是说，即便通过创建 SQLProfile 解决了目标 SQL 执行计划变更的问题，依然不能保证系统后续执行的 SQL 的执行计划就不再发生不好的变更。</p><h2 id="SPM（SQL-Plan-Management）"><a href="#SPM（SQL-Plan-Management）" class="headerlink" title="SPM（SQL Plan Management）"></a>SPM（SQL Plan Management）</h2><p>&emsp;&emsp;SPM 是一种主动的稳定执行计划的手段，能够保证只有被验证过的执行计划才会被启用。SPM 既能够主动地稳定执行计划，又保留了继续使用新的执行效率可能更高的执行计划的机会。 SPM 启动后，每个 SQL 的所有执行计划都有对应的 SQL Plan Baseline，可以通过 DBA_SQL_PLAN_BASELINE 查看。只有 DBA_SQL_PLAN_BASELINE 表中 ENABLE 和 ACCEPTED 列的值均为’YES’的 SQL Plan Baseline 对应的执行计划才会被 Oracle 启用。</p><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><ul><li>自动捕获（Automatic Initial Plan Capture）</li></ul><ol><li>设置 OPTIMIZER_CAPTURE_SQL_PLAN_BASELINES = Ture</li><li>Oracle 自动监控执行两次以上的 SQL 语句，将执行计划记入 Plan History。</li><li>生成的第一个执行计划被标记为 ENABLED 并且是 ACCEPTED，后续的执行计划会被标记为 ENABLED 但不是 ACCEPTED。</li><li>后续如果关闭了自动捕捉，针对存在 baseline 的 SQL，仍旧会有新的 PLAN 生成，新的 Plan 仍会进入 Plan History，标记为 ENABLED 但不是 ACCEPTED。</li></ol><ul><li>手动导入（Manual Plan Capture）<br>Oracle 支持通过 DBMS_SPM 包手动管理 SPM，可以将 SQL 执行计划从高速缓存或现有的 SQL 优化集中加载到 SPM。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之其他执行计划</title>
      <link href="/posts/44822.html"/>
      <url>/posts/44822.html</url>
      
        <content type="html"><![CDATA[<h2 id="AND-EQUAL-INDEX-MERGE"><a href="#AND-EQUAL-INDEX-MERGE" class="headerlink" title="AND-EQUAL(INDEX MERGE)"></a>AND-EQUAL(INDEX MERGE)</h2><p>INDEX MERGE 是指当 where 条件中出现针对多个不同索引列的等值条件，Oracle 会分别去扫描这些索引列，然后合并每个索引的集合，找到值相同的 ROWID 最后回表。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>涉及到的索引都为单列索引<br>索引都在查询中出现<br>谓词使用=关系符号连接<br>从 Oracle 10g 开始，and_equal 操作被废弃，Oracle 不再支持，这里废弃的含义并不是被彻底移除，而是说不再进行改进，通过 hints 仍然可以强制实现 Index Merge 的 and_equal 操作。</p><h2 id="INDEX-JOIN"><a href="#INDEX-JOIN" class="headerlink" title="INDEX JOIN"></a>INDEX JOIN</h2><p>对 index 进行关联,oracle 通过 hash index join 的方式实现了避免对表的访问.所有的数据都从索引中直接获得.它不受查询条件影响,可以是唯一索引,也可以是多列索引.</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>如果不是所有数据都能从索引获得,那么将不会使用 index join</p><h2 id="VIEW"><a href="#VIEW" class="headerlink" title="VIEW"></a>VIEW</h2><p>Oracle 在处理包含视图的 SQL 时，通常会根据该视图是否能做视图合并（View Merging），即 Oracle 在执行该 SQL 时可以直接针对该视图的基表，此时 SQL 的执行计划中很可能不会出现关键字”VIEW”<br>对于某些 SQL 而言，即使 Oracle 已经做了视图合并但其所对应的执行计划中可能还是会显示关键字”VIEW”<br>如果不能做视图合并，则 Oracle 将把该视图看作一个整体并独立地执行它，此时 SQL 的执行计划中将出现关键字”VIEW”</p><h2 id="FILTER"><a href="#FILTER" class="headerlink" title="FILTER"></a>FILTER</h2><p>FILTER 直译过来就是过滤、筛选的意思，它是一种特殊的执行计划。</p><pre><code>FILTER 类型的执行计划实际上是一种改良的嵌套循环连接，FILTER的性能跟列值distinct数有关</code></pre><h3 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h3><ol><li>得到一个驱动结果集。</li><li>根据一定的过滤条件从上述驱动结果集中滤除不满足条件的记录。</li><li>结果集中剩下的记录就会返回给最终用户或者继续参与下一个执行步骤。</li></ol><h2 id="SORT"><a href="#SORT" class="headerlink" title="SORT"></a>SORT</h2><ol><li>SORT AGGREGATE<br>通常发生在使用一些聚合函数的时候，sum(),avg(),min(),max()，count（）等等，实际上 sort aggregate 不做真正的 sort，并不会用到排序空间，而是通过一个全局变量＋全表或全索引扫描来实现</li><li>SORT UNIQUE<br>需要取 distinct 值的时候或 in 子查询</li><li>SORT GROUP BY<br>发生在有 group by 子句的时候</li><li>SORT ORDER BY<br>发生在有 order by 子句的时候</li><li>SORT JOIN<br>发生在出现 merge join 的情况下，两张关联的表要各自做 sort，然后再 merge</li></ol><h2 id="UNION-UNION-ALL"><a href="#UNION-UNION-ALL" class="headerlink" title="UNION/UNION ALL"></a>UNION/UNION ALL</h2><p>UNION 和 UNIONALL 的区别是 ∶UNION ALL 仅仅是简单地将两个结果集合并，并不做任何额外的处理;而 UNION 除了将两个结果集简单合并之外，还会对合并后的结果集做排序和去重，即 UNION 相当于先做 UNION ALL，然后再对 UNIONALL 之后的结果集做 SORT UNIQUE。</p><h2 id="CONCAT"><a href="#CONCAT" class="headerlink" title="CONCAT"></a>CONCAT</h2><p>CONCAT 就是 IN-List 扩展（IN-List Expansion）或 OR 扩展（OR Expansion），IN-List 扩展/OR 扩展在执行计划中对应的关键字是”CONCATENATION”。<br>CONCATENATION 操作类似 union ,只不过与 union 不同的是他并不对全部数据去重.<br>CONCATENATION 操作只去除由 OR 引起的重复值.</p><h2 id="CONNECT-BY"><a href="#CONNECT-BY" class="headerlink" title="CONNECT BY"></a>CONNECT BY</h2><p>CONNECT BY 是 Oracle 数据库中层次查询（Hierarchical Queries）。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Cache 详解</title>
      <link href="/posts/27399.html"/>
      <url>/posts/27399.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;库缓存主要用于缓存刚刚执行过的 SQL 语句和 PL/SQL 语句（如存储过程、函数、包、触发器）所对应的执行计划、解析树（Parse Tree）、Pcode、Mcode 等，当同样的 SQL 语句和 PL/SOL 语句再次被执行时无须再次从头开始解析，从而提高 SQL 语句和 PL/SQL 语句重复执行的执行效率。V$DB_OBJECT_CACHE 视图可以查看 Library Cache 的对象。</p><h2 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h2><p><a href="https://cheneyblog.com//posts/39514.html">Library Cache 的基本结构</a></p><h2 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h2><ol><li>可以快速定位数据库对象，并找到对应的信息</li><li>Library Cache 中存储着各库缓存对象的依赖关系，解决依赖问题</li><li>Library Cache 可以并发控制，管理大量共享对象的并发访问和修改问题</li></ol><hr><p>&emsp;&emsp;当 SQL 语句传到服务器，Oracle 会先对目标 SQL 进行哈希运算，然后根据哈希值访问库缓存对象句柄链表，从而找到对应的库缓存对象句柄，重用 SQL 的执行计划、解析树而无需从头开始解析；如果找不到对应的库缓存对象句柄，则重新解析目标 SQL，将解析后的资源以库缓存对象句柄的方式链接在对应 Hash Bucket 的库缓存对象句柄链表中。</p><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>Oracle 利用 Library cache lock 和 Library cache pin 来实现并发控制，Library cache lock 是在 handle 上获取的，而 Library cache pin 则是在 data heap 上获取。访问对象时，首先必须获取 handle 上的 lock，然后将访问的数据 pin 在内存中。lock 的作用是控制进程间的并发访问，而 pin 的作用是保证数据一致性，防止数据在访问时被交换出去。</p><p>Library cache lock 有三种模式：null，share，exclusive，Library cache pin 有两种模式：share，exclusive。</p><p>每个 handle 上都有 lock 和 pin 的 holder list 和 waiter list，用来保存持有该资源和等待该资源的队列。</p><h2 id="Hash-Latch"><a href="#Hash-Latch" class="headerlink" title="Hash Latch"></a>Hash Latch</h2><p>&emsp;&emsp;当多个用户同时访问或修改 Hash Bucket 和库缓存对象句柄链表时会出现冲突,为了解决这一问题，实现用户的有序访问和共享，Oracle 生成 Hash Latch 的机制来保护这些共享资源，当一个用户需要访问或修改这些 Hash Bucket 及其库缓存对象句柄链表时，需要首先获取 Hash Latch，如果期间有其他需要获取相同 Hash Latch 的用户或会话就需要等待，直到持有该哈希 Latch 的用户释放为止.</p><pre><code>Hash Latch分类shared pool latch：分配或释放空间时使用Library cache latch：hash bucket中定位handle时使用library cache lock latch、library cache pin latch：获取lock和pin时使用</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Library Cache 的基本结构</title>
      <link href="/posts/39514.html"/>
      <url>/posts/39514.html</url>
      
        <content type="html"><![CDATA[<h2 id="图解-Library-Cache"><a href="#图解-Library-Cache" class="headerlink" title="图解 Library Cache"></a>图解 Library Cache</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309151502341.png" alt="Library Cache 基本结构1"></p><p><img src="https://www.cdn.cheneyblog.com/blog/202309151503289.png" alt="Library Cache 基本结构2"></p><h2 id="结构说明"><a href="#结构说明" class="headerlink" title="结构说明"></a>结构说明</h2><h3 id="Hash-Bucket"><a href="#Hash-Bucket" class="headerlink" title="Hash Bucket"></a>Hash Bucket</h3><p>库缓存相当于一个 Hash Table 由一组 Hash Bucket 构成，每个 Hash Bucket 存储相同哈希值的所有库缓存对象句柄，不同库缓存对象句柄间用指针连接，构成库缓存对象句柄链表（Library Cache Object Handles）</p><pre><code>Hash Bucket主要用于可执行对象的快速定位和存取</code></pre><h3 id="Library-Cache-Object-Handle"><a href="#Library-Cache-Object-Handle" class="headerlink" title="Library Cache Object Handle"></a>Library Cache Object Handle</h3><p>库缓存对象句柄(Library Cache Object Handle)是存储库缓存对象的一种结构，这些句柄包含了对象的相关属性，例如：名称、标记、指向对象内存地址的指针等。<br>Object Handle 的主要属性：</p><ol><li><p>Name<br>库缓存对象句柄对应的库缓存对象名称</p></li><li><p>Namespace<br>库缓存对象句柄对应的库缓存对象的分组名</p><table><thead><tr><th>Namespace 值</th><th>含义</th></tr></thead><tbody><tr><td>CRSR</td><td>SQL 语句和匿名 PL/SQL 语句</td></tr><tr><td>TABL/PRCD/TYPE</td><td>表、视图、序列、同义词、存储过程、函数、Type 和 Package</td></tr><tr><td>BODY/TYBD</td><td>Type 和 Package 的 Body</td></tr><tr><td>TRGR</td><td>Trigger</td></tr><tr><td>INDEX</td><td>索引</td></tr><tr><td>CLST</td><td>Cluster</td></tr></tbody></table></li><li><p>Heap 0 Pointer<br>指向子结构 Heap 0 的指针</p></li></ol><h3 id="Library-Cache-Object"><a href="#Library-Cache-Object" class="headerlink" title="Library Cache Object"></a>Library Cache Object</h3><p>Handle 对应可执行对象 Library Cache Object，通常以堆（Heap）的形式组成。Handle 中指向第一个堆的指针为 Heap 0，Heap 0 中包含指向其他堆的指针信息。</p><ol><li>dependency table<br>该对象依赖的对象信息</li><li>child table<br>对象的子对象；比如同一个父游标对应的不同子游标</li><li>authorization table<br>对象的授权信息</li><li>type<br>shared cursor,index,table,cluster,view,synonym,sequence,procedure,function,package,table body,package body,trigger 等等。</li><li>data blocks<br>data block 也是一个指针，指向了 data heap</li></ol><h3 id="Data-heap"><a href="#Data-heap" class="headerlink" title="Data heap"></a>Data heap</h3><p>Data heap 即存放真实数据的地方，主要包含库缓存对象的 SQL 语句、执行计划、执行文本等信息。</p><table><thead><tr><th>Heap</th><th>Usage</th></tr></thead><tbody><tr><td>0</td><td>Object</td></tr><tr><td>1</td><td>Source</td></tr><tr><td>2</td><td>Diana</td></tr><tr><td>3</td><td>Pcode</td></tr><tr><td>4</td><td>Mcode</td></tr><tr><td>5</td><td>Errors</td></tr><tr><td>6</td><td>SQL Context</td></tr><tr><td>7</td><td>Free</td></tr><tr><td>8</td><td>Subordinate Heaps</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之表连接</title>
      <link href="/posts/10468.html"/>
      <url>/posts/10468.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;表连接，顾名思义多个表之间用用连接条件连接在一起，使用表连接的目标 SQL 其目的就是从多个表获取存储在这些表中不同维度的数据。</p><h2 id="解析表连接-SQL-的要素"><a href="#解析表连接-SQL-的要素" class="headerlink" title="解析表连接 SQL 的要素"></a>解析表连接 SQL 的要素</h2><ol><li>目标 SQL 文本的写法<br>SQL 文本的写法决定表连接的类型：内连接、外连接、自连接<blockquote><p>自连接：同一张表内的字段做连接</p></blockquote></li><li>表连接顺序<br>不管目标 SQL 中有多少个表做连接，Oracle 在实际执行该 SQL 时都只能先两两 连接，再依次同剩下的表做连接，直到目标 SQL 中所有的表都已连接完毕。</li><li>表连接方法<br>排序合并连接、嵌套循环连接、哈希连接和笛卡尔积连接</li></ol><h2 id="表连接类型"><a href="#表连接类型" class="headerlink" title="表连接类型"></a>表连接类型</h2><ul><li>内连接（Join）<br>连接结果只包含那些完全满足连接条件的记录</li><li>外连接<ol><li>左外连接（Left Join）<br>表连接结果包含左边表的全部行，右边表满足连接条件的查询列正常显示，不满足展示 Null</li><li>右外连接（Right Join）<br>表连接结果包含右边表的全部行，左边表满足连接条件的查询列正常显示，不满足展示 Null</li><li>全外连接（Full Join）<br>表连接结果包含两张表的全部记录，满足连接条件的查询列正常显示，不满足连接条件的记录对应另外一张表展示 Null<blockquote><p>如果使用（+）操作符指定外连接,不满足连接条件时靠近操作符表的连接列以 Null 值填充,必须使用 Where 子句指定连接条件,否则会产生笛卡尔积</p></blockquote></li></ol></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>A 表：1，2，3，4，5<br>B 表：2，4，6，8，10<br><img src="https://www.cdn.cheneyblog.com/blog/202309151456976.png" alt="表连接"></p><h2 id="表连接方法"><a href="#表连接方法" class="headerlink" title="表连接方法"></a>表连接方法</h2><h3 id="排序合并连接-Sort-Merge-Join"><a href="#排序合并连接-Sort-Merge-Join" class="headerlink" title="排序合并连接(Sort Merge Join)"></a>排序合并连接(Sort Merge Join)</h3><pre><code>两个表在做表连接时用排序操作(Sort)和合并操作(Merge)来得到结果集的表连接方法</code></pre><p>执行步骤简析</p><ol><li><p>用目标 SQL 中指定的谓词分别去访问两张表，对谓词过滤后的表数据分别按照连接列排序生成结果集 1 和结果集 2。</p></li><li><p>遍历结果集 1，按照连接列的顺序依次匹配结果集 2 中的数据，最后结果集 1 和结果集 2 中所有的匹配结果就是上述排序合并连接的最终结果。</p></li></ol><p>适用场景</p><ul><li><p>通常情况下，排序合并连接的执行效率不如哈希连接，但前者的适用范围广，因为哈希连接通常只用于等值连接，而排序连接还能用于其他连接(例：&gt;,&lt;,&gt;=,&lt;=)。</p></li><li><p>通常情况下，排序合并连接不适合 OLTP(On-Line Transaction Processing)联机事务处理过程，因为排序相对而言成本较高。</p></li></ul><h3 id="嵌套循环连接-Nested-Loops-Join"><a href="#嵌套循环连接-Nested-Loops-Join" class="headerlink" title="嵌套循环连接(Nested Loops Join)"></a>嵌套循环连接(Nested Loops Join)</h3><pre><code>两张表在做表连接时依靠两层嵌套循环(外层循环和内层循环)来得到连接结果集的表连接方法。</code></pre><p>执行步骤</p><ol><li><p>首先 Oracle 优化器会按照一定的规则来决定驱动表和被驱动表。驱动表用于外层循环，被驱动表用于内层循环。</p></li><li><p>然后分别用目标 SQL 中指定的谓词去筛选数据。</p></li><li><p>接着遍历驱动表按照连接条件去匹配被驱动表中的数据，直到遍历完驱动表中的所有数据。显然驱动表有多少数据，内层循环就要做多少次。</p></li></ol><p>适用场景</p><ul><li><p>如果驱动表所对应的驱动结果集的记录数较少，同时在被驱动表的连接列上又存在唯一索引(或者在被驱动表的连接列上存在选择性比较好的非唯一性索引)，那么此时使用嵌套循环连接的执行效率就会非常高；但如果驱动表所对应的驱动结果集的记录数很多，即便被驱动表的连接列上存在索引，此时使用嵌套循环连接的执行效率也不会太高。</p></li><li><p>大表也可以作为嵌套循环连接的驱动表，关键看目标 SQL 中指定谓词条件能否将驱动结果集的数据量降下来。</p></li><li><p>嵌套循环连接有一个其他连接方法没有的优点：嵌套循环连接可以实现快速响应。</p></li></ul><blockquote><p>在 Oracle11g 中，Oracle 引入了向量 I/O(Vector I/O)。在引入向量 I/O 后，Oracle 就可以将原先一批单块读所需要消耗的物理 I/O 组合起来，然后用一个向量 I/O 去批量处理他们，这样就实现了在单块读的数据量不降低的情况下减少这些单块读所需要消耗的物理 I/O 数量，也就提高了嵌套循环连接的执行效率。</p></blockquote><h3 id="哈希连接-Hash-Join"><a href="#哈希连接-Hash-Join" class="headerlink" title="哈希连接(Hash Join)"></a>哈希连接(Hash Join)</h3><pre><code>两张表在做表连接时主要依靠哈希运算来得到连接结果集的表连接方法。</code></pre><p>执行步骤</p><ol><li>两张表在施加了目标 SQL 指定谓词条件后，结果集数量较少的将被 Oracle 选为哈希连接的驱动表，反之结果集数据量较多的选做被驱动结果集。</li><li>哈希运算会在 hash area 生成 hash bulket，并将若干 bulket 分成一组，成为一个 partition，还会生成一个 bitmap 的列表，每个 bulket 在上面占一位</li><li>对驱动表的连接列做 hash 运算，将数据分散到相应 partition 的 bulket 中，当运算完成后，如果键值唯一性较高的话，bulket 里的数据会比较均匀，也有可能有的桶里面数据会是空的，这样 bitmap 上对应的标志位就是 0，有数据的桶，标志位会是 1</li><li>再对被驱动表的连接列做 hash 运算，确定应该到某个 partition 的某个 bulket 去探测，探测之前，会看这个 bulket 的 bitmap 是否会 1，如果为 0，表示没数据，这行就直接丢弃掉，如果 bitmap 为 1，则在桶内做精确匹配，判断 OK 后，返回数据</li><li>如果驱动表或被驱动表数据量很大，在构建对应的 Hash Table 时，会出现 PGA 的工作区(Work Area)被填满的情况，这时 Oracle 会把工作区中包含记录数最多的 Hash Partition 写到磁盘上(TEMP 表空间)。</li><li>两张表都扫描完毕后，由于两边的数据都按照相同的 hash 算法做的 partition 和 bulket，现在只要成对的比较两边 partition 数据即可，并且在比较的时候，oracle 也做了优化处理，没有严格的驱动与被驱动关系，他会在 partition 对中选较小的一个作为驱动来进行，直到磁盘上所有的 partition 对都比较完成，哈希连接处理结束</li></ol><p>试用场景</p><ul><li>哈希连接只适用于 CBO，只能用于等值连接条件(即使是哈希反连接，Oracle 实际上也是将其转换成了等价的等值连接)。</li><li>当两个表作哈希连接时，如果在施加了目标 SQL 中指定谓词条件后得到的数据量较小的那个结果集所对应的 Hash Table 能够完全被容纳在内存中(PGA 的工作区)，则此时的哈希连接的执行效率会非常高。</li></ul><h3 id="笛卡尔积连接-Cross-Join"><a href="#笛卡尔积连接-Cross-Join" class="headerlink" title="笛卡尔积连接(Cross Join)"></a>笛卡尔积连接(Cross Join)</h3><pre><code>两个表在做表连接时没有任何连接条件的表连接方法。</code></pre><p>执行步骤</p><ol><li><p>首先以目标 SQL 中指定谓词条件访问表 1，得到结果集 1，记录数 m；</p></li><li><p>接着以目标 SQL 中指定谓词条件访问表 2，得到结果集 2，记录数 n；</p></li><li><p>最后对结果集 1 和结果集 2 执行合并操作，因为没有表连接条件，结果集 1 和结果集 2 连接时，结果集 1 中的任意一条记录匹配结果集 2 中的每一条记录，最终得到记录数 m*n 的结果集。</p></li></ol><blockquote><p>笛卡尔积的出现通常是由于目标 SQL 中漏写了表连接条件，笛卡尔积一般是不好的，有些情况下也可以利用笛卡尔积来减少对目标 SQL 中大表的全表扫描次数。</p></blockquote><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309181529407.png" alt="表连接执行计划对比"><br><img src="https://www.cdn.cheneyblog.com/blog/202309181556316.png" alt="让表连接提速的方法1"><br><img src="https://www.cdn.cheneyblog.com/blog/202309181557525.png" alt="让表连接提速的方法2"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之表相关执行计划</title>
      <link href="/posts/46535.html"/>
      <url>/posts/46535.html</url>
      
        <content type="html"><![CDATA[<h2 id="全表扫描（Full-Table-Scans-FTS）"><a href="#全表扫描（Full-Table-Scans-FTS）" class="headerlink" title="全表扫描（Full Table Scans, FTS）"></a>全表扫描（Full Table Scans, FTS）</h2><p>&emsp;&emsp;全表扫描是指 Oracle 在访问目标表里的数据时，会从该表所占用的第一个区（EXTENT）的第一个块（BLOCK）开始扫描，一直扫描到该表的高水位线（HWM,High Water Mark），这段范围内所有的数据块 Oracle 都必须读到。Oracle 会对这期间读到的所有数据施加目标 SQL 的 where 条件过滤，最后返回满足要求的数据。<br>&emsp;&emsp;Oracle 在做全表扫描操作时会使用多块读，在目标表数据量不大时执行效率是非常高的。全表扫描最大的问题是执行时间不稳定、不可控，会随着目标表数据量的递增而递增。<br>&emsp;&emsp;高水位线特性的副作用：即使 DELETE 删光了目标表里的所有数据，高水位线还是会在原来的位置，全表扫描的时候还是会扫描高水位线下所有的数据块。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151446539.png" alt="全表扫描（Full Table Scans, FTS）"></p><h3 id="会引起全表扫描的-SQL"><a href="#会引起全表扫描的-SQL" class="headerlink" title="会引起全表扫描的 SQL"></a>会引起全表扫描的 SQL</h3><ol><li>全模糊查询</li><li>查询条件中含有 is null</li><li>查询条件中使用了不等于操作符（&lt;&gt;、!=）</li><li>对于组合索引，如果查询条件中没有前导列，也会引起全表扫描</li><li>对字段进行表达式操作</li><li>返回的行无任何限定条件</li></ol><h2 id="ROWID-扫描（table-access-by-ROWID）"><a href="#ROWID-扫描（table-access-by-ROWID）" class="headerlink" title="ROWID 扫描（table access by ROWID）"></a>ROWID 扫描（table access by ROWID）</h2><p>&emsp;&emsp;ROWID 表示的是 Oracle 中数据行记录所在的物理存储位置，同数据块中的记录一一对应。Oracle 通过 ROWID 去定位并访问数据的方法叫 ROWID 扫描。</p><h3 id="ROWID-的两层含义"><a href="#ROWID-的两层含义" class="headerlink" title="ROWID 的两层含义"></a>ROWID 的两层含义</h3><ol><li><p>根据 SQL 语句中输入的 ROWID 值直接去访问对应的行记录<br><img src="https://www.cdn.cheneyblog.com/blog/202309151446582.png" alt="ROWID 值直接去访问对应的行记录"></p></li><li><p>通过访问相关索引，再根据索引得到的 ROWID 访问数据<br><img src="https://www.cdn.cheneyblog.com/blog/202309151447101.png" alt="根据索引得到的 ROWID 访问数据"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之优化器的模式</title>
      <link href="/posts/49498.html"/>
      <url>/posts/49498.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;优化器是 Oracle 的内置软件，可以确定执行目标 SQL 的最有效方式。优化器的模式决定 Oracle 解析目标 SQL 时所用优化器的类型，以及决定使用 CBO 时计算成本的侧重点。优化器的模式不同，CBO 计算成本值的方法也不同。控制 Oracle 优化器模式的参数为 optimizer_mode。</p><ul><li>查看参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> optimizer_mode</span><br></pre></td></tr></table></figure><ul><li>修改参数</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> optimizer_mode<span class="operator">=</span><span class="string">&#x27;CHOOSE&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="RULE"><a href="#RULE" class="headerlink" title="RULE"></a>RULE</h2><p>表示优化器采用 RBO 来解析目标 SQL。<br>是 Oracle 早期版本的一种优化模式。<br>目前 Oracle 已不再更新 RBO，也不推荐使用 RBO。</p><h2 id="CHOOSE"><a href="#CHOOSE" class="headerlink" title="CHOOSE"></a>CHOOSE</h2><p>由 RBO 到 CBO 转换时的默认值。<br>表示既可以使用 RBO 又可以使用 CBO。<br>取决于 SQL 涉及的对象是否有统计信息，有统计信息 CBO（部分有时会采样统计），否则 RBO。</p><h2 id="FIRST-ROWS-n-n-1-10-100-1000"><a href="#FIRST-ROWS-n-n-1-10-100-1000" class="headerlink" title="FIRST_ROWS_n(n=1,10,100,1000)"></a>FIRST_ROWS_n(n=1,10,100,1000)</h2><p>Oracle 采用 CBO 解析目标 SQL。<br>侧重点是最快的速度返回头 n 条记录。<br>本质上其实是 Oracle 把那些能够以最快相应速度返回头 n 条记录所对应的执行步骤的成本修改成一个很小的值（远远小于默认情况下 CBO 对同样执行步骤所计算的成本值）。</p><h2 id="FIRST-ROWS"><a href="#FIRST-ROWS" class="headerlink" title="FIRST_ROWS"></a>FIRST_ROWS</h2><p>Oracle 在解析目标 SQL 时会联合使用 CBO 和 RBO。<br>解析时采用 CBO，侧重点在于以最快的响应速度返回记录；<br>当出现一些特定的情况时，会用 RBO 中的一些内置规则来选取执行计划而不考虑成本。<br>例如用索引来避免排序</p><h2 id="ALL-ROWS"><a href="#ALL-ROWS" class="headerlink" title="ALL_ROWS"></a>ALL_ROWS</h2><p>Oracle 10G 及后续版本的默认值。<br>Oracle 用 CBO 解析目标 SQL，此时计算成本值时的侧重点在于最佳的吞吐量（即最小的系统 I/O 和 CPU 资源的消耗量）。<br>这种优化模式适合于数据查看实时性不是那么强的数据仓库、决策支持系统和面向批处理的数据库（batch-oriented databases）等。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之基于成本的优化器（CBO）</title>
      <link href="/posts/61.html"/>
      <url>/posts/61.html</url>
      
        <content type="html"><![CDATA[<h2 id="基于代价的优化方式"><a href="#基于代价的优化方式" class="headerlink" title="基于代价的优化方式"></a>基于代价的优化方式</h2><p>&emsp;&emsp;Cost-Based Optimization，简称 CBO。CBO 选择目标 SQL 执行计划的判断原则是成本，从目标 SQL 的诸多执行计划中选取成本值最小的执行路径为其执行计划，各执行路径的成本值是根据目标 SQL 中涉及到的表、索引、列等相关对象的统计信息计算出来的，实际反应执行目标 SQL 所要消耗的 I/O、CPU 和网络资源的一个估计值。</p><ul><li>I/O<br>把数据从磁盘读入内存时所需代价(Select 重点指标)</li><li>CPU<br>处理内存中数据所需的代价（排序(sort)、连接(join)操作）</li><li>网络资源<br>网络资源是指那些用了 dblink 的分布式目标 SQL，CBO 在解析该类目标 SQL 时知道在实际执行时所需要的的数据并不在本地数据库中（需要远程数据库取数），便会将网络资源消耗折算成对等的 I/O 资源消耗再进行估算。</li><li>动态采样<br>执行 SQL 所涉及对象（表、索引等）没有被分析、统计过，Oracle 就会使用动态采样，动态的收集表和索引上的一些数据信息，但这些统计信息不会记录在视图中，只在硬解析时才会使用动态采样。</li></ul><h2 id="CBO-组成"><a href="#CBO-组成" class="headerlink" title="CBO 组成"></a>CBO 组成</h2><ul><li><p>查询转化器（Query Transformer）<br>查询转换器的作用就是等价改变查询语句的形式，以便产生更好的执行计划。<br>Oracle 转换技术：视图合并（View Merging）、谓词推进（Predicate Pushing）、非嵌套子查询（Subquery Unnesting）、物化视图的查询重写（Query Rewrite With Materialized Views）</p></li><li><p>代价评估器（Estimator）<br>评估器通过计算三个值来评估各个执行计划的总体成本：选择性（Selectivity）、集的势（Cardinality）、成本（Cost）</p><ol><li><p>选择性（Selectivity）：是指施加制定谓词条件后返回结果集的记录数占未施加任何谓词条件的原始结果集的记录数的比率。选择率的值越大，就意味着返回结果集的 Cardinality 值就越大，所以估算出来的成本值也就越大。</p><hr><p>   选择率的计算公式</p><pre><code>   目标列上没有直方图且没有NULL值的情况下，对目标列做等值查询时       Selectivity = 1 / NUM_DISTINCT       ※ NUM_DISTINCT表示目标列的distinct值的数量</code></pre><hr></li><li><p>集的势（Cardinality）：指集合所包含的记录数。实际上表示对目标 SQL 某个具体执行步骤的执行结果所包含记录数的估算。某个执行步骤的 Cardinality 值越大，那么它所对应的成本值也就越大，这个执行步骤所对应的执行路径总成本值也就越大。</p><hr><p>   CBO 估算 Cardinality 公式</p><pre><code>       Computed Cardinality = Original Cardinality * Selectivity       ※ Computed Cardinality:施加指定谓词条件后返回结果集的记录数       ※ Originad Cardinality:未施加任何谓词条件的原始结果集的记录数       ※ Selectivity:选择率</code></pre><hr></li></ol></li><li><p>计划生成器（Plan Generator）<br>计划生成器会考虑可能的访问路径（Access Path）、关联方法和关联顺序，生成不同的执行计划，让查询优化器从这些计划中选择出执行代价最小的一个计划。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151440141.png" alt="query Optimizer Components"></p></li></ul><h2 id="CBO-的局限性"><a href="#CBO-的局限性" class="headerlink" title="CBO 的局限性"></a>CBO 的局限性</h2><ol><li>CBO 会默认目标 SQL 语句 where 条件中出现的各列之间是独立的，没有关联关系</li><li>CBO 会假设所有的目标 SQL 都是单独执行的，并且互不干扰</li><li>CBO 对直方图统计信息有诸多限制</li><li>CBO 在解析多表关联的目标 SQL 时，可能会漏选正确的执行计划</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之基于规则的优化器（RBO）</title>
      <link href="/posts/65395.html"/>
      <url>/posts/65395.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;基于规则的优化器（RBO）是通过编码在 Oracle 数据库中的一系列固定的规则，来决定目标 SQL 的执行计划。Oracle 事先给各种类型的执行路径定一个等级，从 1 到 15，等级 1 对应执行路径的执行效率最高，等级 15 对应执行路径的执行效率最低。对于等级相同的执行计划，oracle 根据目标对象在数据字典中缓存的顺序判断选择哪一种执行计划。在决定目标 SQL 的执行计划时，RBO 会从该 SQL 的诸多执行路径中选择一条等级最低的执行路径来作为其执行计划。<br>&emsp;&emsp;RBO 中等级 1 对应的执行路径是“single row by rowid（通过 rowID 来访问单行数据）”，等级 15 所对应的执行路径时“full table scan（全表扫描）”。</p><h2 id="RBO-的缺陷"><a href="#RBO-的缺陷" class="headerlink" title="RBO 的缺陷"></a>RBO 的缺陷</h2><ul><li>RBO 的执行计划很难调整</li><li>目标 SQL 的写法及各个对象在该 SQL 文本中出现的先后顺序都会影响执行计划</li><li>Oracle 数据中的很多新特性、功能，均不支持 RBO</li><li>没有考虑目标 SQL 所涉及对象的实际数据量</li></ul><h2 id="RBO-执行计划的调整"><a href="#RBO-执行计划的调整" class="headerlink" title="RBO 执行计划的调整"></a>RBO 执行计划的调整</h2><ul><li><p>等价改写 SQL</p><p>Number 或 Date 类型的字段加上 0,Varchar 类型拼接上空字符’’,使本来走索引的现在不走索引，对于多表连接的改变 form 后表的先后顺序可以影响表连接顺序</p></li><li><p>如果出现多条等级值相同的执行路径，改变目标 SQL 中涉及相关对象数据字典缓存（Data Dictionary Cache）的缓存顺序</p></li><li><p>如果出现多条等级值相同的执行路径，改变目标 SQL 中涉及相关对象在 SQL 文本中出现的先后顺序</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之位图索引</title>
      <link href="/posts/35895.html"/>
      <url>/posts/35895.html</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>&emsp;&emsp;目前一般我们使用的索引都是 B-Tree 索引，索引结构中存储的是键值和对应 ROWID。位图索引是指用位图表示的索引，通常创建在有大量重复值的列上，针对每个键值建立不同的位图。索引结构中主要存储键值、起止 ROWID 和位置编码，位置编码中的每一位表示键值对应数据行的有无，一个块可能指向多行数据的位置。<br><img src="https://www.cdn.cheneyblog.com/blog/202309151427035.jpg" alt="位图索引结果图"></p><ul><li>位图索引通过位图向量，表示索引键值在表中的分布</li><li>存在大量更新操作的列上不宜建位图索引，因为更新向量时相应键值涉及到的数据行都将被锁定</li></ul><h2 id="与-B-Tree-索引的区别"><a href="#与-B-Tree-索引的区别" class="headerlink" title="与 B-Tree 索引的区别"></a>与 B-Tree 索引的区别</h2><ol><li>位图索引一个键值对应一个叶子节点，B-Tree 索引一个叶子节点包含多个索引键值</li><li>位图索引使用位图向量标识键值对应数据行的分布，B-Tree 采用 Row_id 定位数据行</li><li>位图索引创建不需要排序，B-Tree 索引需要排序</li><li>位图索引允许键值为 Null，B-Tree 索引对 Null 值敏感</li><li>位图索引可以进行位运算（and、or）</li></ol><h2 id="位图索引优缺点"><a href="#位图索引优缺点" class="headerlink" title="位图索引优缺点"></a>位图索引优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>位图索引由于只存储键值的起止 Rowid 和位图,占用的空间非常少.</li><li>位图索引创建时不需要排序，创建速度快</li><li>位图索引对 Null 值不敏感</li><li>位图运算使相应查询更快</li><li>可以通过位图索引直接计数。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不适合选择度底的列</li><li>频繁的 DML 可能会导致性能问题，更新索引会产生行锁（可能锁定多行）</li><li>可能会溢出，索引数据块难于放下整个索引值，这导致低效。</li></ul><h2 id="位图索引相关执行计划"><a href="#位图索引相关执行计划" class="headerlink" title="位图索引相关执行计划"></a>位图索引相关执行计划</h2><ul><li>位图索引单键值扫描（BITMAP INDEX SINGLE VALUE）</li><li>位图索引范围扫描（BITMAP INDEX RANGE SCAN）</li><li>位图索引全扫描（BITMAP INDEX FULL SCAN）</li><li>位图索引快速全扫描（BITMAP INDEX FAST FULL SCAN）</li><li>位图按位与（BITMAP AND）</li><li>位图按位或（BITMAP OR）</li><li>位图按位减（BITMAP MINUS）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之 B-Tree 索引</title>
      <link href="/posts/26997.html"/>
      <url>/posts/26997.html</url>
      
        <content type="html"><![CDATA[<h2 id="B-Tree-索引内部结构"><a href="#B-Tree-索引内部结构" class="headerlink" title="B-Tree 索引内部结构"></a>B-Tree 索引内部结构</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309151423469.png" alt="B-Tree 索引内部结构"></p><p>&emsp;&emsp;B-Tree 是一种常见的数据结构，可以显著减少定位记录时所经历的中间过程，从而加快存取速度，主要用于 OLTP 系统（事务系统）。B-Tree 索引包含的主要组件如下：</p><ol><li>根节点（Root Node）：一个 B-Tree 索引只有一个根节点，它实际就是位于树的最顶端的分支节点。</li><li>分支节点（Branch Node）：包含指向相应索引分支块或叶子块的指针和索引键值列。</li><li>叶子节点（Leaf Node）：包含被索引键值和该键值对应的 ROWID</li><li>索引项（Index Entry）：对应每一条行记录</li></ol><h2 id="分支节点（Branch-Node）"><a href="#分支节点（Branch-Node）" class="headerlink" title="分支节点（Branch Node）"></a>分支节点（Branch Node）</h2><p>&emsp;&emsp;分支节点主要包括两部分：指针和索引键值列。</p><ul><li>指针<br>指针是指相关分支块或叶子块的块地址 RDBA。每个分支块都会有两种类型的指针，一种是 LMC（Left Most Child），比当前节点中最小的索引值还小的下一级节点块的数据块地址；另外一种是索引行记录指针即下一级节点块地址，该指针指向块的索引键值列最小值一定大于或等于该行记录的索引键值</li><li>索引键值列<br>索引键值列只要 Oracle 能区分相应的索引分支块或叶子块就行，这样既节省空间又可以快速定位下层的分支块或叶子块。</li></ul><h2 id="叶子节点（Leaf-Node）"><a href="#叶子节点（Leaf-Node）" class="headerlink" title="叶子节点（Leaf Node）"></a>叶子节点（Leaf Node）</h2><p>&emsp;&emsp;索引叶子节点也有两个指针，分别指向比当前节点最小索引值还小的叶节点块的地址，以及比当前节点最大索引值还大的叶节点块地址。通过这两个指针，把所有的叶节点串起来，形成一个双向链表。顺序遍历这个链表即可得到有序的数据。<br><strong>拓展</strong><br>唯一 B-Tree 索引，ROWID 存储在索引行的行头，Oracle 不存储该 ROWID 的长度，非唯一 B-Tree 索引则都需要存储。</p><h2 id="B-Tree-索引优势"><a href="#B-Tree-索引优势" class="headerlink" title="B-Tree 索引优势"></a>B-Tree 索引优势</h2><ul><li>所有索引叶子块在同一层，访问每一个键值的时间相同</li><li>通过索引访问数据的时间是可控的、基本稳定</li><li>B-Tree 索引自动保持平衡</li><li>不会随着表数据量的增长而性能下降。</li></ul><p><strong>特别提醒</strong><br>通过 B-Tree 索引访问数据的过程是先访问相关的 B-Tree 索引，然后再根据 ROWID 访问相应的行记录。<br>相应的会产生两部分消耗，一部分是访问索引的成本，另一部分是回表的成本。</p><h2 id="访问-B-Tree-索引的方法"><a href="#访问-B-Tree-索引的方法" class="headerlink" title="访问 B-Tree 索引的方法"></a>访问 B-Tree 索引的方法</h2><h3 id="索引唯一扫描（INDEX-UNIQUE-SCAN）"><a href="#索引唯一扫描（INDEX-UNIQUE-SCAN）" class="headerlink" title="索引唯一扫描（INDEX UNIQUE SCAN）"></a>索引唯一扫描（INDEX UNIQUE SCAN）</h3><p>WHERE 条件里是等值查询，扫描结果最多一条记录</p><h3 id="索引范围扫描（INDEX-RANGE-SCAN）"><a href="#索引范围扫描（INDEX-RANGE-SCAN）" class="headerlink" title="索引范围扫描（INDEX RANGE SCAN）"></a>索引范围扫描（INDEX RANGE SCAN）</h3><p>WHERE 条件为范围查询，扫描结果可能返回多条记录。<br>同等条件下，当目标索引的索引行数量大于 1 时，索引范围扫描所消耗的逻辑读至少会比相应的索引唯一扫描的逻辑读多 1 因为范围扫描会扫描多个叶子块。</p><h3 id="索引全扫描（INDEX-FULL-SCAN）"><a href="#索引全扫描（INDEX-FULL-SCAN）" class="headerlink" title="索引全扫描（INDEX FULL SCAN）"></a>索引全扫描（INDEX FULL SCAN）</h3><p>索引全扫描要从左至右依次顺序扫描目标索引所有叶子块的所有索引行，而索引是有序的，所以索引全扫描的执行结果也是有序的，并且是按照该索引的索引键值列来排序，这也意味着走索引全扫描能够既达到排序的效果，又同时避免了对该索引的索引键值列的真正排序操作。</p><p><strong><em>NULL 值不会在 B 树索引中存在，这意味着 Oracle 中能做索引全扫描的前提条件是目标索引至少有一个索引键值列的属性是 NOT NULL</em></strong></p><h3 id="索引快速全扫描（INDEX-FAST-FULL-SCAN）"><a href="#索引快速全扫描（INDEX-FAST-FULL-SCAN）" class="headerlink" title="索引快速全扫描（INDEX FAST FULL SCAN）"></a>索引快速全扫描（INDEX FAST FULL SCAN）</h3><p>从段头开始，读取包含位图块，root block, 所有的 branch block, leaf block，读取的顺序完全由物理存储位置决定，并采取多块读，每次读取 db_file_multiblock_read_count 个。</p><h4 id="索引快速全扫描与索引全扫描的区别"><a href="#索引快速全扫描与索引全扫描的区别" class="headerlink" title="索引快速全扫描与索引全扫描的区别"></a>索引快速全扫描与索引全扫描的区别</h4><ol><li>索引快速全扫描只适用于 CBO</li><li>索引快速全扫描可以使用多块读，也可以并行执行</li><li>索引快速全扫描的执行结果不一定是有序的</li><li>索引快速全扫描是根据索引行在磁盘上的物理存储顺序来扫描<br>索引全扫描时按照逻辑顺序从左至右依次扫描<br>对于单个索引叶子块中的索引行而言，其物理存储顺序和逻辑存储顺序一致;但对于物理存储位置相邻的索引叶子块而言，块与块之间索引行的物理存储顺序则不一定在逻辑上有序</li></ol><h3 id="索引跳跃式扫描（INDEX-SKIP-SCAN）"><a href="#索引跳跃式扫描（INDEX-SKIP-SCAN）" class="headerlink" title="索引跳跃式扫描（INDEX SKIP SCAN）"></a>索引跳跃式扫描（INDEX SKIP SCAN）</h3><p>索引跳跃式扫描使那些在 where 条件中没有对目标索引的前导列指定查询条件但同时又对该索引的非前导列指定了查询条件的目标 SQL 依然可以用上该索引。Oracle 会对该索引的前导列的所有 distinct 值做遍历，然后对原目标 SQL 做等价改写，将目标列的所有前导列的 distinct 值加进来。</p><p>Oracle 中的索引跳跃式扫描仅仅适用于那些目标索引前导列的 distinct 值数量较少、后续非前导列的可选择性又非常好的情形，因为索引跳跃式扫描的执行效率一定会随着目标索引前导列的 distinct 值数量的递增而递减。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之索引介绍</title>
      <link href="/posts/9739.html"/>
      <url>/posts/9739.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>&emsp;&emsp;索引是建立在表上的可选数据库对象，是一组排序后的的索引键。主要用于加快数据的检索，类似于书籍的目录，快速定位到目标数据。索引在物理上和逻辑上都是独立的，创建或删除索引对基表不会有影响。当对基表进行 DML 操作时 Oracle 会自动管理索引，无需手动处理。</p><h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ul><li>分区索引</li></ul><p>索引按范围（Range）或散列（Hash，Oracle 10g中引入）进行分区<br>一个分区索引可能指向任何（或全部的）表分区。</p><ul><li>B-Tree 索引</li></ul><p>B-Tree索引是一个典型的树结构，通常包含根节点、分支节点、叶子节点<br>包括正常索引或反转关键字索引</p><ul><li>位图索引</li></ul><p>位图索引主要针对大量相同值的列而创建<br>位图索引不直接存储ROWID，而是存储字节位到ROWID的映射<br>位图索引的空间占用明显小于B-Tree索引<br>位图索引不适合经常更新的表<br>关键字BitMap</p><h3 id="逻辑分类"><a href="#逻辑分类" class="headerlink" title="逻辑分类"></a>逻辑分类</h3><ul><li>单列索引</li></ul><p>索引列为单个字段</p><ul><li>组合索引</li></ul><p>索引列为多个字段，最多为32列，顺序自定义</p><ul><li>唯一索引</li></ul><p>索引列的值唯一，Oracle会自动在表的主键列上创建唯一索引，关键字UNIQUE INDEX</p><ul><li>非唯一索引</li></ul><p>索引列的值允许重复</p><ul><li>函数索引</li></ul><p>一列或多列上的基于函数表达式所创建的索引<br>表达式不能出现聚合函数<br>不能在LOB类型的列上创建<br>创建时必须具有 QUERY REWRITE 权限</p><ul><li>反向键索引</li></ul><p>反向键索引反转索引列键值的每个字节，实现索引的均匀分配<br>通常建立在值是连续增长的列上，使数据均匀地分布在整个索引上<br>关键字REVERSE</p><h2 id="创建索引原则"><a href="#创建索引原则" class="headerlink" title="创建索引原则"></a>创建索引原则</h2><ul><li>权衡索引个数与 DML 之间关系</li></ul><p>建立索引的目的是为了提高查询效率的<br>但建立的索引过多，会影响插入、删除数据的速度</p><ul><li>尽量将表和索引放在不同的表空间</li></ul><p>在读取数据时表与索引是同时进行的。<br>表与索引在一个表空间里就会产生资源竞争，放在不同的表空间最佳。</p><ul><li>创建索引会产生 Redo 信息和占用磁盘空间</li></ul><p>索引是数据库对象之一，需要分配磁盘空间去存储。<br>创建索引会产生Redo信息，对于大表创建索引时可以设置不产生日志信息。</p><ul><li>创建索引需根据具体的业务 SQL</li></ul><p>Oracle根据具体的情况判断是否走索引。<br>索引建在Where限制条件、表连接、需排序字段上。</p><ul><li>唯一索引优先</li></ul><p>如果同时存在唯一性索引和非唯一索引，oracle将使用唯一性索引而忽略非唯一索引</p><ul><li>经常用的字段放组合索引第一列</li></ul><p>组合索引只有它的第一列被where子句引用时，优化器才会使用该索引</p><ul><li>限制表中索引的数量</li></ul><p>索引会占用物理空间，会随基表数据量的增大而增大；<br>当对表中的数据进行DML时，索引也要动态的维护，降低了数据的维护速度</p><ul><li><p>小表不要建索引</p></li><li><p>对于基数大的列适合建立 B 树索引，对于基数小的列适合建立位图索引</p></li><li><p>列中有很多空值，但经常查询该列上非空记录时应该建立索引</p></li><li><p>LONG（可变长字符串数据，最长 2G）和 LONG RAW（可变长二进制数据，最长 2G）列不能创建索引</p></li></ul><h2 id="索引可选项"><a href="#索引可选项" class="headerlink" title="索引可选项"></a>索引可选项</h2><ul><li>NOSORT</li></ul><p>建立索引时会先对表记录排序再建立索引，当表数据量较多是会占用较多的时间。<br>特殊情况下，我们就可以使用该参数加快建索引的速度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) NOSORT;</span><br></pre></td></tr></table></figure><ul><li>ONLINE</li></ul><p>数据库系统默认是不允许 DML 与创建索引同时进行的，ONLINE 选项可以避免此类问题，但会延长建索引时间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) ONLINE;</span><br></pre></td></tr></table></figure><ul><li>NOLOGGING</li></ul><p>是否需要记录日志信息，一般用在在大型表上建索引，使用该参数，默认是记日志。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) NOLOGGING;</span><br></pre></td></tr></table></figure><ul><li>COMPUTE STATISTICS</li></ul><p>该参数会提示数据库建索引的同时，更新对应的统计信息。<br>当数据修改量比较大的情况下，使用该选项有可能导致执行计划的不稳定。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX IDX_TEMP_CHR_D_NOSORT <span class="keyword">ON</span> TEMP_CHR_D (LIST_ID) COMPUTE STATISTICS;</span><br></pre></td></tr></table></figure><ul><li>PARALLEL</li></ul><p>增加并发，多服务进程创建索引,通常针对大表建索引使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="comment">/*+ PARALLEL(2)*/</span> INDEX IDX_EMP_ENAME <span class="keyword">ON</span> EMP (ENAME);</span><br></pre></td></tr></table></figure><h2 id="索引失效分析"><a href="#索引失效分析" class="headerlink" title="索引失效分析"></a>索引失效分析</h2><ol><li><p>Where 条件有不等于操作符(&lt;&gt;, !=)</p></li><li><p>限定条件中有对空值的判断（Null 或 Not Null）</p></li><li><p>非函数索引，Where 条件中对索引列使用了函数</p></li><li><p>不匹配的索引数据类型</p></li><li><p>全模糊查询（’like ‘%aa’）</p></li><li><p>Union 替换 Or</p></li><li><p>用 EXISTS 替代 IN、用 NOT EXISTS 替代 NOT IN</p></li></ol><h2 id="索引相关视图"><a href="#索引相关视图" class="headerlink" title="索引相关视图"></a>索引相关视图</h2><table><thead><tr><th>视图</th><th>说明</th></tr></thead><tbody><tr><td>dba_indexes all_indexes user_indexes</td><td>这类视图显示索引的基本信息，如索引名称、索引是否压缩存储、索引段的存储等信息以及使用 dbms_stats 包或 analyze 语句生成的统计信息</td></tr><tr><td>dba_ind_columns all_ind_columns user_ind_columns</td><td>这类视图显示了被索引列的信息</td></tr><tr><td>dba_ind_expressions all_ind_expresions user_ind_expressions</td><td>这类视图显示函数索引的函数语句</td></tr><tr><td>dba_ind_statistics all_ind_statistics user_ind_statistics</td><td>这类视图显示对索引的优化统计信息</td></tr><tr><td>index_stats index_histogram</td><td>显示最近一次使用 analyze index… validate structure 语句生成的统计信息</td></tr><tr><td>v$object_usage</td><td>存储由 alter index … monitoring usage 语句生成的索引使用信息</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Oracle数据库的综合体系结构与各组成部分的作用</title>
      <link href="/posts/47150.html"/>
      <url>/posts/47150.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>Oracle数据库作为一款强大的关系型数据库管理系统，具有复杂而完善的综合体系结构。这个体系结构由物理结构、内存结构、进程结构和逻辑结构组成，它们相互协作，共同为数据库提供高效的数据存储、管理和访问。本文将深入解析Oracle数据库的综合体系结构，探讨各组成部分之间的联系以及它们对数据库的影响与作用。</p></div><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>物理结构是指数据库在磁盘上的存储方式和组织形式。它涉及到数据文件、数据块、操作系统文件系统等层面的存储结构。物理结构的设计和调优对于数据库的性能和性能是至关重要的，它直接影响着数据的读取和写入速度，以及数据库的可靠性和可用性。</p><h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p>内存结构是指Oracle数据库在内存中分配和管理的存储区域。它包括了共享池、数据库缓存、重做日志缓冲区等重要的内存组件。内存结构的设计和配置对于数据库的性能优化和响应速度具有重要影响。合理配置内存结构可以降低磁盘IO操作的频率，提升数据检索和事务处理的效率。</p><h2 id="进程结构"><a href="#进程结构" class="headerlink" title="进程结构"></a>进程结构</h2><p>进程结构是指Oracle数据库的进程组成和协作方式。它包括了实例进程、后台进程和用户进程等多个进程。不同的进程负责着不同的任务和功能，它们相互配合，保证数据库实例的正常运行和对外服务的可用性。</p><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p>逻辑结构是指数据库中数据的组织方式和访问方法，如表空间、段、区和数据文件等。它决定了数据在数据库中的存储和访问方式。逻辑结构的设计和管理对于数据的安全性、一致性和有效性具有重要影响。有效的逻辑结构设计可以提高数据的查询效率和管理灵活性。</p><h2 id="各组成部分的联系与作用"><a href="#各组成部分的联系与作用" class="headerlink" title="各组成部分的联系与作用"></a>各组成部分的联系与作用</h2><p>这四个组成部分在Oracle数据库中密切联系，相互协作，共同为数据库的运行和管理提供支持。具体来说：</p><ul><li>物理结构和内存结构之间的联系：物理结构决定了数据在磁盘上的存储方式和布局，而内存结构则管理了数据在内存中的缓存和访问。它们之间的协作可以通过减少磁盘IO操作，加快数据的读取和写入速度，提升数据库的性能。</li><li>内存结构和进程结构之间的联系：内存结构中的共享池和数据库缓存等组件被进程共享和访问，进程通过内存结构来读取和处理数据。内存结构的优化和配置可以提升进程的查询和事务处理效率，从而加快数据库的响应速度。</li><li>进程结构和逻辑结构之间的联系：进程通过逻辑结构访问和操纵数据库中的数据，如表空间、段和区等。进程的操作和管理需要依赖于逻辑结构的定义和存在。逻辑结构的设计和管理直接影响着进程的执行和数据的操作。</li></ul><div class="note info simple"><p>综合体系结构是Oracle数据库运行和管理的基石，物理结构、内存结构、进程结构和逻辑结构相互联系、相互作用，为数据库提供了高效的存储、访问和管理能力。深入理解和综合运用各组成部分的知识和技术，可以帮助数据库管理员和开发人员更好地设计、调优和管理Oracle数据库，提升数据库的性能、可靠性和可用性，为企业提供卓越的数据库服务。希望本文的介绍对您理解Oracle数据库的综合体系结构和各组成部分的作用起到了指导和启发的作用。</p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的逻辑结构与数据组织方式</title>
      <link href="/posts/24947.html"/>
      <url>/posts/24947.html</url>
      
        <content type="html"><![CDATA[<h2 id="逻辑结构图"><a href="#逻辑结构图" class="headerlink" title="逻辑结构图"></a>逻辑结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141411597.png" alt="Oracle逻辑结构图"></p><h2 id="表空间（Tablespace）"><a href="#表空间（Tablespace）" class="headerlink" title="表空间（Tablespace）"></a>表空间（Tablespace）</h2><p>表空间是 Oracle 最大的逻辑存储结构，与物理上的数据文件相对应，但是一个表空间可以拥有多个数据文件。</p><ul><li>数据表空间<br>用于存储用户数据的普通表空间。</li><li>系统表空间<br>默认的表空间，用于保存数据字典（一组保存数据库自身信息的内部系统表和视图，及用于 Oracle 内部使用的其他一些对象），保存所有的 PL/SQL 程序的源代码和解析代码，包括存储过程和函数、包、数据库触发器等，保存数据库对象（表、视图、序列）的定义。</li><li>回滚表空间<br>用于存放回滚段,每个实例最多只能使用一个撤销表空间</li><li>临时表空间<br>存储 SQL 执行过程中产生的临时数据</li></ul><h2 id="段（Segment）"><a href="#段（Segment）" class="headerlink" title="段（Segment）"></a>段（Segment）</h2><p>段是一组盘区，它是一个独立的逻辑存储结构，用于存储具有独立存储结构对象的全部数据。段一般是数据库终端用户处理最小的存储单位，当段的数据区已满，Oracle 为其分配另一个数据区，段的数据区在磁盘上可能是不连续的。</p><ul><li>数据段<br>用来存储表中所有数据；</li><li>索引段<br>用来存储表中索引的所有数据；</li><li>临时段<br>用于存储表排序或汇总时产生的临时数据</li><li>LOB 段<br>LOB 用来存储表中大型数据对象，例如 CLOB 与 BLOB</li><li>回退段<br>用于存储用户数据被修改之前的位置和值；<br>当要对用户的数据进行回退操作时，就要使用回退段。</li></ul><h2 id="区（Extent）"><a href="#区（Extent）" class="headerlink" title="区（Extent）"></a>区（Extent）</h2><p>区是 Oracle 存储分配的最小单位，它是由一个或多个数据块组成的。一个或多个区组成一个段，也就是说段的大小都是由区的个数来决定。当一个段的空间使用完之后，Oracle 会自动为该段分配成一个新的区。</p><p>用户还能够通过执行下面的命令来回收表、索引等对象中未使用的区：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">deallocate</span> unused;</span><br></pre></td></tr></table></figure><h2 id="块（Block）"><a href="#块（Block）" class="headerlink" title="块（Block）"></a>块（Block）</h2><p>块是用来管理存储空间的最基本的单位，也是最小的逻辑存储单位。块的大小由初始化参数 db_block_size 来决定，不同的 Oracle 版本的大小是不同的，但是数据库一旦创建，其大小便不可更改。虽然每个数据块可以存储不同类型的数据，但是每个数据块都具有一个相同的结构。<br><img src="https://www.cdn.cheneyblog.com/blog/202309141412149.png" alt="块结构"></p><ul><li>块头<br>包含了该数据块一般的属性信息，如数据块的物理地址、所属段类型等</li><li>表目录<br>如果数据块中存储的数据是某个表的数据，则这里存放该表的信息</li><li>行目录<br>用来存储数据块中有效的行信息</li><li>空余空间<br>指数据块还没有使用的存储空间</li><li>行空间<br>表或者索引的数据存储在行空间中，所以行空间是数据块中已经使用的存储空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的进程结构</title>
      <link href="/posts/35730.html"/>
      <url>/posts/35730.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-进程结构图"><a href="#Oracle-进程结构图" class="headerlink" title="Oracle 进程结构图"></a>Oracle 进程结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141407701.png" alt="Oracle 进程结构图"></p><h2 id="用户进程"><a href="#用户进程" class="headerlink" title="用户进程"></a>用户进程</h2><p>&emsp;&emsp;用户进程是一个与 Oracle 服务器进行交互的程序。一般的客户端软件，像 Oracle 的 sqlplus，sql developer,或者是一些驱动程序等等向数据库发送请求时即创建了用户进程。</p><h2 id="服务器进程"><a href="#服务器进程" class="headerlink" title="服务器进程"></a>服务器进程</h2><p>&emsp;&emsp;当监听程序监听到客户端来了一个请求，在创建会话时便会为其分配一个对应的服务器进程。服务器进程的主要作用就是处理连接到当前实例的用户进程的请求，对客户端发来的 sql 进行执行并返回执行结果。</p><h2 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h2><p>后台进程是 Oracle 数据库为了保持最佳系统性能和协调多个用户请求而设置的一系列后台进程。</p><h3 id="进程监控（PMON）"><a href="#进程监控（PMON）" class="headerlink" title="进程监控（PMON）"></a>进程监控（PMON）</h3><p>对故障的进程执行恢复操作，负责清理内存存储区和释放该进程所使用的资源<br>周期的检查调度进程和服务器进程的状态，对已死的进程进行重启</p><h3 id="系统监控（SMON）"><a href="#系统监控（SMON）" class="headerlink" title="系统监控（SMON）"></a>系统监控（SMON）</h3><p>当数据库实例出现故障或者系统崩溃的时候，执行恢复操作<br>定期合并字典管理的表空间中的空闲空间<br>在系统重启期间，清理表空间所有临时段<br>安装和打开数据库</p><h3 id="数据写入（DBWn）"><a href="#数据写入（DBWn）" class="headerlink" title="数据写入（DBWn）"></a>数据写入（DBWn）</h3><p>负责的将更新完的缓冲区数据写入磁盘中。以下情况发生时执行：</p><ul><li>没有可以写入的缓存空间</li><li>脏缓存达到限制（会导致搜索时间过长）1/4 满</li><li>最晚三秒钟：最晚三秒会执行一次写入</li><li>遇到检查点：遇到这个 checkpoint 便会执行写程序</li><li>表空间热备份的时候</li><li>表空间离线、只读状态</li><li>执行 Drop 操作的时候</li></ul><h3 id="日志写入（LGWR）"><a href="#日志写入（LGWR）" class="headerlink" title="日志写入（LGWR）"></a>日志写入（LGWR）</h3><p>将日志缓冲区的脏数据写进磁盘中 以下情况发生时执行：</p><ul><li>commit 写入</li><li>日志缓冲区占用率 1/3</li><li>DBWn 要写入脏缓冲区前</li></ul><h3 id="检查点进程（CKPT）"><a href="#检查点进程（CKPT）" class="headerlink" title="检查点进程（CKPT）"></a>检查点进程（CKPT）</h3><p>负责发起检查点信号，让 DBWn 开始工作<br>更新控制文件以及数据文件头</p><h3 id="归档进程（ACRn）"><a href="#归档进程（ACRn）" class="headerlink" title="归档进程（ACRn）"></a>归档进程（ACRn）</h3><p>将日志文件复制到归档日志文件中，来避免日志文件组的循环使用覆盖到已有的日志文件。<br>只有当数据库在 ARCHIVELOG 模式下，且自动归档开启的时候，系统便会启动 ARCn 进程；ARCn 包括归档方式和非归档方式。</p><h3 id="恢复器进程-RECO"><a href="#恢复器进程-RECO" class="headerlink" title="恢复器进程(RECO)"></a>恢复器进程(RECO)</h3><p>是一个用于分布式数据库配置的后台进程，它可以自动解决涉及分布式事务处理的故障。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的内存结构</title>
      <link href="/posts/14901.html"/>
      <url>/posts/14901.html</url>
      
        <content type="html"><![CDATA[<h2 id="Oracle-内存结构图"><a href="#Oracle-内存结构图" class="headerlink" title="Oracle 内存结构图"></a>Oracle 内存结构图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111341.png" alt="Oracle 内存结构图"></p><h2 id="System-Global-Aera-（SGA）"><a href="#System-Global-Aera-（SGA）" class="headerlink" title="System Global Aera （SGA）"></a>System Global Aera （SGA）</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309141111776.png" alt="SGA"></p><p>V$SGASTAT 视图提供有关 SGA 更详细的内存分配信息。</p><p>V$SGA 视图给出了系统全局区(System Global Area，SGA)内存结构的摘要信息。</p><h3 id="数据库缓存区（Database-Buffer-Cache）"><a href="#数据库缓存区（Database-Buffer-Cache）" class="headerlink" title="数据库缓存区（Database Buffer Cache）"></a>数据库缓存区（Database Buffer Cache）</h3><p>&emsp;&emsp;用于缓存当前或最近使用的从磁盘读取的数据块的拷贝，来优化数据库的 I/O 减少物理读/写。Oralce 依据 LRU 算法对该内存区域进行 block-level 的更新。数据高速缓存块又由以下几个缓存块组成：</p><ul><li>脏缓存块（Dirty buffers）<br>保存被修改过并且 commit 但未写入磁盘数据的缓存块，脏缓存块最终被 DBWn 进程写入到硬盘的数据文件中永久保存。</li><li>命中缓存块（Pinned buffers）<br>保存最近正在被访问的缓存块，始终被保留在数据高速缓存中，不会被写入数据文件。</li><li>空闲缓存块（Free buffers）<br>该缓存块中没有数据，等待被写入数据。oracle 从数据文件中读取数据后，寻找空闲缓存块，以便写入其中。</li></ul><h3 id="日志缓冲区（Redo-Log-Buffer）"><a href="#日志缓冲区（Redo-Log-Buffer）" class="headerlink" title="日志缓冲区（Redo Log Buffer）"></a>日志缓冲区（Redo Log Buffer）</h3><p>&emsp;&emsp;日志缓冲区是一块比较小的内存区域，它是用来短期存储将写入到磁盘中的重做日志信息。日志缓冲区也是为了减少磁盘 IO，减少用户的等待时间。</p><h3 id="共享池（Shared-Pool）"><a href="#共享池（Shared-Pool）" class="headerlink" title="共享池（Shared Pool）"></a>共享池（Shared Pool）</h3><ul><li><p>数据字典缓存区（Data Dictionary Cache）<br>用于存放 SQL 语句相关的数据文件、表、索引、列、用户、其他的数据对象的定义和权限信息等。</p></li><li><p>库缓存区（Librabry Cache）<br>共享 SQL 和 PL/SQL 代码。服务器进程在执行语句时，首先会匹配库缓存，如果存在相同语句则无需编译直接使用已编译的执行计划。<br>绑定变量不是在编译阶段赋值的，而是在运行阶段赋值的，因此含有绑定变量的 SQL 语句可以不用重新编译。</p></li><li><p>SQL 和 PL/SQL 结果缓存（Server Result Cache）<br>用于存储 SQL 查询或 PL/SQL 函数的结果，以加快其将来的执行速度。</p></li></ul><h3 id="大池（Large-Pool）"><a href="#大池（Large-Pool）" class="headerlink" title="大池（Large Pool）"></a>大池（Large Pool）</h3><p>&emsp;&emsp;大池是个可选的内存区域，可提供一个大的缓冲区供数据库的备份与恢复操作过程使用。数据库的备份恢复、执行具有大量排序操作的 SQL 语句、并行化的数据库操作时可能需要用到大池。</p><h3 id="Java-池（Java-Pool）"><a href="#Java-池（Java-Pool）" class="headerlink" title="Java 池（Java Pool）"></a>Java 池（Java Pool）</h3><p>&emsp;&emsp;JAVA 池在数据库中支持 JAVA 的运行，存放 JAVA 代码和 JAVA 语句的语法分析表。</p><h3 id="流池（Stream-Pool）"><a href="#流池（Stream-Pool）" class="headerlink" title="流池（Stream Pool）"></a>流池（Stream Pool）</h3><p>&emsp;&emsp;用于缓存流进程在数据库间移动/复制数据时使用的队列消息。一般从重做日志中提取变更记录的进程和应用变更记录的进程会用到流池。</p><h2 id="Program-Global-Aera-（PGA）"><a href="#Program-Global-Aera-（PGA）" class="headerlink" title="Program Global Aera （PGA）"></a>Program Global Aera （PGA）</h2><p>&emsp;&emsp;PGA 是指单个服务器进程或者单个后台进程所需的数据和控制信息。PGA 是在用户进程连接到数据库并创建一个会话时自动分配。该区域内保留每个与 oracle 数据库连接的用户进程所需的内存，当一个用户会话结束，PAG 就会释放。</p><ol><li>Private SQL area：包含绑定信息、运行时的内存结构。每个发出 sql 语句的会话，都有一个 private SQL area（私有 SQL 区）<br><strong>专有服务器连接私有 SQL 区在 PGA 中，共享服务器连接私有 SQL 区在 SGA 中。</strong></li><li>Session memory：为保存会话中的变量以及其他与会话相关的信息，而分配的内存区。</li></ol><ul><li>排序区<br>当用户需要对数据进行排序时，系统会将需要排序的数据保存到 PGA 中的排序区内，然后在这个排序区内对这些数据进行排序。如果发现用户的很多操作都需要用到排序，那么为用户设置比较大的排序区，可以提高用户访问数据的效率。</li><li>会话区<br>会话区保存了会话所具有的权限、角色、性能统计等信息，通常都是由数据库系统自我维护。</li><li>堆栈区<br>保存着绑定变量、会话变量、SQL 语句运行时的内存结构等重要的信息，通常都是由数据库系统自我维护</li><li>游标区<br>游标区是一个动态的区域，当用户执行游标语句打开游标时，系统会在 PGA 中创建游标区，当关闭游标时，这个区域就会被释放。创建与释放需要占用一定的系统资源，花费一定的时间，如果频繁的打开和关闭游标，就会降低语句的执行性能。</li></ul><h2 id="User-Global-Aera-（UGA）"><a href="#User-Global-Aera-（UGA）" class="headerlink" title="User Global Aera （UGA）"></a>User Global Aera （UGA）</h2><p>&emsp;&emsp;为用户进程存储会话状态。UGA 可以作为 SGA 或者 PGA 的一部分，如果通过一个共享服务器连接，UGA 包含在 SAG 中；如果通过一个专有服务器连接，UGA 就包含在专有服务器的 PGA 中。</p><h2 id="Software-code-areas"><a href="#Software-code-areas" class="headerlink" title="Software code areas"></a>Software code areas</h2><p>&emsp;&emsp;Oracle 存放自身软件代码的一部分内存区，不允许其他会话访问。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Oracle数据库的物理结构：文件组织与作用详解</title>
      <link href="/posts/565.html"/>
      <url>/posts/565.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>在Oracle数据库中，物理结构是数据库存储的基础，各种文件扮演着重要的角色。本文将为您深入介绍Oracle数据库的物理结构，特别是不同类型的文件以及它们的作用。我们将逐步介绍数据文件、控制文件、重做日志文件和参数文件，并详细解释这些文件在Oracle数据库中的重要性和功能。让我们一起来了解Oracle数据库中的物理结构与文件组织吧！</p></div><h2 id="数据文件（Data-file）"><a href="#数据文件（Data-file）" class="headerlink" title="数据文件（Data file）"></a>数据文件（Data file）</h2><p>数据文件是Oracle数据库中存储实际数据的文件。每个表空间在磁盘上都有一个或多个关联的数据文件，它们保存了表和索引的物理数据。数据文件的扩展名为.dbf。数据文件是Oracle数据库的核心组成部分。</p><h3 id="数据文件特性"><a href="#数据文件特性" class="headerlink" title="数据文件特性"></a>数据文件特性</h3><ol><li>每个数据文件对应一个数据库，一个数据库可以对应多个数据文件</li><li>数据文件可以自动扩展</li><li>数据文件专属于一个表空间，一个表空间可以拥有多个数据文件。</li></ol><h2 id="控制文件（Control-file）"><a href="#控制文件（Control-file）" class="headerlink" title="控制文件（Control file）"></a>控制文件（Control file）</h2><p>控制文件是Oracle数据库的重要组成部分，用于跟踪数据库的结构和状态。它记录了数据库的结构信息，包括数据文件、日志文件和数据库参数的位置和状态信息。控制文件还包含数据库的日志序列号，用于恢复和故障恢复。通常情况下，一个数据库有一个主控制文件和多个备用控制文件。</p><h2 id="重做日志文件（Redo-log-file）"><a href="#重做日志文件（Redo-log-file）" class="headerlink" title="重做日志文件（Redo log file）"></a>重做日志文件（Redo log file）</h2><p>重做日志文件（也称为事务日志文件）是用于保护数据库事务完整性和恢复的关键组件。重做日志文件记录了对数据库所做的所有更改，包括数据修改和结构变化。这些文件存储了对数据库的更改操作，以便在发生故障时进行恢复。重做日志文件通常以循环方式使用，即当一个日志文件被填满后，会切换到下一个日志文件。</p><h2 id="参数文件（Parameter-file）"><a href="#参数文件（Parameter-file）" class="headerlink" title="参数文件（Parameter file）"></a>参数文件（Parameter file）</h2><p>参数文件是Oracle数据库的配置文件，用于存储数据库的初始化参数设置。它包含了数据库的各种配置选项，如内存分配、日志记录级别、网络设置等。参数文件通常具有一个默认名称（如”init.ora”或”spfile.ora”），并且位于数据库实例的启动目录中。参数文件是在启动数据库实例时被读取和加载的。</p><h2 id="归档日志文件（Archived-Log-files）"><a href="#归档日志文件（Archived-Log-files）" class="headerlink" title="归档日志文件（Archived Log files）"></a>归档日志文件（Archived Log files）</h2><p>归档日志文件用来对写满的重做日志文件进行保存复制。其目的是为了长期保存日志以便于恢复。<br>数据库要运行归档模式下,如果数据不运行归档模式下,那么重做日志就循环覆盖写</p><h2 id="告警文件"><a href="#告警文件" class="headerlink" title="告警文件"></a>告警文件</h2><p>告警文件用于记录数据库启动后，用户操作上出现的问题或者数据库本身的问题，它时刻伴随着数据库。</p><div class="note info simple"><p>在Oracle数据库中，不同类型的文件起着关键的作用，确保数据库的正常运行和数据的完整性。从数据文件存储实际数据，到控制文件跟踪数据库的结构和状态，再到重做日志文件记录数据库的更改操作，以及参数文件存储数据库的各种配置选项，每个文件都具有独特的功能和重要性。了解文件的组织和作用对于维护和管理Oracle数据库至关重要。</p></div><p>希望本文的介绍能够帮助您更好地理解和应用Oracle数据库的物理结构，以及不同类型的文件在数据库中的作用。通过合理管理和配置这些文件，您可以确保数据库的稳定性和性能优化。祝您在使用Oracle数据库时取得更好的效果！</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加速查询优化——深入了解Oracle Hint</title>
      <link href="/posts/24522.html"/>
      <url>/posts/24522.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>引言：<br>在Oracle数据库中，查询性能的优化一直是DBA和开发人员关注的焦点。作为Oracle数据库的高级功能之一，Oracle Hint（提示）可以直接指导执行计划的生成，对于提高查询性能至关重要。</p></div><h2 id="什么是Oracle-Hint？"><a href="#什么是Oracle-Hint？" class="headerlink" title="什么是Oracle Hint？"></a>什么是Oracle Hint？</h2><p>Oracle Hint是一种以注释形式嵌入SQL语句中的指令，其目的是引导数据库优化器生成更优化的查询执行计划。通过使用Hint，我们可以直接干预执行计划的生成过程，以最大程度地提高查询性能。</p><h2 id="常用Hint"><a href="#常用Hint" class="headerlink" title="常用Hint"></a>常用Hint</h2><table><thead><tr><th>Oracle Hint</th><th>作用与使用场景</th></tr></thead><tbody><tr><td>ALL_ROWS</td><td>以最佳的性能获取所有行的方式进行查询</td></tr><tr><td>FIRST_ROWS(n)</td><td>指示优化器返回前n行结果，适用于需要快速返回部分结果的查询</td></tr><tr><td>INDEX(table_name index)</td><td>强制使用指定索引进行查询</td></tr><tr><td>FULL(table_name)</td><td>强制执行全表扫描，避免使用索引</td></tr><tr><td>ORDERED</td><td>强制按照查询中表出现的顺序连接表</td></tr><tr><td>USE_HASH(table_name)</td><td>强制使用哈希连接算法来连接表</td></tr><tr><td>USE_MERGE(table_name)</td><td>强制使用合并连接算法</td></tr><tr><td>LEADING(table_name)</td><td>指定连接的顺序</td></tr><tr><td>USE_CONCAT(table_name)</td><td>合并多个表的全表扫描</td></tr><tr><td>PARALLEL(table_name, n)</td><td>指示查询并行执行</td></tr><tr><td>INDEX_ASC(table_name)</td><td>强制使用升序索引进行查询</td></tr><tr><td>INDEX_DESC(table_name)</td><td>强制使用降序索引进行查询</td></tr><tr><td>PUSH_PRED(table_name)</td><td>提前将谓词推入到视图或子查询中进行评估</td></tr><tr><td>UNNEST(table_name)</td><td>对表的嵌套子查询进行展开</td></tr><tr><td>NO_MERGE(table_name)</td><td>禁止合并表达式计算</td></tr><tr><td>NO_PUSH_PRED(table_name)</td><td>禁止将谓词推入到视图或子查询中进行评估</td></tr><tr><td>USE_CUBE(table_name)</td><td>使用立方体优化进行查询</td></tr><tr><td>VECTOR_TRANSFORM(table_name)</td><td>使用向量转换技术进行查询</td></tr><tr><td>REWRITE(table_name)</td><td>使用查询重写技术进行优化</td></tr><tr><td>OPT_PARAM(‘optimizer_feature_enable’, ‘false’)</td><td>禁用特定的优化器功能</td></tr></tbody></table><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>例子1：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ INDEX(orders order_date_idx) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> orders</span><br><span class="line"><span class="keyword">WHERE</span> order_date <span class="keyword">BETWEEN</span> <span class="string">&#x27;2022-01-01&#x27;</span> <span class="keyword">AND</span> <span class="string">&#x27;2022-12-31&#x27;</span>;</span><br></pre></td></tr></table></figure><p>在上述查询中，我们使用Hint “INDEX(orders order_date_idx)”，强制优化器使用名为”order_date_idx”的索引来执行查询。这可以提高查询性能，尤其在处理大量数据时效果显著。</p><p>例子2：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ PARALLEL(employees, 8) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “PARALLEL(employees, 8)”，指示优化器使用8个并行进程来执行查询，提高查询效率和并行处理能力。</p><p>例子3：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ LEADING(dept, emp) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> departments dept</span><br><span class="line"><span class="keyword">JOIN</span> employees emp <span class="keyword">ON</span> dept.department_id <span class="operator">=</span> emp.department_id;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “LEADING(dept, emp)”，强制优化器按照给定的连接顺序连接表，以达到更好的性能。</p><p>例子4：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ USE_HASH(customers, orders) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> customers</span><br><span class="line"><span class="keyword">JOIN</span> orders <span class="keyword">ON</span> customers.customer_id <span class="operator">=</span> orders.customer_id;</span><br></pre></td></tr></table></figure><p>在以上查询中，我们使用Hint “USE_HASH(customers, orders)”，指示优化器使用哈希连接算法来连接customers表和orders表，以提升查询效率。</p><p>例子5：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="comment">/*+ OPT_PARAM(&#x27;optimizer_feature_enable&#x27;, &#x27;false&#x27;) */</span> <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>在此查询中，我们使用Hint “OPT_PARAM(‘optimizer_feature_enable’, ‘false’)”，禁用特定的优化器功能，以便在特定情况下获得更好的查询性能。</p><h2 id="Hint使用规范"><a href="#Hint使用规范" class="headerlink" title="Hint使用规范"></a>Hint使用规范</h2><ol><li>谨慎使用：仅在需要进行特定优化时使用Hint，并在使用前进行全面测试和评估。</li><li>避免过度使用：过度使用Hint可能导致查询性能下降或不稳定。</li><li>Hint的适应性：使用Hint时要考虑数据库结构、数据规模和查询需求的特点，选择适应性强的Hint。</li><li>统计信息更新：使用Hint可能会影响优化器对表和索引的统计信息的收集和更新，应及时更新相关统计信息。</li><li>版本兼容性：不同版本的Oracle数据库对Hint的支持和效果可能有所差异，应根据具体版本权衡使用。</li></ol><blockquote><p>结语：<br>通过合理使用Oracle Hint，我们可以直接干预查询执行计划的生成过程，从而优化查询性能。在使用Hint时，我们需要根据实际需求和数据库环境进行选择和测试，并注意遵循使用Hint的最佳实践和注意事项。希望本文的介绍和示例能够帮助您更好地理解和应用Oracle Hint，并在优化查询性能的过程中取得更好的效果。祝您的查询性能优化顺利！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何根据执行计划识别低效SQL</title>
      <link href="/posts/20503.html"/>
      <url>/posts/20503.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309140949942.png" alt="总结1"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看懂执行计划之执行顺序</title>
      <link href="/posts/12101.html"/>
      <url>/posts/12101.html</url>
      
        <content type="html"><![CDATA[<h2 id="口诀"><a href="#口诀" class="headerlink" title="口诀"></a>口诀</h2><p>  最右最上先执行</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>从上往下，第一个没有子节点的步骤先执行</li><li>对于兄弟节点，即靠上的节点先执行</li><li>所有兄弟节点执行完以后，执行父节点</li></ol><hr><ol><li>缩进最深的，最先执行</li><li>缩进深度相同的，先上后下</li></ol><h2 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h2><p>从上至下，从右向左</p><p>  由上至下：在执行计划中一般含有多个节点，相同级别(或并列)的节点，靠上的优先执行，靠下的后执行<br>  从右向左：在某个节点下还存在多个子节点，先从最靠右的子节点开始执行。</p><p>&emsp;&emsp;先从最开头一直连续往右看，直到看到最右边的并列的地方;对于不并列的，靠右的先执行;如果见到并列的，就从上往下看，对于并列的部分，靠上的先执行。</p><h2 id="格式化显示父子关系"><a href="#格式化显示父子关系" class="headerlink" title="格式化显示父子关系"></a>格式化显示父子关系</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id, parent_id, operation</span><br><span class="line">  <span class="keyword">from</span> (<span class="keyword">select</span> level lvl,</span><br><span class="line">               id,</span><br><span class="line">               parent_id,</span><br><span class="line">               lpad(<span class="string">&#x27; &#x27;</span>, level) <span class="operator">||</span> operation <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span> options <span class="operator">||</span> <span class="string">&#x27; &#x27;</span> <span class="operator">||</span></span><br><span class="line">               object_name <span class="keyword">as</span> operation</span><br><span class="line">          <span class="keyword">from</span> plan_table</span><br><span class="line">         <span class="keyword">start</span> <span class="keyword">with</span> id <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">connect</span> <span class="keyword">by</span> prior id <span class="operator">=</span> parent_id)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> lvl <span class="keyword">desc</span>, id;</span><br></pre></td></tr></table></figure><p>  该SQL必须同explain plan for 在同一个session（即同一个窗口执行）</p><h2 id="查看执行顺序工具"><a href="#查看执行顺序工具" class="headerlink" title="查看执行顺序工具"></a>查看执行顺序工具</h2><ul><li><p>PL/SQL Developer 快捷键 F5<br><img src="https://www.cdn.cheneyblog.com/blog/202309140926628.png" alt="示例"></p></li><li><p>XPLAN 包<br><img src="https://www.cdn.cheneyblog.com/blog/202309140927069.png" alt="XPLAN 包"><br><img src="https://www.cdn.cheneyblog.com/blog/202309140943310.png" alt="扫码获取xplan包"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划</title>
      <link href="/posts/54365.html"/>
      <url>/posts/54365.html</url>
      
        <content type="html"><![CDATA[<h2 id="获取执行计划的方法"><a href="#获取执行计划的方法" class="headerlink" title="获取执行计划的方法"></a>获取执行计划的方法</h2><p><a href="https://cheneyblog.com//posts/16791.html">获取执行计划之 Autotrace</a><br><a href="https://cheneyblog.com//posts/21084.html">获取执行计划之 explain plan for</a><br><a href="https://cheneyblog.com//posts/8170.html">获取执行计划之 dbms_xplan.display_cursor()</a><br><a href="https://cheneyblog.com//posts/51893.html">获取执行计划之 dbms_xplan.display_awr()</a><br><a href="https://cheneyblog.com//posts/53050.html">获取执行计划之 10046 事件</a><br><a href="https://cheneyblog.com//posts/24823.html">获取执行计划之 10053 事件</a><br><a href="https://cheneyblog.com//posts/28768.html">获取执行计划之 AWR</a></p><h2 id="适用场合分析"><a href="#适用场合分析" class="headerlink" title="适用场合分析"></a>适用场合分析</h2><ol><li>简单获取执行计划的方法：explain plan for 或 set autotrace on</li><li>获取目标 SQL 的多个执行计划：dbms_xplan.display_cursor 或 AWR 报告</li><li>有函数，存在多层调用：10046 事件</li><li>表被访问次数：dbms_xplan.display_cursor 搭配 ALTER SESSION SET STATISTICS_LEVEL = ALL</li><li>获取真实执行计划：除 explain plan for 和 SET AUTOTRACE TRACEONLY EXPLAIN 外</li><li>dbms_xplan.display_cursor()与 set autotrace traceonly exp 的区别在于当 SQL 有绑定变量时，1 更准确(毕竟 sql 先执行再获取的执行计划)，2 可能不准确，其他情况下两者获取的执行计划基本一样</li></ol><h2 id="指标总结"><a href="#指标总结" class="headerlink" title="指标总结"></a>指标总结</h2><ol><li>sql 执行多次不改变 arraysize(一次提取操作在网络回路中传输的可能的数据行数)的情况下，每次的 consistent gets 不会变</li><li>sql 执行一次改变一次 arraysize 的情况下，每次的 consistent gets 会变，Arraysize 越大每次从数据块中获取的行数将得到提高，相同行数情况下，访问数据块的次数自然减小，逻辑读也就相应的降低。</li><li>arraysize 参数如果过低，会影响如 physical reads，consistent gets 还有 SQL*Net roundtrips to/from client 次数。</li><li>执行计划中的 Cost (%CPU)等于 v$sql_plan.COST</li><li>只是一个 select(非 select for update)时，db block gets 是 0</li></ol><blockquote><p>引用《收获，不止SQL优化》中的总结</p></blockquote><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p><img src="https://www.cdn.cheneyblog.com/blog/202309131548538.png" alt="总结1"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131550078.png" alt="总结2"></p></div>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 AWR</title>
      <link href="/posts/28768.html"/>
      <url>/posts/28768.html</url>
      
        <content type="html"><![CDATA[<h2 id="AWR"><a href="#AWR" class="headerlink" title="AWR"></a>AWR</h2><p>&emsp;&emsp;AWR（Automatic Workload Repository 自动工作负载库）。AWR 报告是进行日常数据库性能评定、问题 SQL 发现的重要手段。可以自动采集 Oracle 运行中的负载信息，并生成与性能相关的统计数据。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;AWR 报告的原理是基于 Oracle 数据库的定时镜像功能。Oracle 数据库后台进程会以一定间隔收集系统的快照信息，并且保存在数据库中。AWR 通过比对两次快照收集到的统计信息来生成对应的报表数据。<br>AWR 来源：<code>V$ACTIVE_SESSION_HISTORY</code><br>AWR 开关参数：<code>CONTROL_MANAGEMENT_PACK_ACCESS</code><br>采样频率和保存时间配置表：<code>DBA_HIST_WR_CONTROL</code>。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>sqlplus 运行 awrrpt.sql 脚本</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>选择报告生成格式<br><img src="https://www.cdn.cheneyblog.com/blog/202309131531894.png" alt="报告生成格式"></p></li><li><p>选择生成报告日期，缺省值最近 7 天<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532123.png" alt="生成报告日期"></p></li><li><p>选择 snpID<br><img src="https://www.cdn.cheneyblog.com/blog/202309131532557.png" alt="snpID"></p></li><li><p>选择报告保存路径以及名字，默认路径为当前 CMD 目录<br><img src="https://www.cdn.cheneyblog.com/blog/202309131533376.png" alt="AWR名称"><br><img src="https://www.cdn.cheneyblog.com/blog/202309131534637.png" alt="awr完成"></p></li><li><p>根据上面的 awr 报告中，找出花费时间比较长的单条 sql 语句的执行计划<br><img src="https://www.cdn.cheneyblog.com/blog/202309131534339.png" alt="Elapsed Time"><br>我们这里以<strong>f7d3m1dh7bjkg</strong>为例</p></li><li><p>运行 awrsqrpt</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@?<span class="operator">/</span>rdbms<span class="operator">/</span>admin<span class="operator">/</span>awrsqrpt.sql</span><br></pre></td></tr></table></figure></li><li><p>重复执行第二、三、四步</p></li><li><p>选择查看执行计划的 sql_id<br><img src="https://www.cdn.cheneyblog.com/blog/202309131535419.png" alt="sql_id"></p></li><li><p>默认名称生成对应 SQL 的执行计划</p></li></ol><h2 id="Awrsqrpt-报告详解"><a href="#Awrsqrpt-报告详解" class="headerlink" title="Awrsqrpt 报告详解"></a>Awrsqrpt 报告详解</h2><ul><li><p>SQL Summary<br>SQL 摘要包括 sql_id、执行时间、执行工具及 SQL 文本<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536846.png" alt="sql摘要"></p></li><li><p>SQL plan<br>SQL_ID 对应的执行计划，如果存在多个则会有多条记录，对应的 Plan Hash Value 不同<br><img src="https://www.cdn.cheneyblog.com/blog/202309131536439.png" alt="sqlplan"></p></li><li><p>Plan Statistics<br>执行计划统计信息<br><img src="https://www.cdn.cheneyblog.com/blog/202309131537857.png" alt="plan_statistics"></p></li><li><p>Execution Plan<br>目标 SQL 对应执行步骤<br><img src="https://www.cdn.cheneyblog.com/blog/202309131538844.png" alt="Execution Plan"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_awr()</title>
      <link href="/posts/51893.html"/>
      <url>/posts/51893.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>  目标SQL的执行计划被Oracle采集到AWR Reponsitory中</p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><ol><li><p>查看 <code>CONTROL_MANAGEMENT_PACK_ACCESS</code>、<code>STATISTICS_LEVEL</code> 参数</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">PARAMETER</span> control_management_pack_access</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">parameter</span> STATISTICS_LEVEL</span><br></pre></td></tr></table></figure><p> 以上两个参数用于控制诊断和调优包的使用<br> <code>CONTROL_MANAGEMENT_PACK_ACCESS</code> 应该被设置为 DIAGNOSTIC+TUNING 诊断和调优模式<br> DIAGNOSTIC 为确保启用自动数据库诊断监视器，包括 AWR、ADDM<br> TUNING 显示一 sql 推断信息和调优建议，包括 SQL Tuning Advisor,、SQLAccess Advisor</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> control_management_pack_access<span class="operator">=</span>&quot;DIAGNOSTIC+TUNING&quot;;</span><br></pre></td></tr></table></figure></li><li><p>执行测试 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="number">1</span>) <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查询 Shared Pool 中是否已经缓存了 <code>select count(1) from emp</code> 的执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131528480.png" alt="缓存记录"></p></li><li><p>手工收集 AWR 报告，清空 Shared Pool 缓冲池</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exec</span> dbms_workload_repository.create_snapshot();</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> flush shared_pool;</span><br><span class="line"><span class="keyword">select</span> t.SQL_TEXT,t.SQL_ID,t.VERSION_COUNT,t.EXECUTIONS <span class="keyword">from</span> v$sqlarea t <span class="keyword">where</span> t.SQL_TEXT <span class="keyword">like</span> <span class="string">&#x27;%select count(1) from emp%&#x27;</span>;</span><br></pre></td></tr></table></figure><p> <img src="https://www.cdn.cheneyblog.com/blog/202309131529745.png" alt="清空缓存池"></p></li><li><p>使用 dbms_xplan.display_awr(‘sql_id’)查看执行计划</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display_awr(<span class="string">&#x27;9r5a71wx8rpr1&#x27;</span>));</span><br></pre></td></tr></table></figure></li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><br>可以得到真实的执行计划</li><li><strong>缺点</strong><br>该方法不能显示谓词信息，是因为从 <code>V$SQL_PLAN</code> 导入 AWR 基表 <code>WRH$_SQL_PLAN</code> 时未将谓词字段 access_predicates 和 filter_predicates 导入</li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10053 事件</title>
      <link href="/posts/24823.html"/>
      <url>/posts/24823.html</url>
      
        <content type="html"><![CDATA[<h2 id="10053"><a href="#10053" class="headerlink" title="10053"></a>10053</h2><p>  10053事件提供了Oracle如何选择执行计划，为什么会得到这样的执行计划信息。<br>  10053事件的trace文件，只能阅读原始的trace文件，不能使用tkprof工具来处理。</p><h2 id="10053-事件级别"><a href="#10053-事件级别" class="headerlink" title="10053 事件级别"></a>10053 事件级别</h2><ul><li>Level 2<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li><li>Level 1<br>Parameters used by the optimizer<br>Index statistics<br>Column statistics<br>Single Access Paths<br>Join Costs<br>Table Joins Considered<br>Join Methods Considered (NL/MS/HA)</li></ul><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><ol><li><p>启用 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS<span class="operator">=</span><span class="string">&#x27;10053 trace name context forever, level 1&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>确定 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> D.VALUE <span class="operator">||</span> <span class="string">&#x27;\&#x27;</span> <span class="operator">||</span> <span class="built_in">LOWER</span>(RTRIM(I.INSTANCE, CHR(<span class="number">0</span>))) <span class="operator">||</span> <span class="string">&#x27;_ora_&#x27;</span> <span class="operator">||</span>P.SPID <span class="operator">||</span> <span class="string">&#x27;.trc&#x27;</span> <span class="keyword">AS</span> &quot;trace_file_name&quot;</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> P.SPID</span><br><span class="line"><span class="keyword">FROM</span> V$MYSTAT M, V$SESSION S, V$PROCESS P</span><br><span class="line">        <span class="keyword">WHERE</span> M.STATISTIC# <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">AND</span> S.SID <span class="operator">=</span> M.SID</span><br><span class="line">        <span class="keyword">AND</span> P.ADDR <span class="operator">=</span> S.PADDR) P,</span><br><span class="line">    (<span class="keyword">SELECT</span> T.INSTANCE</span><br><span class="line">        <span class="keyword">FROM</span> V$THREAD T, V$<span class="keyword">PARAMETER</span> V</span><br><span class="line">        <span class="keyword">WHERE</span> V.NAME <span class="operator">=</span> <span class="string">&#x27;thread&#x27;</span></span><br><span class="line">        <span class="keyword">AND</span> (V.VALUE <span class="operator">=</span> <span class="number">0</span> <span class="keyword">OR</span> T.THREAD# <span class="operator">=</span> TO_NUMBER(V.VALUE))) I,</span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="keyword">VALUE</span> <span class="keyword">FROM</span> V$<span class="keyword">PARAMETER</span> <span class="keyword">WHERE</span> NAME <span class="operator">=</span> <span class="string">&#x27;user_dump_dest&#x27;</span>) D;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10053 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> SESSION <span class="keyword">SET</span> EVENTS <span class="string">&#x27;10053 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131449766.png" alt="10053"></p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 10046 事件</title>
      <link href="/posts/53050.html"/>
      <url>/posts/53050.html</url>
      
        <content type="html"><![CDATA[<h2 id="10046"><a href="#10046" class="headerlink" title="10046"></a>10046</h2><p>&emsp;&emsp;10046 事件可以得到 Oracle 内部执行系统解析、调用、等待、绑定变量等详细的信息，可以帮助我们解析一条/多条 SQL、PL/SQL 语句的运行状态，这些状态包括：Parse/Fetch/Execute 三个阶段中遇到的等待事件、消耗的物理和逻辑读、CPU 时间、执行计划等，还能帮我们分析一些 DDL 维护命令的内部工作原理，RMAN、Data Pump Expdp/impdp 等工具缓慢问题。</p><h2 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h2><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context forever,level 12&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span>(m.sid),p.pid,p.tracefile <span class="keyword">from</span> v$mystat m,v$session s,v$process p <span class="keyword">where</span> m.sid<span class="operator">=</span>s.sid <span class="keyword">and</span> s.paddr<span class="operator">=</span>p.addr;</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> session <span class="keyword">set</span> events <span class="string">&#x27;10046 trace name context off&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><ol><li><p>激活 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oradebug setmypid</span><br><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>执行目标 SQL</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br></pre></td></tr></table></figure></li><li><p>查看生成的 trace 文件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug tracefile_name</span><br></pre></td></tr></table></figure></li><li><p>关闭 10046 事件</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oradebug event <span class="number">10046</span> trace name context forever,level <span class="number">12</span>;</span><br></pre></td></tr></table></figure></li><li><p>切换 cmd，tkprof 命令规范文件格式</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tkprof D:\11G\APP\ORACLE\diag\rdbms\xe\xe\trace\xe_ora_5140.trc E:\xe_ora_5140.trc</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://www.cdn.cheneyblog.com/blog/202309131523044.png" alt="10046"></p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong></li></ul><ol><li>可以看出 sql 语句对应的等待事件</li><li>函数调用也会被列出</li><li>可以方便的看处理的行数，产生的逻辑物理读</li><li>可以方便的看解析时间和执行时间</li><li>可以跟踪整个程序包</li></ol><ul><li><strong>缺点</strong></li></ul><ol><li>步骤繁琐</li><li>无法判断表被访问了多少次</li><li>执行计划中的谓词部分不能清晰的展现出来</li></ol>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 dbms_xplan.display_cursor()</title>
      <link href="/posts/8170.html"/>
      <url>/posts/8170.html</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>SQL执行计划仍在Shared Pool中</p><h2 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h2><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DBMS_XPLAN.DISPLAY_CURSOR(</span><br><span class="line">sql_id        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">child_number  <span class="keyword">IN</span>  NUMBER    <span class="keyword">DEFAULT</span>  <span class="keyword">NULL</span>,</span><br><span class="line">format        <span class="keyword">IN</span>  VARCHAR2  <span class="keyword">DEFAULT</span>  <span class="string">&#x27;TYPICAL&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li>sql_id<br>指位于库缓存执行计划中 SQL 语句的父游标。默认值为 null。当使用默认值时当前会话的最后一条 SQL 语句的执行计划将被返回<br>可以通过查询 <code>V$SQL</code> 或 <code>V$SQLAREA</code> 的 SQL_ID 列来获得 SQL 语句的 SQL_ID。</li><li>child_number<br>指定父游标下子游标的序号。即指定被返回执行计划的 SQL 语句的子游标。默认值为 0。如果为 null，则 sql_id 所指父游标下所有子游标的执行计划都将被返回。</li><li>format<br>控制 SQL 语句执行计划的输出部分。</li></ul><h2 id="Format-参数详解"><a href="#Format-参数详解" class="headerlink" title="Format 参数详解"></a>Format 参数详解</h2><ul><li>官方输出格式<ol><li>BASIC: 显示最少的信息，只包括操作类型，ID 名称和选项。</li><li>TYPICAL: 默认值，显示相关信息以及某些附加的显示选项，如分区和并发使用等。</li><li>SERIAL: 与 TYPICAL 类型相似，区别是它不包括并发的信息，即使是并行执行的计划。</li><li>ALL: 显示最多的信息，包含了 TYPICAL 的全部以及更多的附加信息,如别名和远程调用等。</li></ol></li><li>附加输出格式（逗号和空格分隔来声明多个关键字，使用”+”和”-”符号来包含或排除相应的显示元素）<ol><li>ROWS – 显示被优化器估算的记录的行号</li><li>BYTES – 显示优化器估算的字节数</li><li>COST – 显示优化器计算的成本信息</li><li>PARTITION – 显示分区的分割信息</li><li>PARALLEL – 显示并行执行信息</li><li>PREDICATE – 显示谓语</li><li>PROJECTION – 显示列投影部分(每一行的那些列被传递给其父列已经这些列的大小)</li><li>ALIAS – 显示查询块名称已经对象别名</li><li>REMOTE – 显示分布式查询信息</li><li>NOTE – 显示注释</li><li>IOSTATS – 显示游标执行的 IO 统计信息</li><li>MEMSTATS – 为内存密集运算如散列联结，排序，或一些类型的位图运算显示内存管理统计信息</li><li>ALLSTATS – 与’IOSTATS MEMSTATS’等价</li><li>LAST – 显示最后执行的执行计划统计信息，默认显示为 ALL 类型，并且可以累积。</li></ol></li></ul><h2 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h2><p><code>dbms_xplan.display_cursor(null,null,&#39;advanced&#39;)</code> 仅用于 SQLplus 中查看刚执行过的 SQL 执行计划，在 PL/SQL Developer 中无法使用，因为工具在执行完 SQL 后还会执行其他的后台语句。</p><h2 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h2><p>  <code>dbms_xplan.display_cursor()</code>通常搭配<code>ALTER SESSION SET STATISTICS_LEVEL = ALL</code>或 <code>/*+ GATHER_PLAN_STATISTICS*/</code></p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131521485.png" alt="执行计划"></p><ol><li>starts：SQL 执行的次数；</li><li>E-Rows：执行计划预计返回的行数；</li><li>A-Rows：执行计划实际返回的行数；</li><li>A-Time：每一步执行的时间(HH:MM:SS.FF)，根据这一行可知 SQL 耗时在哪些地方；</li><li>Buffers：每一步实际执行的逻辑读或一致性读；</li><li>Reads：物理读；</li><li>OMem：OMem 为最优执行模式所需的内存评估值， 这个数据是由优化器统计数据以及前一次执行的性能数据估算得出的；</li><li>1Mem：1Mem 为 one-pass 模式所需的内存评估值，当工作区大小无法满足操作所需的大小时，需要将部分数据写入临时磁盘空间中(如果仅需要写入一次就可以完成操作，就称一次通过，One-Pass;否则为多次通过，Multi-Pass).该列数据为语句最后一次执行中，单次写磁盘所需要的内存大小，这个由优化器统计数据以及前一次执行的性能数据估算得出的</li><li>Used_Mem：Used-Mem 则为当前操作实际执行时消耗的内存，括号里面为(发生磁盘交换的次数,1 次即为 One-Pass,大于 1 次则为 Multi_Pass,如果没有使用磁盘，则显示 0)</li></ol><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>可得到真实的执行计划</li><li>可以看出表被访问了多少次</li><li>可以通过 E-ROWS 和 A-RWS 得到预测行数和实际行数</li><li>Buffers 和 Reads 也可以显示真实的逻辑读和物理读</li></ol></li><li><strong>缺点</strong><ol><li>只有语句执行完毕才可以看到结果</li><li>看不出递归调用的次数</li><li>无法控制记录打屏输出</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 explain plan for</title>
      <link href="/posts/21084.html"/>
      <url>/posts/21084.html</url>
      
        <content type="html"><![CDATA[<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">explain plan <span class="keyword">for</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span>(dbms_xplan.display());</span><br></pre></td></tr></table></figure><p>explain plan命令通常和dbms_xplan.display()命令结合使用<br>PL/SQL Developer里F5快捷键的原理就是调用explain plan命令</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>&emsp;&emsp;explain plan 命令的原理是 Oracle 将目标 SQL 所产生的执行计划写入 PLAN_TABLE$<br>（ON COMMIT PRESERVE ROWS 的 GLOBAL TEMPORARY TABLE 即会话级临时表仅对当前会话有效）然后再通过dbms_xplan.display()命令将PLAN_TABLE$中的具体执行步骤格式化显示出来</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li><strong>优点</strong><ol><li>无需真正执行，快捷方便</li></ol></li><li><strong>缺点</strong><ol><li>没有输出相关统计信息</li><li>无法判断是处理了多少行</li><li>无法判断表被访问了多少次</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>获取执行计划之 Autotrace</title>
      <link href="/posts/16791.html"/>
      <url>/posts/16791.html</url>
      
        <content type="html"><![CDATA[<h2 id="Autotrace-简介"><a href="#Autotrace-简介" class="headerlink" title="Autotrace 简介"></a>Autotrace 简介</h2><pre><code>AUTOTRACE是一项SQL*Plus功能，自动跟踪为SQL语句生成一个执行计划并且提供与该语句的处理有关的统计。AUTOTRACE的好处是您不必设置跟踪文件的格式，并且它将自动为SQL语句显示执行计划。</code></pre><h2 id="Autotrace-选项说明"><a href="#Autotrace-选项说明" class="headerlink" title="Autotrace 选项说明"></a>Autotrace 选项说明</h2><table><thead><tr><th align="center">命令</th><th align="center">输出内容</th><th align="center">简写</th><th>是否真实执行</th></tr></thead><tbody><tr><td align="center">SET AUTOTRACE OFF</td><td align="center">缺省模式，只显示 SQL 执行结果</td><td align="center">SET AUTOT OFF</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE ON</td><td align="center">显示 SQL 结果、执行路径和资源消耗</td><td align="center">SET AUTOT ON</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY</td><td align="center">显示 SQL 结果数量、执行路径和资源消耗</td><td align="center">SET AUTOT TRACE</td><td>是</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY EXPLAN</td><td align="center">只显示 SQL 执行路径</td><td align="center">SET AUTOT TRACE EXP</td><td>Select 语句没有，DML 会被执行</td></tr><tr><td align="center">SET AUTOTRACE TRACEONLY STATISTICS</td><td align="center">只显示资源消耗</td><td align="center">SET AUTOT TRACE STAT</td><td></td></tr></tbody></table><h2 id="统计信息"><a href="#统计信息" class="headerlink" title="统计信息"></a>统计信息</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202309131518397.png" alt="统计信息"></p><table><thead><tr><th align="right">统计信息</th><th align="left">解释</th></tr></thead><tbody><tr><td align="right">recursive calls</td><td align="left">产生的递归 sql 调用的条数</td></tr><tr><td align="right">Db block gets</td><td align="left">从 buffer cache 中读取的 block 的数量</td></tr><tr><td align="right">consistent gets</td><td align="left">从 buffer cache 中读取的 undo 数据的 block 的数量</td></tr><tr><td align="right">physical reads</td><td align="left">从磁盘读取的 block 的数量</td></tr><tr><td align="right">redo size</td><td align="left">DML 生成的 redo 的大小</td></tr><tr><td align="right">bytes sent via SQL*Net to client</td><td align="left">数据库服务器通过 SQL*Net 向查询客户端发送的查询结果字节数</td></tr><tr><td align="right">bytes received via SQL*Net from client</td><td align="left">通过 SQL*Net 接受的来自客户端的数据字节数</td></tr><tr><td align="right">SQL*Net roundtrips to/from client</td><td align="left">服务器和客户端来回往返通信的 Oracle Net messages 条数</td></tr><tr><td align="right">sorts (memory)</td><td align="left">在内存执行的排序量</td></tr><tr><td align="right">sorts (disk)</td><td align="left">在磁盘上执行的排序量</td></tr><tr><td align="right">rows processed</td><td align="left">处理的数据的行数</td></tr></tbody></table><h2 id="Autotrace-优缺点"><a href="#Autotrace-优缺点" class="headerlink" title="Autotrace 优缺点"></a>Autotrace 优缺点</h2><ul><li><strong>优点</strong><ol><li>可以输出运行时的相关统计信息</li><li>有多种模式可供选择</li></ol></li><li><strong>缺点</strong><ol><li>必须要等 SQL 语句执行完，才出结果</li><li>无法看到表被访问了多少次</li><li>当存在绑定变量时执行计划可能不准</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解DBMS_STATS包：优化Oracle数据库统计信息管理</title>
      <link href="/posts/32449.html"/>
      <url>/posts/32449.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我来和大家分享关于Oracle数据库中DBMS_STATS包的相关知识，并通过举例详细介绍如何使用这个强大的工具包来优化数据库性能。DBMS_STATS包提供了一系列过程和函数，帮助我们管理统计信息，从而提升查询效率和数据库性能。</p><h2 id="收集统计信息"><a href="#收集统计信息" class="headerlink" title="收集统计信息"></a>收集统计信息</h2><p>首先，让我们通过一个例子来了解如何使用DBMS_STATS包收集表的统计信息。假设我们有一个名为”employees”的表，我们希望为该表收集统计信息。我们可以使用以下命令执行此操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXEC</span> DBMS_STATS.GATHER_TABLE_STATS(<span class="string">&#x27;HR&#x27;</span>, <span class="string">&#x27;EMPLOYEES&#x27;</span>);</span><br></pre></td></tr></table></figure><p>其中，’HR’为用户名，’EMPLOYEES’为表名。通过执行以上命令，DBMS_STATS包会收集’employees’表的统计信息，如行数、列的唯一值数量、索引信息等。</p><h2 id="自动收集统计信息"><a href="#自动收集统计信息" class="headerlink" title="自动收集统计信息"></a>自动收集统计信息</h2><p>除了手动收集，我们还可以让DBMS_STATS包自动定期收集统计信息，以确保数据库的最新性能。首先，我们需要创建一个统计信息收集作业。以下是一个创建作业的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_SCHEDULER.CREATE_JOB(</span><br><span class="line">      job_name        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_COLLECTION_JOB&#x27;</span>,</span><br><span class="line">      job_type        <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;PLSQL_BLOCK&#x27;</span>,</span><br><span class="line">      job_action      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;BEGIN DBMS_STATS.GATHER_DATABASE_STATS(); END;&#x27;</span>,</span><br><span class="line">      start_date      <span class="operator">=</span><span class="operator">&gt;</span> SYSTIMESTAMP,</span><br><span class="line">      repeat_interval <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;FREQ=DAILY&#x27;</span>,</span><br><span class="line">      enabled         <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过这个作业，DBMS_STATS包将每天收集一次数据库的统计信息。</p><h2 id="导出和导入统计信息"><a href="#导出和导入统计信息" class="headerlink" title="导出和导入统计信息"></a>导出和导入统计信息</h2><p>另一个强大的功能是DBMS_STATS包支持统计信息的导出和导入。这在数据库升级、数据迁移或创建测试环境时非常有用。以下是一个导出统计信息的示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.EXPORT_SCHEMA_STATS(</span><br><span class="line">      ownname      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;HR&#x27;</span>,</span><br><span class="line">      stattab      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_TABLE&#x27;</span>,</span><br><span class="line">      statid       <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;EMP_STATS&#x27;</span>,</span><br><span class="line">      statown      <span class="operator">=</span><span class="operator">&gt;</span> <span class="string">&#x27;STATS_OWNER&#x27;</span>,</span><br><span class="line">      cascade      <span class="operator">=</span><span class="operator">&gt;</span> <span class="literal">TRUE</span></span><br><span class="line">   );</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>在上述示例中，我们将’HR’模式的统计信息导出到名为’STATS_TABLE’的表中。</p><h2 id="统计信息管理"><a href="#统计信息管理" class="headerlink" title="统计信息管理"></a>统计信息管理</h2><p>除了收集和导出统计信息，DBMS_STATS包还提供了其他管理功能。例如，我们可以使用以下命令锁定统计信息，防止其被自动收集或修改：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">   DBMS_STATS.LOCK_SCHEMA_STATS(<span class="string">&#x27;HR&#x27;</span>);</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>通过上述命令，’HR’用户的统计信息将被锁定。</p><blockquote><p>总结：<br>DBMS_STATS包是Oracle数据库中一个强大的工具包，通过其提供的过程和函数，我们可以方便地收集、导出、导入和管理数据库对象的统计信息。深入了解和灵活应用DBMS_STATS包的知识，可以帮助我们优化数据库性能，提高查询效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle执行计划简介：优化数据库查询的关键</title>
      <link href="/posts/20895.html"/>
      <url>/posts/20895.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我来和大家分享关于Oracle数据库中执行计划的相关知识，执行计划在优化数据库查询中起着至关重要的作用。深入理解什么是执行计划以及它的选定依据，对于提高查询性能和数据库响应速度具有重要意义。</p><h2 id="什么是执行计划"><a href="#什么是执行计划" class="headerlink" title="什么是执行计划"></a>什么是执行计划</h2><p>执行计划是Oracle数据库根据查询语句、表、索引和统计信息等生成的一种执行路线图，它描述了数据库优化器在执行查询语句时的执行步骤和操作方式。执行计划包括了查询的访问方式、连接方式、操作顺序等关键信息。</p><p><img src="https://www.cdn.cheneyblog.com/blog/202309131358420.png" alt="执行计划示例"></p><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ol><li><p>目标 SQL 的正文、sql_id 和执行计划对应的 plan_hash_value<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610746.png" alt="目标SQL的正文"></p></li><li><p>执行计划主体，主要有内部执行步骤、执行顺序、谓词信息、列信息、Cardinality、Cost 等<br><img src="https://www.cdn.cheneyblog.com/blog/202309131610827.png" alt="执行计划主体"></p></li><li><p>执行计划的额外补充信息，是否动态采用（dynamic sampling）、是否 Cardinality Feedback、是否 SQL Profile<br><img src="https://www.cdn.cheneyblog.com/blog/202309131611503.png" alt="补充信息"></p></li></ol><h2 id="模块解读"><a href="#模块解读" class="headerlink" title="模块解读"></a>模块解读</h2><h3 id="主体-Header"><a href="#主体-Header" class="headerlink" title="主体 Header"></a>主体 Header</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131611458.png" alt="Header"></p><ul><li>ID：序号</li><li>Operation： 当前操作的内容</li><li>Rows： 当前操作的 Cardinality，Oracle 估计当前操作的返回结果集。</li><li>Cost：SQL 执行的代价</li><li>Time：Oracle 估计当前操作的时间</li></ul><h3 id="Query-Block-Name"><a href="#Query-Block-Name" class="headerlink" title="Query Block Name"></a>Query Block Name</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131612236.png" alt="Query Block Name"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Query Block Name <span class="operator">/</span> Object Alias (identified <span class="keyword">by</span> operation id):           <span class="comment">--这部分显示的为查询块名和对象别名</span></span><br><span class="line"><span class="comment">-------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> SEL$<span class="number">1</span>                                                            <span class="comment">--SEL$为select 的缩写，位于块1,相应的还有DEL$,INS$,UPD$等</span></span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span>                                               <span class="comment">--DEPT@SEL$1，对应到执行计划中的操作ID为3上，即在表DEPT上的查询，DEPT为别名，下面类同</span></span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> DEPT<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> EMP<span class="variable">@SEL</span>$<span class="number">1</span></span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> SEL$<span class="number">1</span> <span class="operator">/</span> J<span class="variable">@SEL</span>$<span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="Outline-Data"><a href="#Outline-Data" class="headerlink" title="Outline Data"></a>Outline Data</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613271.png" alt="Outline Data"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Outline Data                                                            <span class="comment">--提纲部分，这部分将执行计划中的图形化方式以文本形式来呈现，即转换为提示符方式</span></span><br><span class="line"><span class="comment">-------------</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*+</span></span><br><span class="line"><span class="comment">      BEGIN_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">      IGNORE_OPTIM_EMBEDDED_HINTS</span></span><br><span class="line"><span class="comment">      OPTIMIZER_FEATURES_ENABLE(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      DB_VERSION(&#x27;11.2.0.2&#x27;)</span></span><br><span class="line"><span class="comment">      ALL_ROWS</span></span><br><span class="line"><span class="comment">      OUTLINE_LEAF(@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      INDEX(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; (&quot;DEPT&quot;.&quot;DEPTNO&quot;))                  --指明对于DEPT上的访问方式为使用索引</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                      --指明对于EMP上的访问方式为全表扫描</span></span><br><span class="line"><span class="comment">      FULL(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)</span></span><br><span class="line"><span class="comment">      LEADING(@&quot;SEL$1&quot; &quot;DEPT&quot;@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)        --指明前导表</span></span><br><span class="line"><span class="comment">      USE_MERGE(@&quot;SEL$1&quot; &quot;EMP&quot;@&quot;SEL$1&quot;)                                 --使用USE_MERGE提示，即MERGE SORT排序合并连接</span></span><br><span class="line"><span class="comment">      USE_HASH(@&quot;SEL$1&quot; &quot;J&quot;@&quot;SEL$1&quot;)                                    --使用USE_HASH提示，即HASH连接</span></span><br><span class="line"><span class="comment">      END_OUTLINE_DATA</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><h3 id="Predicate-Information"><a href="#Predicate-Information" class="headerlink" title="Predicate Information"></a>Predicate Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131613212.png" alt="Predicate Information"></p><ul><li>Access</li></ul><ol><li>通过某种方式定位了需要的数据，然后读取出这些结果集，叫做 Access。</li><li>表示这个谓词条件的值将会影响数据的访问路劲（表还是索引）。</li></ol><ul><li>Filter</li></ul><ol><li>把所有的数据都访问了，然后过滤掉不需要的数据，这种方式叫做 filter 。</li><li>表示谓词条件的值不会影响数据的访问路劲，只起过滤的作用。</li></ol><h3 id="Column-Projection-Information"><a href="#Column-Projection-Information" class="headerlink" title="Column Projection Information"></a>Column Projection Information</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131614629.png" alt="Column Projection Information"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Column</span> Projection Information (identified <span class="keyword">by</span> operation id):             <span class="comment">--执行时每一步骤所返回的列，下面的不同步骤返回了不同的列</span></span><br><span class="line"><span class="comment">-----------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">   <span class="number">1</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br><span class="line">   <span class="number">2</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">3</span> <span class="operator">-</span> &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;DEPT&quot;.&quot;DNAME&quot;[VARCHAR2,<span class="number">14</span>]</span><br><span class="line">   <span class="number">4</span> <span class="operator">-</span> &quot;DEPT&quot;.ROWID[ROWID,<span class="number">10</span>], &quot;DEPT&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">5</span> <span class="operator">-</span> (#keys<span class="operator">=</span><span class="number">1</span>) &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>], &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>]</span><br><span class="line">   <span class="number">6</span> <span class="operator">-</span> &quot;EMP&quot;.&quot;EMPNO&quot;[NUMBER,<span class="number">22</span>], &quot;EMP&quot;.&quot;ENAME&quot;[VARCHAR2,<span class="number">10</span>],</span><br><span class="line">       &quot;EMP&quot;.&quot;JOB&quot;[VARCHAR2,<span class="number">9</span>], &quot;EMP&quot;.&quot;DEPTNO&quot;[NUMBER,<span class="number">22</span>]</span><br><span class="line">   <span class="number">7</span> <span class="operator">-</span> &quot;J&quot;.&quot;JOB_NAME&quot;[VARCHAR2,<span class="number">50</span>], &quot;J&quot;.&quot;JOB_DESCRIBE&quot;[VARCHAR2,<span class="number">100</span>]</span><br></pre></td></tr></table></figure><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p><img src="https://www.cdn.cheneyblog.com/blog/202309131615740.png" alt="Note"><br>&emsp;&emsp;动态采样（dynamic sampling）是 Oracle CBO 优化器的一种特性。如果相关数据表没有收集过统计量，又要使用 CBO 的机制，就会引起动态采样。</p><h2 id="执行计划的选定依据"><a href="#执行计划的选定依据" class="headerlink" title="执行计划的选定依据"></a>执行计划的选定依据</h2><p>在选择执行计划时，数据库优化器会考虑以下几个关键依据：</p><ol><li>统计信息：执行计划的选定依赖于表、索引和列的统计信息。这些统计信息包括表的行数、列的唯一值数目、索引的高度等。通过准确的统计信息，优化器能够评估不同执行计划的成本和效率，并选择最佳的执行路径。</li><li>查询语句和条件：执行计划的选定还考虑了查询语句和条件的影响。优化器会分析查询涉及的表、索引、连接方式以及查询条件的复杂性和选择性。根据这些因素，优化器会评估执行计划的成本和效率，以选择最佳的执行路径。</li><li>系统资源：执行计划的选定还会受到系统资源的限制和优化目标的影响。优化器会考虑系统可用的资源（例如CPU和内存）以及管理员设置的优化目标，以选择适当的执行计划，以平衡查询性能和系统负载。</li></ol><blockquote><p>总结：<br>执行计划在优化数据库查询性能中起着关键的作用。它能够帮助我们理解查询的执行过程、优化查询语句和提高数据库的响应速度。执行计划的选定依据主要包括统计信息、查询语句和条件，以及系统资源的限制和优化目标。通过深入理解和应用执行计划，我们能够更好地优化查询性能，提升数据库的整体效率。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升数据库性能的关键：Oracle统计信息</title>
      <link href="/posts/26508.html"/>
      <url>/posts/26508.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我想和大家分享关于数据库性能优化的重要方面之一：Oracle统计信息。在我们的应用程序中，数据库的性能直接影响着用户体验和系统的稳定性。而统计信息作为一种关键的工具，可以帮助我们更好地优化数据库性能。</p><h2 id="什么是统计信息？"><a href="#什么是统计信息？" class="headerlink" title="什么是统计信息？"></a>什么是统计信息？</h2><p>统计信息是数据库中关于表、索引和列的统计数据，用于优化查询计划的生成。Oracle数据库会定期收集这些统计信息，并据此进行优化决策，以提供最佳的查询性能。统计信息主要包括表的行数、列的唯一值个数、索引高度等。</p><h2 id="为什么统计信息如此重要"><a href="#为什么统计信息如此重要" class="headerlink" title="为什么统计信息如此重要"></a>为什么统计信息如此重要</h2><p>统计信息的准确性直接影响着查询的执行效率。如果统计信息不准确，数据库可能会选择错误的查询计划，导致查询性能下降甚至出现严重的性能问题。因此，及时收集和更新统计信息是提升数据库性能的关键步骤之一。</p><h2 id="如何收集统计信息"><a href="#如何收集统计信息" class="headerlink" title="如何收集统计信息"></a>如何收集统计信息</h2><p>Oracle提供了多种方式来收集统计信息：</p><ol><li>自动收集：Oracle会自动定期收集表的统计信息，可以通过设置相关参数来调整收集的频率和深度。</li><li>手动收集：可以使用DBMS_STATS包中的过程来手动收集统计信息，可以选择对整个数据库、表、索引或列进行统计信息的收集。</li><li>统计信息导入导出：可以将统计信息导出为统计信息的XML格式文件，然后在其他数据库中导入使用。</li></ol><h2 id="如何使用统计信息优化性能"><a href="#如何使用统计信息优化性能" class="headerlink" title="如何使用统计信息优化性能"></a>如何使用统计信息优化性能</h2><p>在收集统计信息后，Oracle优化器会根据统计信息进行查询计划的生成。有几点需要注意：</p><ol><li>统计信息的准确性：确保收集的统计信息准确无误，可以使用DBMS_STATS包提供的过程对统计信息进行评估和修正。</li><li>统计信息的更新：当表的数据发生较大变化时，需要及时更新统计信息，以保证优化器生成最新且最适合的查询计划。</li><li>数据库参数的设置：合理配置相关的数据库参数，如optimizer_mode、optimizer_index_cost_adj等，以便优化器更好地利用统计信息进行查询优化。</li></ol><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>大家可能注意到LAST_ANALYZED字段的取值，似乎时间有点早，不像每天都收集的样子，原来Oracle可以专门对表的记录变化量进行管理，当某表一天记录变化量没有超过指定的阈值时，Oracle就不会对该表进行统计信息收集，所以很多时候不少表被<br>第一次收集统计信息后，由于一直很少更新，故很少再有针对该表收集信息的动作。</p></div><blockquote><p>总结：<br>Oracle统计信息在数据库性能的优化中起着至关重要的作用。通过准确收集和更新统计信息，我们可以使数据库选择最佳的查询计划，从而提升查询性能。同时，定期的统计信息维护也是保证数据库长期稳定运行的重要环节。希望以上的内容对你们理解和应用统计信息有所帮助。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组解析：探索数据存储与操作的利器</title>
      <link href="/posts/50102.html"/>
      <url>/posts/50102.html</url>
      
        <content type="html"><![CDATA[<p>大家好，今天我们来深入探讨Java中的数组这一数据结构，它是数据存储与操作的利器。通过本文，我们将全面了解Java数组的特性和用法。</p><h2 id="数组的基础知识"><a href="#数组的基础知识" class="headerlink" title="数组的基础知识"></a>数组的基础知识</h2><p>数组是一种存储连续数据的结构，它由相同类型的元素组成。在Java中，数组的长度是固定的，一旦创建后，无法改变。每个元素都通过索引访问，索引从0开始。这个特性使得数组在很多编程任务中非常有用。</p><h2 id="数组的声明和初始化"><a href="#数组的声明和初始化" class="headerlink" title="数组的声明和初始化"></a>数组的声明和初始化</h2><p>在Java中，声明和初始化数组可以分为两步，首先声明数组变量，然后使用<code>new</code>关键字为数组分配内存并初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个整数数组</span></span><br><span class="line"><span class="type">int</span>[] numbers;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个长度为5的整数数组</span></span><br><span class="line">numbers = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明并初始化一个字符串数组</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Charlie&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用简化的语法初始化一个字符数组</span></span><br><span class="line"><span class="type">char</span>[] vowels = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>通过指定数组的大小和类型，我们可以声明一个数组，然后使用<code>new</code>关键字为其分配内存空间。</p><h2 id="数组的访问和遍历"><a href="#数组的访问和遍历" class="headerlink" title="数组的访问和遍历"></a>数组的访问和遍历</h2><p>通过索引，我们可以访问数组中的元素。索引从0开始，最后一个元素的索引为数组长度减1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">firstNumber</span> <span class="operator">=</span> numbers[<span class="number">0</span>]; <span class="comment">// 访问数组的第一个元素</span></span><br><span class="line"></span><br><span class="line">numbers[<span class="number">2</span>] = <span class="number">10</span>; <span class="comment">// 修改数组的第三个元素</span></span><br></pre></td></tr></table></figure><p>除了直接访问数组元素，我们还可以使用循环结构（如<code>for</code>循环或<code>foreach</code>循环）来遍历数组中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">    System.out.println(numbers[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用foreach循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> number : numbers) &#123;</span><br><span class="line">    System.out.println(number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组的常见操作"><a href="#数组的常见操作" class="headerlink" title="数组的常见操作"></a>数组的常见操作</h2><p>Java提供了许多有用的数组操作方法。例如，我们可以使用<code>Arrays</code>类中的<code>sort()</code>方法对数组进行排序，使用<code>binarySearch()</code>方法查找元素，使用<code>copyOf()</code>方法复制数组等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在本文中，我们深入了解了Java数组的基础知识，包括声明和初始化、访问和遍历以及常见操作。数组作为一种重要的数据结构，广泛应用于各种编程场景。通过掌握数组的特性和用法，我们可以更加灵活地处理数据，并编写出高效的程序。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>巧妙运用Java表达式：编程中的算术与逻辑之道</title>
      <link href="/posts/37227.html"/>
      <url>/posts/37227.html</url>
      
        <content type="html"><![CDATA[<p>作为一门广泛应用于软件开发领域的高级编程语言，Java为我们提供了丰富的表达式和操作符，使我们能够轻松进行算术计算和逻辑推理。在本文中，我们将深入探讨Java表达式的基础知识和技巧，帮助你在编程中更加熟练地使用这些强大的功能。</p><h2 id="算术表达式：实现精确计算"><a href="#算术表达式：实现精确计算" class="headerlink" title="算术表达式：实现精确计算"></a>算术表达式：实现精确计算</h2><p>在Java中，算术表达式用于进行数学运算，例如加法、减法、乘法和除法等。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">difference</span> <span class="operator">=</span> a - b; <span class="comment">// 减法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法</span></span><br></pre></td></tr></table></figure><p>另外，Java还提供了取模运算符（%），用于获取两个数相除的余数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><p>合理利用算术表达式的组合和嵌套，可以实现复杂的数学计算，并在编程中达到精确计算的目的。</p><h2 id="逻辑表达式：实现条件判断"><a href="#逻辑表达式：实现条件判断" class="headerlink" title="逻辑表达式：实现条件判断"></a>逻辑表达式：实现条件判断</h2><p>逻辑表达式在编程中非常重要，它用于实现条件判断和逻辑控制。我们常用的逻辑操作符有：</p><ul><li>逻辑与（&amp;&amp;）：当两个操作数都为true时，结果为true。</li><li>逻辑或（||）：当两个操作数中有一个为true时，结果为true。</li><li>逻辑非（！）：用于取反操作，将true变为false，将false变为true。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFalse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result1</span> <span class="operator">=</span> isTrue &amp;&amp; isFalse; <span class="comment">// false</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result2</span> <span class="operator">=</span> isTrue || isFalse; <span class="comment">// true</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">result3</span> <span class="operator">=</span> !isTrue; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>逻辑表达式通常与条件语句（如if语句）结合使用，根据条件的真假执行相应的逻辑操作。</p><h2 id="提高表达式的可读性和效率"><a href="#提高表达式的可读性和效率" class="headerlink" title="提高表达式的可读性和效率"></a>提高表达式的可读性和效率</h2><p>在编程中，良好的代码习惯对于表达式的编写非常重要。以下是一些有效的建议，可帮助提高表达式的可读性和效率：</p><ol><li><p>使用括号：使用括号明确表达式的执行顺序，避免歧义。</p></li><li><p>命名变量：使用有意义的变量名，使表达式更易理解。</p></li><li><p>避免过度复杂化：尽量避免编写过于复杂的表达式，以免降低代码的可读性和可维护性。</p></li><li><p>避免除数为0的情况：在进行除法操作时，务必考虑除数为0的异常情况。</p></li><li><p>使用短路求值：对于逻辑与（&amp;&amp;）和逻辑或（||）操作，利用短路求值的特性，可以提高代码的效率。</p></li></ol><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在编程中，掌握Java表达式的基础知识和技巧对于构建复杂的程序非常重要。通过灵活运用算术表达式，我们可以实现精确的数学计算；逻辑表达式则允许我们根据条件进行逻辑判断和流程控制。并且，良好的编码习惯和优化技巧可以提高代码的可读性和执行效率。</p><p>希望本文能为你提供关于Java表达式的详细解释和实践建议。通过深入学习和不断练习，相信你将能够熟练地使用Java表达式，并在编程过程中发挥其强大的功能。祝你编程愉快，取得优秀的成就！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java编程语言：优雅而强大的编程利器</title>
      <link href="/posts/42473.html"/>
      <url>/posts/42473.html</url>
      
        <content type="html"><![CDATA[<p>Java作为一门广泛应用于软件开发和企业级应用的编程语言，以其优雅的语法、强大的跨平台性能和丰富的生态系统而广受欢迎。本文将为您全面介绍Java的起源、特点和发展历程，带您走进这门受众众多开发者推崇的编程利器。</p><h2 id="起源和背景"><a href="#起源和背景" class="headerlink" title="起源和背景"></a>起源和背景</h2><p>Java诞生于20世纪90年代初，由Sun Microsystems的詹姆斯·高斯林（James Gosling）及其团队创作。当时，Sun Microsystems致力于开发一种能在家用电视和其他家电设备上运行的机器语言，他们让这个项目称为“绿色计划”。然而，由于电视技术的限制，这个项目没能实现，但是却为创建一种通用的编程语言奠定了基础。</p><h2 id="Java的特点与优势"><a href="#Java的特点与优势" class="headerlink" title="Java的特点与优势"></a>Java的特点与优势</h2><p>Java具备诸多独特的特点和优势，使它成为了如今广泛使用的编程语言之一：</p><ol><li><p>跨平台性：Java的最大特点之一是“一次编写，到处运行”。它的程序可以在各种操作系统上运行，如Windows、Mac、Linux等，这是通过Java虚拟机（JVM）实现的。</p></li><li><p>简单易学：Java采用了C++语言的面向对象编程理念，但去除了C++中的复杂和难以理解的部分。Java提供了清晰而易于理解的语法，使初学者也能够轻松入门。</p></li><li><p>安全性：Java注重安全性，它提供了一些机制用于防止程序中的潜在安全漏洞。Java的安全性主要通过Java安全管理器、类加载机制以及字节码验证等来实现。</p></li><li><p>面向对象：Java是一种纯面向对象的编程语言，它支持类、继承、多态等面向对象的特性。这种特点使得Java开发更加模块化、易于维护和扩展。</p></li><li><p>强大的生态系统：Java拥有丰富的类库和开发工具，比如Java标准库（Java API）提供了大量已经实现的类和方法，开发者可以直接使用这些类来实现复杂的功能。此外，Java还有大量的开源框架和工具，如Spring、Hibernate等，能够帮助开发者更高效地进行开发。</p></li></ol><h2 id="发展历程和应用领域"><a href="#发展历程和应用领域" class="headerlink" title="发展历程和应用领域"></a>发展历程和应用领域</h2><p>Java的成功得益于其出色的设计和适用性，在过去的几十年中不断发展壮大。</p><ol><li><p>初期发展（1995-2000）：Java 1.0发布后迅速引起了开发者们的关注，在互联网的应用和Web开发中得以迅速推广。Java Servlet和Java Server Pages（JSP）的引入使得Java在Web应用开发领域占据了重要的地位。</p></li><li><p>中期发展（2000-2010）：Java 2（J2SE）、Java 2 Enterprise Edition（J2EE）和Java 2 Micro Edition（J2ME）等版本陆续发布，Java的应用范围进一步扩大。同时，大型企业应用和金融系统中广泛采用Java，使其成为企业级应用的首选语言。</p></li><li><p>当代发展（2010至今）：Java 8的发布引入了函数式编程的特性，使得Java更加现代化和强大。Java继续保持其领先地位，广泛应用于大数据处理、云计算、物联网和移动应用等领域。</p></li></ol><h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><p>随着技术的发展和需求的变化，Java仍然保持着强大的生命力。目前，Java继续推进语言和库的更新，提供更好的性能和安全性。同时，Java也在不断发展与演进，如引入模块化系统（Java模块化系统）和提供更好的开发工具支持等。</p><blockquote><p>总结：<br>Java是一门具备优雅语法和强大能力的编程语言，它的跨平台性、面向对象特性和丰富的生态系统使其得到了广泛应用。无论是开发大型企业级应用还是小型移动应用，Java都能为开发者提供可靠的解决方案。相信未来，在技术的推动下，Java将继续成为企业级开发和大规模系统构建的首选语言。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>精通Java流程控制：玩转条件和循环，打造高效编程之路！</title>
      <link href="/posts/42343.html"/>
      <url>/posts/42343.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，流程控制是一种重要的技术，用于根据不同的条件执行不同的代码块，或者通过循环重复执行一段代码。掌握流程控制语句可以使程序更具灵活性和可控性。本文将深入探究Java流程控制的相关概念和应用。</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><p>条件语句用于根据条件的成立与否决定是否执行某个代码块。Java中常用的条件语句有<code>if</code>语句、<code>if-else</code>语句和<code>switch</code>语句。</p><ol><li><p><code>if</code>语句</p><p> <code>if</code>语句用于在条件成立时执行某个代码块，语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>condition</code>是一个布尔表达式，当其结果为<code>true</code>时，执行代码块。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>if-else</code>语句</p><p> <code>if-else</code>语句用于在条件成立和不成立时分别执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition) &#123;</span><br><span class="line">    <span class="comment">// 执行条件为true时的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 执行条件为false时的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (num &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num大于5&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;num小于等于5&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>switch</code>语句</p><p> <code>switch</code>语句用于根据不同的取值，执行不同的代码块。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1:</span><br><span class="line">        <span class="comment">// 执行值为value1的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2:</span><br><span class="line">        <span class="comment">// 执行值为value2的代码块</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 执行默认情况的代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 其中，<code>expression</code>是一个表达式，根据其值来匹配不同的<code>case</code>。</p><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">grade</span> <span class="operator">=</span> <span class="string">&#x27;B&#x27;</span>;</span><br><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行一段代码，直到某个条件不再成立。Java中常用的循环语句有<code>for</code>循环、<code>while</code>循环和<code>do-while</code>循环。</p><ol><li><p><code>for</code>循环</p><p> <code>for</code>循环用于在已知循环次数的情况下重复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>while</code>循环</p><p> <code>while</code>循环用于在条件成立时反复执行一段代码。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>do-while</code>循环</p><p> <code>do-while</code>循环和<code>while</code>循环类似，不同之处在于它先执行一次循环体，然后在判断条件是否成立。语法结构如下：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体代码</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure><p> 示例：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="流程控制的嵌套和跳转"><a href="#流程控制的嵌套和跳转" class="headerlink" title="流程控制的嵌套和跳转"></a>流程控制的嵌套和跳转</h2><p>在实际编程中，我们常常会在流程控制语句内部进行嵌套，以实现更复杂的逻辑。此外，Java还提供了跳转语句<code>break</code>和<code>continue</code>，用于跳出循环或跳过本次循环。</p><ul><li><code>break</code>语句用于跳出当前循环，结束循环执行。</li><li><code>continue</code>语句用于跳过本次循环，继续执行下一次循环。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结：<br>通过本文的介绍，我们深入探究了Java流程控制的相关概念和应用场景。条件语句和循环语句是实现程序流程控制的重要工具，能够根据不同的条件和需求，灵活地执行对应的代码块。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入解析Java运算符：理解常用运算符及其应用场景</title>
      <link href="/posts/37240.html"/>
      <url>/posts/37240.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，运算符是一种用来进行数学、逻辑和位操作的符号。通过运算符，我们可以对数据进行各种计算和操作，完成复杂的逻辑判断和数据处理。本文将深入解析Java中常用的运算符，帮助你理解运算符的概念和使用场景。</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>算术运算符用于执行基本的数学运算，包括加法、减法、乘法、除法、取模等。对于整型和浮点型变量，可以使用如下算术运算符：</p><ul><li><code>+</code> ：用于执行加法运算；</li><li><code>-</code> ：用于执行减法运算；</li><li><code>*</code> ：用于执行乘法运算；</li><li><code>/</code> ：用于执行除法运算；</li><li><code>%</code> ：用于执行取模（求余）运算。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b; <span class="comment">// 加法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">subtract</span> <span class="operator">=</span> a - b; <span class="comment">// 减法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> a * b; <span class="comment">// 乘法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">quotient</span> <span class="operator">=</span> a / b; <span class="comment">// 除法运算</span></span><br><span class="line"><span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> a % b; <span class="comment">// 取模运算</span></span><br></pre></td></tr></table></figure><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符用于将一个值赋给变量。Java中的常用赋值运算符是<code>=</code>，表示将右边的值赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>a</code>变量被赋值为10，然后将<code>a</code>的值赋给了<code>b</code>变量。</p><p>另外，赋值运算符还有一些简化的形式，如<code>+=</code>、<code>-=</code>、<code>*=</code>等，表示将右边的值和左边的变量进行特定运算后再赋给左边的变量。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">num += <span class="number">10</span>; <span class="comment">// 等价于num = num + 10;</span></span><br></pre></td></tr></table></figure><p>在上述代码中，<code>num</code>的值先加上10，再赋给<code>num</code>。</p><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h2><p>关系运算符用于比较两个值之间的关系，返回一个布尔值（<code>true</code>或<code>false</code>）。常见的关系运算符包括：</p><ul><li><code>==</code> ：判断相等；</li><li><code>!=</code> ：判断不等；</li><li><code>&gt;</code> ：大于；</li><li><code>&lt;</code> ：小于；</li><li><code>&gt;=</code> ：大于等于；</li><li><code>&lt;=</code> ：小于等于。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> (a &gt; b); <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符用于执行逻辑操作，常用的逻辑运算符有：</p><ul><li><code>&amp;&amp;</code> ：逻辑与运算符，当两个条件都为<code>true</code>时，返回<code>true</code>；</li><li><code>||</code> ：逻辑或运算符，当两个条件其中一个为<code>true</code>时，返回<code>true</code>；</li><li><code>!</code> ：逻辑非运算符，用于取反操作。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">condition1</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">condition2</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> condition1 &amp;&amp; condition2; <span class="comment">// 返回false</span></span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>位运算符用于对整数类型的数据进行位操作，常见的位运算符包括：</p><ul><li><code>&amp;</code> ：按位与运算，对每一位进行与操作；</li><li><code>|</code> ：按位或运算，对每一位进行或操作；</li><li><code>^</code> ：按位异或运算，对每一位进行异或操作；</li><li><code>~</code> ：按位取反运算，对每一位进行取反操作；</li><li><code>&lt;&lt;</code> ：左移运算符，将二进制表示的数向左移动指定位数；</li><li><code>&gt;&gt;</code> ：右移运算符，将二进制表示的数向右移动指定位数。</li></ul><p>位运算符常用于处理二进制数据，例如位操作、图像处理、加密算法等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过本文的介绍，我们深入解析了Java中常用的运算符，包括算术运算符、赋值运算符、关系运算符、逻辑运算符和位运算符。不同类型的运算符在不同的场景中发挥着重要的作用。灵活运用运算符，可以让我们更高效地进行数据处理、逻辑判断和位操作。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS配置：将域名连接到IP地址的关键步骤</title>
      <link href="/posts/59495.html"/>
      <url>/posts/59495.html</url>
      
        <content type="html"><![CDATA[<p>在互联网世界中，DNS（Domain Name System）是一项至关重要的技术，它将人们可读的域名转换为机器可理解的 IP 地址，为用户提供访问网站和服务的便利性。本文将介绍DNS配置的基本知识以及常见的配置方法，帮助你更好地理解和配置DNS。</p><h2 id="什么是DNS？"><a href="#什么是DNS？" class="headerlink" title="什么是DNS？"></a>什么是DNS？</h2><p>DNS 是一个分布式的命名系统，用于将域名转换为 IP 地址。在用户输入网址访问网站时，计算机将通过 DNS 查询来找到相应的 IP 地址，然后建立连接并获取网页内容。</p><h2 id="DNS配置的基本概念"><a href="#DNS配置的基本概念" class="headerlink" title="DNS配置的基本概念"></a>DNS配置的基本概念</h2><ol><li><p>域名注册：首先，你需要选择并注册一个域名，可以通过各大域名注册服务商进行购买和管理。</p></li><li><p>域名服务器（名称服务器）：域名服务器是存储和管理域名解析信息的服务器。当用户访问一个域名时，域名服务器将负责将域名解析为对应的 IP 地址。</p></li><li><p>DNS解析：DNS 解析是指将域名解析为 IP 地址的过程。它是通过查找域名服务器中存储的相关记录（如A记录、CNAME记录等）来进行的。</p></li></ol><h2 id="常见的DNS配置方法"><a href="#常见的DNS配置方法" class="headerlink" title="常见的DNS配置方法"></a>常见的DNS配置方法</h2><ol><li><p>A记录配置：A记录将域名直接映射到一个 IPv4 地址。在域名服务器的管理界面，创建一个A记录，设置域名和对应的IP地址，即可完成配置。</p></li><li><p>CNAME记录配置：CNAME记录允许将一个域名指向另一个域名。这在需要将多个域名指向同一个 IP 地址时非常有用。在域名服务器的管理界面，创建一个CNAME记录，设置域名和目标域名，即可完成配置。</p></li><li><p>MX记录配置：MX记录用于指定电子邮件服务器的地址。在域名服务器的管理界面，创建一个MX记录，设置邮件服务器的优先级和对应的域名或IP地址，即可完成配置。</p></li><li><p>TXT记录配置：TXT记录可以用于存储任意文本信息，常用于验证域名所有权、设置 SPF（发件人策略框架）等。在域名服务器的管理界面，创建一个TXT记录，并设置相应的文本信息，即可完成配置。</p></li><li><p>AAAA记录配置：AAAA记录用于将域名映射到一个 IPv6 地址。在域名服务器的管理界面，创建一个AAAA记录，设置域名和对应的IPv6地址，即可完成配置。</p></li></ol><h2 id="DNS配置生效时间及调试方法"><a href="#DNS配置生效时间及调试方法" class="headerlink" title="DNS配置生效时间及调试方法"></a>DNS配置生效时间及调试方法</h2><ol><li><p>DNS配置生效时间：DNS配置的生效时间可能需要一段时间（通常为数小时到一天），全球各地的 DNS 服务器需要时间来获取和更新新的配置。</p></li><li><p>DNS调试方法：可以使用 DNS 查询工具（如 Dig、Nslookup、mxtoolbox 等）进行 DNS 查询和调试，验证域名解析是否生效，并检查相关记录是否正确配置。</p></li></ol><p>DNS配置是构建互联网基础设施的关键步骤，通过正确配置和管理DNS，确保域名解析和服务访问的稳定性和可靠性。通过本文的介绍，你应该对DNS的基本概念和常见的配置方法有了初步了解，希望对你进行DNS配置提供一定的帮助。如果你想深入了解更多细节，可以参考相关文档和教程，或者咨询专业的DNS服务提供商。</p>]]></content>
      
      
      <categories>
          
          <category> WebEcology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web生态 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提升网站设计的绝佳选择：教你如何使用 FontAwesome 图标库</title>
      <link href="/posts/21975.html"/>
      <url>/posts/21975.html</url>
      
        <content type="html"><![CDATA[<p>在网站设计中，图标起着非常重要的作用，它们可以帮助传达信息、增加可视化吸引力和提升用户体验。本文将向你介绍如何使用 FontAwesome 这一流行的图标库，让你轻松地实现出色而引人注目的图标效果。</p><h2 id="FontAwesome-简介"><a href="#FontAwesome-简介" class="headerlink" title="FontAwesome 简介"></a>FontAwesome 简介</h2><p>FontAwesome 是一个免费的开源图标库，拥有超过一万多个矢量图标供你使用。它以 CSS 和字体文件的形式提供图标，可以轻松地自定义图标的样式、大小、颜色和动画效果。</p><h2 id="使用-FontAwesome-的步骤"><a href="#使用-FontAwesome-的步骤" class="headerlink" title="使用 FontAwesome 的步骤"></a>使用 FontAwesome 的步骤</h2><ol><li><p>下载和引入 FontAwesome：首先，你需要在官方网站 (fontawesome.com) 上下载最新版本的 FontAwesome。解压文件，复制所需的 CSS 文件或字体文件到你的项目文件夹中。在 HTML 文件的 <code>&lt;head&gt;</code> 标签中引入 CSS 文件。</p></li><li><p>添加图标到你的网页：FontAwesome 提供了丰富的图标选择。在需要添加图标的地方，使用 <code>&lt;i&gt;</code> 或 <code>&lt;span&gt;</code> 标签，并添加相应的类名，例如 <code>&lt;i class=&quot;fas fa-heart&quot;&gt;&lt;/i&gt;</code>。这将在页面上显示一个带有心形图标的元素。</p></li><li><p>定制图标样式：FontAwesome 提供了多种方式来自定义图标的外观。通过添加额外的类名，可以更改图标的大小、颜色和样式。例如，要增加图标的大小，可以使用 <code>fa-lg</code> 或 <code>fa-2x</code> 类名。</p></li><li><p>添加动画效果：FontAwesome 还支持添加动画效果，使图标更加生动和引人注目。通过添加 <code>fa-spin</code> 类名，可以使图标旋转起来。还可以使用其他类名，如 <code>fa-pulse</code>（脉冲效果）和 <code>fa-pulse</code>（跳动效果）。</p></li></ol><h2 id="技巧和注意事项"><a href="#技巧和注意事项" class="headerlink" title="技巧和注意事项"></a>技巧和注意事项</h2><ol><li><p>参考 FontAwesome 文档：FontAwesome 提供详细的文档，包括图标的类名、使用示例和定制选项。参考官方文档可以帮助你更好地了解和使用 FontAwesome。</p></li><li><p>结合其他 CSS 框架或库：FontAwesome 可以与其他流行的 CSS 框架和库（如Bootstrap）无缝集成。通过结合使用，可以进一步扩展和定制你的图标效果。</p></li><li><p>考虑兼容性：在使用 FontAwesome 时，要考虑到不同浏览器和设备的兼容性。确保在不同的环境中，图标正常显示且不影响页面的加载和性能。</p></li></ol><p>FontAwesome 是一个强大而灵活的图标库，为网站设计带来了无限的可能性。通过掌握基本的使用步骤和技巧，你可以轻松地为你的网站添加优秀的图标效果，提升用户体验和设计质量。</p>]]></content>
      
      
      <categories>
          
          <category> HtmlCss </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HtmlCss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入剖析Java变量：理解变量的本质与使用技巧</title>
      <link href="/posts/36533.html"/>
      <url>/posts/36533.html</url>
      
        <content type="html"><![CDATA[<p>在Java编程中，变量是一个非常基础和重要的概念。它可以用来存储和操作数据，是程序中的核心元素之一。本文将深入剖析Java变量的本质和使用技巧，帮助你更好地理解和运用变量。</p><h2 id="变量的定义与声明"><a href="#变量的定义与声明" class="headerlink" title="变量的定义与声明"></a>变量的定义与声明</h2><p>在Java中，变量是用来存储数据的容器。在使用变量之前，需要先进行声明和定义。变量的声明指的是告诉编译器我们要使用一个变量，并指定变量的类型和名称。变量的定义指的是实际为变量分配内存空间，并可以给变量赋初值。</p><p>Java的变量名是由字母、数字、下划线（_）和美元符号（$）组成的，不能以数字开头，不能使用Java的关键字作为变量名。例如，下面是一个声明和定义一个整型变量的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;</span><br><span class="line">num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>int</code>表示整型数据类型，<code>num</code>是变量的名称，<code>10</code>是变量的初值。</p><h2 id="变量的作用域和生命周期"><a href="#变量的作用域和生命周期" class="headerlink" title="变量的作用域和生命周期"></a>变量的作用域和生命周期</h2><p>变量的作用域指的是变量在程序中可见和可访问的范围。在Java中，变量的作用域可以分为局部变量和成员变量两种。</p><p>局部变量是在某个特定的代码块（如方法、循环体）中定义的变量，它的作用域限制在该代码块内。当代码执行离开该代码块时，局部变量的内存空间会被释放。</p><p>成员变量是定义在类中的变量，它的作用域限制在整个类中。成员变量在对象创建时被分配内存空间，并在对象销毁时释放。</p><h2 id="变量的赋值和使用"><a href="#变量的赋值和使用" class="headerlink" title="变量的赋值和使用"></a>变量的赋值和使用</h2><p>在Java中，变量可以被赋值和使用。变量的赋值可以通过直接赋值、表达式赋值、方法返回值赋值等方式进行。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a + <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getMax(a, b);</span><br></pre></td></tr></table></figure><p>上述代码中，<code>a</code>变量直接赋值为10，<code>b</code>变量通过表达式<code>a + 5</code>赋值，<code>c</code>变量通过方法返回值赋值。</p><p>变量的使用可以通过变量名直接引用变量的值。例如，可以使用<code>System.out.println(a)</code>来打印变量<code>a</code>的值。</p><h2 id="变量的命名规范和约定"><a href="#变量的命名规范和约定" class="headerlink" title="变量的命名规范和约定"></a>变量的命名规范和约定</h2><p>良好的变量命名可以提高代码的可读性和可维护性。在命名变量时，应遵循以下规范和约定：</p><ol><li>变量名应具有描述性，能够清晰地表达变量的含义；</li><li>变量名采用驼峰命名法，即首个单词小写，后续单词首字母大写，不含下划线；</li><li>常量名使用全大写，并使用下划线分隔单词；</li><li>避免使用单个字符作为变量名，除非表示计数或临时变量。</li></ol><h2 id="变量的类型和转换"><a href="#变量的类型和转换" class="headerlink" title="变量的类型和转换"></a>变量的类型和转换</h2><p>Java中的变量有多种类型，包括整型、浮点型、字符型、布尔型等。不同类型的变量在存储和使用上有所区别，开发人员需要根据实际需求选择合适的变量类型。</p><p>在程序中，有时需要进行变量类型的转换。例如，将一个整型变量赋给浮点型变量时，会发生自动类型转换。而将一个浮点型变量赋给整型变量时，需要进行强制类型转换。</p><h2 id="常见变量错误和注意事项"><a href="#常见变量错误和注意事项" class="headerlink" title="常见变量错误和注意事项"></a>常见变量错误和注意事项</h2><p>在使用变量时，有一些常见的错误和需要注意的事项：</p><ol><li>变量使用前未初始化：在使用变量之前，要确保为其赋予初值，否则会导致编译错误；</li><li>变量作用域错误：在使用局部变量时，要注意其生命周期和作用域，避免超出范围的引用；</li><li>变量类型不匹配：在进行变量赋值和计算时，要确保类型匹配，避免编译错误或运行时异常。</li></ol><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>通过本文的介绍，我们深入剖析了Java变量的本质和使用技巧。变量作为Java编程中的核心概念之一，对于掌握Java语言和编写优秀的代码具有重要意义。</p><p>良好的变量定义、命名和使用习惯能够提升代码质量和开发效率。希望本文对你理解和运用Java变量有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入探索Java引用数据类型：从基础到进阶</title>
      <link href="/posts/39770.html"/>
      <url>/posts/39770.html</url>
      
        <content type="html"><![CDATA[<p>Java是一门面向对象的编程语言，引用数据类型是其核心概念之一。在Java中，除了基本数据类型外，我们还会常常使用引用数据类型来表示复杂的数据结构和对象。本文将带你深入探索Java引用数据类型的基础知识，并介绍一些进阶的应用场景。</p><h2 id="引用数据类型的定义与声明"><a href="#引用数据类型的定义与声明" class="headerlink" title="引用数据类型的定义与声明"></a>引用数据类型的定义与声明</h2><p>引用数据类型是Java中用来表示对象、类和接口的数据类型。与基本数据类型（如int、double等）不同，引用数据类型在内存中存储的是对象的引用，而非对象本身。</p><p>在Java中，我们可以通过类名或接口名来声明一个引用变量。例如，声明一个<code>Person</code>类的对象引用变量可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person person;</span><br></pre></td></tr></table></figure><p>这样的声明并不会在内存中实际创建对象，而只是为引用变量分配了存储空间，使得它可以引用一个<code>Person</code>类的对象。</p><h2 id="引用数据类型的初始化与赋值"><a href="#引用数据类型的初始化与赋值" class="headerlink" title="引用数据类型的初始化与赋值"></a>引用数据类型的初始化与赋值</h2><p>要创建一个具体的对象，需要使用<code>new</code>关键字来为引用变量实例化一个对象。例如，创建一个<code>Person</code>类的对象可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>上述代码中，<code>new Person()</code>创建了一个<code>Person</code>类的对象，并通过赋值操作将对象的引用赋给了<code>person</code>引用变量。</p><h2 id="引用数据类型的特性和操作"><a href="#引用数据类型的特性和操作" class="headerlink" title="引用数据类型的特性和操作"></a>引用数据类型的特性和操作</h2><p>引用数据类型在内存中存储的是对象的引用，通过引用变量可以访问和操作对象的属性和方法。例如，通过<code>person.getName()</code>可以获取<code>Person</code>对象的名称属性值。</p><p>与基本数据类型不同，引用数据类型的大小在内存中是固定的，无论对象本身的大小是多少。因为引用数据类型所占空间的大小与对象本身的大小无关，而是由引用变量的大小决定的。</p><h2 id="引用数据类型的内存管理"><a href="#引用数据类型的内存管理" class="headerlink" title="引用数据类型的内存管理"></a>引用数据类型的内存管理</h2><p>Java中的垃圾回收机制负责管理引用数据类型的内存。当一个对象不再被引用时，垃圾回收器会自动将其标记为垃圾，并进行内存回收。开发人员无需手动释放对象所占用的内存，这样一方面减轻了内存管理的负担，另一方面也避免了内存泄漏的问题。</p><p>需要注意的是，Java中的引用数据类型是存在空指针的可能性的。当一个引用变量没有指向任何对象时，它的值为<code>null</code>。使用空指针引用变量访问对象的属性或方法将导致空指针异常的发生。因此，在使用引用数据类型时，要注意进行空指针判断，以避免程序的异常终止。</p><h2 id="引用数据类型的进阶应用"><a href="#引用数据类型的进阶应用" class="headerlink" title="引用数据类型的进阶应用"></a>引用数据类型的进阶应用</h2><p>除了基本的使用方式外，引用数据类型还有许多进阶的应用场景。例如，使用数组来存储多个对象的引用，通过循环遍历数组可以批量操作对象；使用集合类来管理动态对象集合，提供更丰富的数据操作方法；使用泛型来提高代码的可重用性和类型安全性等等。</p><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>通过本文的介绍，我们对Java引用数据类型有了更深入的了解。引用数据类型在Java中是非常重要的，它提供了灵活且强大的对象操作能力。合理地运用引用数据类型，可以编写出更加高效、可维护的代码。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基本数据类型揭秘：数据的奥义与转换技巧</title>
      <link href="/posts/33481.html"/>
      <url>/posts/33481.html</url>
      
        <content type="html"><![CDATA[<p>今天，让我们一起深入探索Java的基本数据类型，并详细了解它们的特点、取值范围以及适用场景。对于Java开发者来说，熟悉基本数据类型是编写高效和可靠代码的关键。现在就跟随我一同揭开Java基本数据类型背后的内幕吧！</p><h2 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h2><p>在Java中，有四种整数类型：</p><ol><li><p>byte：占用1个字节，范围在-128至127之间。适用于节省内存的情况，如存储一个很小的整数值。</p></li><li><p>short：占用2个字节，范围在-32768至32767之间。适用于需要中等范围的整数值存储，如计数和数量。</p></li><li><p>int：占用4个字节，范围在-2147483648至2147483647之间。是Java中使用最广泛的整数类型，适用于大多数整数计算和变量存储。</p></li><li><p>long：占用8个字节，范围在-9223372036854775808至9223372036854775807之间。适用于特别大范围的整数值，如时间戳操作和位运算等。</p></li></ol><h2 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h2><p>在Java中，有两种浮点数类型：</p><ol><li><p>float：占用4个字节，精度为7位有效数字。适用于存储较大的浮点数值，并且对精度要求不是十分严格的情况，如科学计算、图形处理等。</p></li><li><p>double：占用8个字节，精度为15位有效数字。是Java中使用最广泛的浮点数类型，适用于需要更高精度的浮点数计算，如财务计算、物理学等。</p></li></ol><h2 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h2><p>在Java中，字符类型使用char来表示，占用2个字节。它用于存储单个字符，如字母、数字、标点符号等。可以用单引号括起来，例如：<code>char ch = &#39;A&#39;;</code>。字符类型适用于处理文本和字符操作，如密码输入、字符串处理等。</p><h2 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h2><p>Java的布尔类型用boolean来表示，只占用1个字节。它只有两个值：true（真）和false（假）。布尔类型适用于判断条件和控制流程，如条件判断、循环控制等。例如：<code>boolean isTrue = true;</code>。</p><h2 id="常量类型和字面常量"><a href="#常量类型和字面常量" class="headerlink" title="常量类型和字面常量"></a>常量类型和字面常量</h2><p>在Java中，常量类型指的是用final关键字声明的不可变的变量。常量类型可以是任何基本数据类型，并且在声明时必须进行初始化，并且初始化后不能再修改常量的值。例如：<code>final int MAX_VALUE = 100;</code>。</p><p>此外，还有字面常量，它们是直接写入代码的常量值。例如，整数常量<code>int num = 10;</code>、浮点数常量<code>float num = 3.14;</code>、字符常量<code>char ch = &#39;A&#39;;</code>、布尔常量<code>boolean isTrue = true;</code>等。</p><h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><p>在Java中，数据类型之间的转换分为两种类型：</p><ol><li><p>自动类型转换：当容量小的数据类型和容量大的数据类型进行运算时，会自动将小类型转换为大类型，以避免数据丢失。例如，int类型可以自动转换为long类型。</p></li><li><p>强制类型转换：当将容量大的数据类型赋值给容量小的数据类型时，需要进行强制类型转换。强制类型转换可能会导致数据精度的损失或溢出，需要谨慎使用。</p></li></ol><h2 id="写在结尾"><a href="#写在结尾" class="headerlink" title="写在结尾"></a>写在结尾</h2><p>本文详细介绍了Java的基本数据类型，包括整数类型、浮点数类型、字符类型和布尔类型。同时，我们还了解了常量类型和字面常量的概念，并简要讨论了数据类型之间的转换。</p><p>通过深入学习和实践，我们能够更好地应用和理解Java的基本数据类型。熟悉不同数据类型的特点和使用场景，将帮助我们编写高效、可靠和易于维护的代码。</p><p>希望本文对您在Java编程中理解和应用基本数据类型有所帮助。愿您在编程的世界中不断探索、不断进步！感谢大家的阅读与支持！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解析Java数据类型：探索数据存储的多样性</title>
      <link href="/posts/41318.html"/>
      <url>/posts/41318.html</url>
      
        <content type="html"><![CDATA[<p>今天，让我们一起深入探索Java数据类型，了解不同数据类型的特点和应用场景。作为Java开发者，熟悉选择合适的数据类型将使您的程序更加高效和可靠。让我们开始探索Java数据类型的多样性吧！</p><h2 id="什么是数据类型？"><a href="#什么是数据类型？" class="headerlink" title="什么是数据类型？"></a>什么是数据类型？</h2><p>在编程中，数据类型是用来声明变量和解释内存中存储数据的方式。Java是一种静态类型的编程语言，每个变量都需要被指定数据类型。数据类型决定了变量可存储的数据类型和所占用的内存空间。</p><h2 id="Java的基本数据类型"><a href="#Java的基本数据类型" class="headerlink" title="Java的基本数据类型"></a>Java的基本数据类型</h2><p>Java提供了一组基本数据类型，用于存储简单的值。以下是Java的基本数据类型：</p><ol><li><p>整数类型：byte、short、int、long</p></li><li><p>浮点数类型：float、double</p></li><li><p>字符类型：char</p></li><li><p>布尔类型：boolean</p></li></ol><p>这些基本数据类型直接存储在内存中，具有固定的大小和取值范围。您可以根据需求选择最合适的数据类型。</p><h2 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h2><p>除了基本数据类型，Java还提供了引用数据类型，用于存储复杂的对象。引用数据类型包括类、接口、数组等，它们在内存中存储的是对象的引用。</p><ol><li><p>类：通过关键字<code>class</code>定义，可以包含属性（变量）和方法。</p></li><li><p>接口：通过关键字<code>interface</code>定义，声明了一组方法的规范。</p></li><li><p>数组：通过使用<code>[]</code>来声明，可以存储多个相同类型的元素。</p></li></ol><p>引用数据类型在内存中存储的是对象的地址，而不是实际的数据本身。这使得Java能够有效地管理和操作复杂的数据结构。</p><h2 id="常量和常量类型"><a href="#常量和常量类型" class="headerlink" title="常量和常量类型"></a>常量和常量类型</h2><p>除了变量，Java还提供了常量和常量类型。常量是不可修改的值，常量类型是指可以保存常量的数据类型。</p><ol><li><p>字面常量：直接写入代码的常量，如整数常量、浮点数常量、字符串常量等。</p></li><li><p>final常量：使用关键字<code>final</code>声明的常量，一旦赋值后就无法更改。</p></li><li><p>枚举常量：通过关键字<code>enum</code>声明的常量，用于定义一组有限的值。</p></li></ol><p>常量提供了在程序中使用不变值的方法，可以提高代码的可维护性和可读性。</p><h2 id="数据类型的选择和使用注意事项"><a href="#数据类型的选择和使用注意事项" class="headerlink" title="数据类型的选择和使用注意事项"></a>数据类型的选择和使用注意事项</h2><p>在选择和使用数据类型时，需要考虑以下因素：</p><ol><li><p>取值范围：选择合适的数据类型以确保变量能够存储所需的值范围。</p></li><li><p>内存占用：不同的数据类型占用不同大小的内存，应根据数据量和性能需求进行选择。</p></li><li><p>类型转换：在不同数据类型之间进行转换时，确保类型兼容，并注意数据丢失的可能性。</p></li><li><p>数据精度：浮点数类型的精度有限，需要注意精确计算时的误差问题。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java的基本数据类型、引用数据类型和常量类型，以及选择和使用数据类型的注意事项。</p><p>进一步学习Java数据类型，请阅读Java官方文档、Java编程书籍和在线教程，深入理解数据类型的细节和使用技巧。同时，通过编写代码和实践项目来锻炼自己的数据类型选择和使用能力。</p><p>希望本文对您理解和应用Java数据类型有所帮助。掌握数据类型是成为一名优秀的Java开发者的重要基础。愿您在编程的旅程中不断学习和进步！谢谢各位读者的支持！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解密Java关键字：探索Java语言的特殊力量</title>
      <link href="/posts/29193.html"/>
      <url>/posts/29193.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将深入探讨Java关键字，探索这些特殊的标识符在Java语言中的重要意义和作用。作为Java开发者，了解和正确使用关键字将为您的代码提供更强大的功能和更高的效率。让我们一同探索Java关键字的魅力！</p><h2 id="什么是关键字？"><a href="#什么是关键字？" class="headerlink" title="什么是关键字？"></a>什么是关键字？</h2><p>在Java中，关键字是一组被保留并且具有特殊意义的标识符。这些关键字在Java编程语言中有特定的用途，不能用作标识符（比如变量、方法或类名）。Java关键字是由语言规范定义的，每个关键字都有其独特的功能和语法。</p><h2 id="常用的Java关键字"><a href="#常用的Java关键字" class="headerlink" title="常用的Java关键字"></a>常用的Java关键字</h2><ol><li><p>public、private、protected：访问修饰符，用于定义类、方法和变量的可访问性范围。</p></li><li><p>class、interface：用于声明类和接口。</p></li><li><p>extends、implements：继承和实现，用于实现类之间的继承和接口的实现。</p></li><li><p>static、final：用于定义静态成员和常量，可以通过类名直接访问。</p></li><li><p>void：用于方法签名中，表示方法没有返回值。</p></li><li><p>new、this、super：用于创建新对象、引用当前对象和引用父类对象。</p></li><li><p>if、else、switch、case、default：条件语句和分支控制关键字，用于控制程序的执行路径。</p></li><li><p>for、while、do-while：循环语句的关键字，用于重复执行一段代码。</p></li><li><p>break、continue：用于在循环或switch语句中改变程序的执行流程。</p></li><li><p>try、catch、finally：异常处理的关键字，用于捕获和处理异常。</p></li></ol><h2 id="特殊的关键字"><a href="#特殊的关键字" class="headerlink" title="特殊的关键字"></a>特殊的关键字</h2><p>除了常用的关键字外，Java还有一些特殊的关键字，具有特定的作用：</p><ol><li><p>native：用于标识本地方法，即由其他语言（如C、C++）实现的Java方法。</p></li><li><p>synchronized：用于实现线程安全的同步访问。</p></li><li><p>transient、volatile：用于定义变量的特殊属性，分别标识变量不被序列化和变量的可见性。</p></li><li><p>enum：用于定义枚举类型，提供一组有限的值。</p></li><li><p>package、import：用于声明包和导入类。</p></li></ol><h2 id="关键字的使用注意事项"><a href="#关键字的使用注意事项" class="headerlink" title="关键字的使用注意事项"></a>关键字的使用注意事项</h2><ol><li><p>大小写敏感：Java关键字是大小写敏感的，需以正确的大小写形式使用。</p></li><li><p>不作为标识符：关键字不能用作变量、方法、类名等标识符。</p></li><li><p>命名规范：建议避免与关键字同名的标识符，以免引起混淆和错误。</p></li><li><p>版本差异：Java的不同版本可能对关键字进行扩展或修改，需要根据使用的Java版本来选择适当的关键字。</p></li></ol><h2 id="扩展学习和总结"><a href="#扩展学习和总结" class="headerlink" title="扩展学习和总结"></a>扩展学习和总结</h2><p>本文介绍了Java关键字的概念、常见的关键字以及一些特殊关键字。了解和正确使用Java关键字将使您更好地理解和编写Java代码。</p><p>进一步学习Java关键字的知识，您可以阅读Java官方文档、Java编程书籍和在线教程。此外，参与Java社区的讨论和交流也是提升自己的好方式。</p><p>在使用Java关键字时，请确保理解其用法和限制，并在编码过程中遵循最佳实践。通过不断的学习和实践，相信您将能够熟练掌握Java关键字，并在编程中发挥它们的特殊力量。</p><p>感谢各位读者的阅读，希望本文能为您提供有价值的Java关键字知识。愿您在编程的旅程中越走越远！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java JDK：解锁编程之门，探索Java开发必备利器</title>
      <link href="/posts/55389.html"/>
      <url>/posts/55389.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将带您进入Java开发的精彩世界，为您介绍Java Development Kit（JDK）这个必备利器。如果您是一个初学者，或者对Java开发感兴趣，那么本文将为您提供入门所需的关键信息和指导。让我们一同探索Java开发中的JDK吧！</p><h2 id="什么是Java-JDK？"><a href="#什么是Java-JDK？" class="headerlink" title="什么是Java JDK？"></a>什么是Java JDK？</h2><p>Java JDK是Java开发中的核心工具包，包含了一系列开发和运行Java应用程序所需的工具和库。它提供了编译、调试、运行和部署Java代码的功能，是Java开发的不可或缺的组成部分。</p><h2 id="为什么需要了解JDK？"><a href="#为什么需要了解JDK？" class="headerlink" title="为什么需要了解JDK？"></a>为什么需要了解JDK？</h2><p>了解JDK的重要性在于它对于Java开发的基础和核心功能提供了支持。以下是为什么要了解JDK的几个重要原因：</p><ol><li><p>编译和运行Java代码：JDK中包含了Java编译器（javac），可以将Java源代码编译成可执行的字节码文件。同时，JDK提供了Java Virtual Machine（JVM）来执行这些字节码文件。</p></li><li><p>开发工具和库：JDK提供了丰富的开发工具和库，包括调试器、性能分析工具、图形界面库等。这些工具和库能够提升您的开发效率和代码质量。</p></li><li><p>版本管理和兼容性：JDK的不同版本之间可能存在一些差异，了解各个版本的特性和变化对于代码的迁移和兼容性非常重要。</p></li></ol><h2 id="JDK版本介绍"><a href="#JDK版本介绍" class="headerlink" title="JDK版本介绍"></a>JDK版本介绍</h2><p>Java JDK经历了多个版本的演进和迭代，每个版本都引入了新的功能和改进。以下是几个常见的JDK版本：</p><ol><li><p>JDK 8：这个版本引入了很多重要的特性，如Lambda表达式、Stream API、新的Date/Time API等。</p></li><li><p>JDK 11：此版本是一个长期支持（LTS）版本，提供了新的特性和性能优化，同时降低了内存占用。</p></li><li><p>JDK 15：此版本引入了包括记录类型（Records）、Pattern Matching for instanceof等在内的多项新功能。</p></li></ol><h2 id="安装JDK的步骤"><a href="#安装JDK的步骤" class="headerlink" title="安装JDK的步骤"></a>安装JDK的步骤</h2><p>安装JDK是开始Java开发的第一步。以下是安装JDK的一般步骤：</p><ol><li><p>下载JDK安装包：您可以从Oracle官网（<a href="https://www.oracle.com/java/technologies/javase-jdk11-downloads.html">https://www.oracle.com/java/technologies/javase-jdk11-downloads.html</a>）下载合适的JDK安装包。</p></li><li><p>安装JDK：按照下载的安装包的指引执行安装操作。根据不同的操作系统，可能需要配置环境变量（如JAVA_HOME）以使JDK可用。</p></li><li><p>验证安装：安装完成后，可以在命令行运行<code>java -version</code>命令来验证JDK的安装是否成功。</p></li></ol><h2 id="学习资源和练习"><a href="#学习资源和练习" class="headerlink" title="学习资源和练习"></a>学习资源和练习</h2><p>学习Java开发需要不断学习和练习。以下是一些提升Java开发技能和知识的资源：</p><ol><li><p>官方文档和教程：Oracle官方提供了丰富的文档和教程，适合初学者入门和进阶学习。</p></li><li><p>在线课程和教学视频：诸如Coursera、Udemy、Codecademy等在线学习平台提供了许多Java开发相关的课程和教学视频。</p></li><li><p>开发工具和IDE：使用流行的开发工具和集成开发环境（IDE），如Eclipse、IntelliJ IDEA等，可以提供更多支持信息。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业数字化：引领未来商业发展的关键</title>
      <link href="/posts/64847.html"/>
      <url>/posts/64847.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><p>​  随着信息技术的飞跃发展，企业数字化已成为引领未来商业发展的关键要素。本文将探讨企业数字化的含义、重要性以及实施数字化转型的关键策略，旨在帮助企业把握数字化机遇，迈向全面发展的新高度。</p><h2 id="企业数字化的含义和重要性"><a href="#企业数字化的含义和重要性" class="headerlink" title="企业数字化的含义和重要性"></a>企业数字化的含义和重要性</h2><p>​  企业数字化是指将传统的商业活动以数字化方式进行，通过技术和网络平台来实现管理、运营和创新的转型过程。它涵盖了包括业务流程、组织结构、客户关系、市场营销等方面的数字化化改造，旨在提高效率、降低成本、提升竞争力。</p><p>​  企业数字化的重要性不可忽视。首先，数字化能够实现业务流程的高度自动化和集成化，提升企业的运营效率和灵活性。其次，数字化极大地扩展了企业的市场触角，打破了地域限制，带来全球范围内的商机和合作伙伴。再次，数字化为企业创新提供了无限可能，通过大数据分析和人工智能等技术手段，企业能够更加准确地洞察市场需求，开发出高质量的产品和服务。</p><h2 id="实施数字化转型的关键策略"><a href="#实施数字化转型的关键策略" class="headerlink" title="实施数字化转型的关键策略"></a>实施数字化转型的关键策略</h2><ol><li><p>制定清晰的数字化战略：企业需要明确数字化的目标和方向，制定可行的战略计划，并将其与企业的整体战略相衔接。数字化战略应该包括改造业务流程、优化组织结构、提升客户体验等方面。</p></li><li><p>投资适当的技术和平台：企业需要评估和选择适合自身需求的技术和平台，例如云计算、大数据分析、人工智能等。同时，企业还需要建立健全的信息技术基础设施，确保数字化转型的顺利进行。</p></li><li><p>建设高效的数字化团队：企业应该拥有一支专业的数字化团队，包括技术人员、数据分析师、数字营销专家等。这支团队能够推动数字化战略的实施，提供相关的技术支持和培训，确保数字化转型的成功。</p></li><li><p>提升组织文化和员工意识：企业数字化的成功还取决于组织文化和员工意识的转变。企业应该鼓励创新思维和信息共享，提供培训和奖励机制，激发员工参与到数字化转型中来。</p></li></ol><blockquote><p>Conclusion</p><p>企业数字化已经成为未来商业发展的不可或缺的一部分。通过实施数字化转型，企业能够提高效率、拓展市场、实现创新，并保持竞争优势。然而，在数字化转型的过程中，企业需要制定清晰的战略、选择适当的技术、建设强大的团队以及改变组织文化和员工意识。只有通过实施一系列的关键策略，企业才能在数字时代中立足并持续发展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Digitalize </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Digitalize </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>企业数字化：引领未来商业发展的关键</title>
      <link href="/posts/64847.html"/>
      <url>/posts/64847.html</url>
      
        <content type="html"><![CDATA[<p>摘要</p><p>​  随着信息技术的飞跃发展，企业数字化已成为引领未来商业发展的关键要素。本文将探讨企业数字化的含义、重要性以及实施数字化转型的关键策略，旨在帮助企业把握数字化机遇，迈向全面发展的新高度。</p><h2 id="企业数字化的含义和重要性"><a href="#企业数字化的含义和重要性" class="headerlink" title="企业数字化的含义和重要性"></a>企业数字化的含义和重要性</h2><p>​  企业数字化是指将传统的商业活动以数字化方式进行，通过技术和网络平台来实现管理、运营和创新的转型过程。它涵盖了包括业务流程、组织结构、客户关系、市场营销等方面的数字化化改造，旨在提高效率、降低成本、提升竞争力。</p><p>​  企业数字化的重要性不可忽视。首先，数字化能够实现业务流程的高度自动化和集成化，提升企业的运营效率和灵活性。其次，数字化极大地扩展了企业的市场触角，打破了地域限制，带来全球范围内的商机和合作伙伴。再次，数字化为企业创新提供了无限可能，通过大数据分析和人工智能等技术手段，企业能够更加准确地洞察市场需求，开发出高质量的产品和服务。</p><h2 id="实施数字化转型的关键策略"><a href="#实施数字化转型的关键策略" class="headerlink" title="实施数字化转型的关键策略"></a>实施数字化转型的关键策略</h2><ol><li><p>制定清晰的数字化战略：企业需要明确数字化的目标和方向，制定可行的战略计划，并将其与企业的整体战略相衔接。数字化战略应该包括改造业务流程、优化组织结构、提升客户体验等方面。</p></li><li><p>投资适当的技术和平台：企业需要评估和选择适合自身需求的技术和平台，例如云计算、大数据分析、人工智能等。同时，企业还需要建立健全的信息技术基础设施，确保数字化转型的顺利进行。</p></li><li><p>建设高效的数字化团队：企业应该拥有一支专业的数字化团队，包括技术人员、数据分析师、数字营销专家等。这支团队能够推动数字化战略的实施，提供相关的技术支持和培训，确保数字化转型的成功。</p></li><li><p>提升组织文化和员工意识：企业数字化的成功还取决于组织文化和员工意识的转变。企业应该鼓励创新思维和信息共享，提供培训和奖励机制，激发员工参与到数字化转型中来。</p></li></ol><blockquote><p>Conclusion</p><p>企业数字化已经成为未来商业发展的不可或缺的一部分。通过实施数字化转型，企业能够提高效率、拓展市场、实现创新，并保持竞争优势。然而，在数字化转型的过程中，企业需要制定清晰的战略、选择适当的技术、建设强大的团队以及改变组织文化和员工意识。只有通过实施一系列的关键策略，企业才能在数字时代中立足并持续发展。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Internet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Internet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>探索Java开发的专有名词：掌握专有术语，驾驭编程世界！</title>
      <link href="/posts/4785.html"/>
      <url>/posts/4785.html</url>
      
        <content type="html"><![CDATA[<p>Java是一种广泛应用的编程语言，在Java开发中有一些必须了解的专有名词。对于初学者来说，这些名词可能有些陌生，但理解它们对于掌握Java开发是至关重要的。在本文中，我们将简单明了地介绍这些专有名词。</p><ol><li><p>JDK（Java Development Kit）<br>JDK是Java开发工具包，它是开发Java应用程序所必需的核心工具集。其中包括了编译器（用于将Java源代码编译为字节码）、调试器（用于调试程序）、类库（提供各种Java类和方法）等。JDK是开发Java应用程序的基石，必须安装和配置好才能开始编写Java代码。</p></li><li><p>JVM（Java Virtual Machine）<br>JVM是Java虚拟机，它是Java程序运行的环境。JVM会将Java字节码解释或编译成机器码，并执行程序。JVM具有跨平台特性，使得Java程序在不同的操作系统上能够运行。</p></li><li><p>OOP（Object-Oriented Programming）<br>OOP是面向对象编程的缩写，是一种编程范式。在Java中，一切都是对象，通过封装、继承和多态等概念，以对象为基本单位进行软件设计和开发。OOP使得代码更加模块化、可维护和可扩展。</p></li><li><p>IDE（Integrated Development Environment）<br>IDE是集成开发环境，它提供了一站式的开发工具。IDE包含代码编辑器、编译器、调试器和其他辅助工具，使得开发者可以更高效地编写、调试和测试代码。常见的Java IDE有Eclipse、IntelliJ IDEA等。</p></li><li><p>API（Application Programming Interface）<br>API是应用程序接口，它定义了软件组件之间的通信规范。通过API，开发者可以调用其他软件组件提供的方法和函数，访问其功能和数据。Java提供了丰富的API，包括图形界面、网络通信、数据库访问等方面。</p></li><li><p>MVC（Model-View-Controller）<br>MVC是一种软件架构模式，将应用程序分成三个核心部分：模型（Model）、视图（View）和控制器（Controller）。模型负责处理数据逻辑，视图负责展示数据和用户界面，控制器负责处理用户的输入和交互。这种分离有助于提高代码的可维护性和可扩展性。</p></li><li><p>Servlet<br>在Java Web开发中，Servlet是运行在服务器端的Java程序。它接收和处理HTTP请求，并生成响应。Servlet通常用于构建动态的Web应用程序，可以与HTML、CSS、JavaScript等前端技术结合使用。</p></li><li><p>JDBC（Java Database Connectivity）<br>JDBC是Java数据库连接，它是一种Java API，用于连接和操作数据库。通过JDBC，开发者可以与各种数据库建立连接，并执行SQL查询、更新等操作。JDBC给予开发者对数据库的灵活控制能力。</p></li></ol><p>了解这些专有名词对于Java开发者而言是非常重要的。它们是Java开发中的基础，深入学习和理解将有助于提高编程能力和开发效率。通过不断实践和探索，你会发现Java是一个强大而广泛应用的开发语言。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL执行过程</title>
      <link href="/posts/65435.html"/>
      <url>/posts/65435.html</url>
      
        <content type="html"><![CDATA[<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="https://www.cdn.cheneyblog.com/blog/202307291635919.png" alt="SQL语句执行流程图"></p><h2 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h2><h3 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h3><p>  用户在客户端输入执行SQL，该SQL语句通过session传输到服务器端，服务器通过Server Process接收SQL语句。客户端无需再做其他的操作，只是将SQL语句发送给服务端。</p><h3 id="查看Lib-Cache"><a href="#查看Lib-Cache" class="headerlink" title="查看Lib Cache"></a>查看Lib Cache</h3><p>  服务器进程在接到客户端传送过来的 SQL 语句后，不会直接去数据库查询。服务器进程会把这个 SQL 语句的字符进行转码，将转码后的值传递给一个 HASH 函数，并返回一个 hash 值，然后服务器进程将到 shared pool 的 library cache （高速缓存）中去查找是否存在相同的 hash 值。如果存在，服务器进程将使用这条语句已高速缓存在 library cache 中的已分析过的解析树和执行计划，省去后续的解析工作，这便是软解析。若高速缓存中不存在，则仍需要继续解析SQL、生成最佳执行计划，这便是硬解析，硬解析通常是昂贵的操作，大约占整个 SQL 执行的 70% 左右的时间。<br>​  所以，采用高速数据缓存的话，可以提高 SQL 语句的查询效率。其原因有两方面：一方面是从内存中读取数据要比从硬盘中的数据文件中读取数据效率要高，另一方面也是因为避免语句解析而节省了时间。</p><h3 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h3><p>  分析SQL语句的语法是否符合规范，如果服务器进程认为这条 SQL 语句不符合语法规则的时候，就会把这个错误信息反馈给客户端。在这个语法检查的过程中，不会对 SQL 语句中所包含的表名、列名等等进行检查，只是检查语法。</p><h3 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h3><p>  服务器进程接下去会对语句中涉及的表、索引、视图等对象进行解析，并对照数据字典检查这些对象的名称以及相关结构，看看这些字段、表、视图等是否在数据库中。如果存在问题的话，则数据库就会反馈错误信息给客户端。</p><h3 id="对象解析锁"><a href="#对象解析锁" class="headerlink" title="对象解析锁"></a>对象解析锁</h3><p>  系统会对我们需要查询的对象加锁，主要是为了保障数据的一致性，防止我们在查询的过程中，其他用户对这个对象的结构发生改变。</p><h3 id="权限核对"><a href="#权限核对" class="headerlink" title="权限核对"></a>权限核对</h3><p>  服务器进程还会检查连接用户是否有语句涉及对象的相关权限，若用户不具备相应权限的话则也会返回客户端。</p><h3 id="查询转换"><a href="#查询转换" class="headerlink" title="查询转换"></a>查询转换</h3><p>  视图转换，将涉及视图的查询语句转换为相应的对基表查询语句。<br>​  表达式转换， 将复杂的 SQL 表达式转换为较简单的等效连接表达式。</p><h3 id="选定执行计划"><a href="#选定执行计划" class="headerlink" title="选定执行计划"></a>选定执行计划</h3><p>  选择优化器，不同的优化器一般产生不同的“执行计划”。<br>​  选择连接方式，ORACLE有四种连接方式，对多表连接ORACLE可选择适当的连接方式。<br>​  选择连接顺序，对多表连接ORACLE选择驱动表和被驱动表。<br>​  选择数据的搜索路径，根据以上条件选择合适的数据搜索路径，如是选用全表搜索还是利用索引或是其他的方式。<br>​  在生成的多个执行计划中，按统计信息带入，找出执行成本最小的执行计划，作为执行此SQL语句的执行计划。<br>​  将SQL文本、解析树、执行计划缓存到库缓存，存放地址以及SQL语句的哈希值，以便下次执行该SQL时可直接获取相关信息。</p><h2 id="语句执行"><a href="#语句执行" class="headerlink" title="语句执行"></a>语句执行</h2><h3 id="查询语句（Select）"><a href="#查询语句（Select）" class="headerlink" title="查询语句（Select）"></a>查询语句（Select）</h3><p>  首先服务器进程要判断所需数据是否在 db buffer 存在，如果存在且可用，则直接获取该数据而不是从数据库文件中去查询数据，同时根据 LRU 算法增加其访问计数；</p><p>  若数据不在缓冲区中，则服务器进程将从数据库文件中查询相关数据，并把这些数据放入到数据缓冲区中（ buffer cache ）。</p><p>  其中，判断数据的存在性和可用性检查方式为：查看 db buffer 块的头部是否有事务，如果有事务，则从回滚段中读取数据；如果没有事务，则比较 select 的 scn 和 db buffer 块头部的 scn ，如果前者小于后者，仍然要从回滚段中读取数据；如果前者大于后者，说明这是一非脏缓存，可以直接读取这个 db buffer 块的中内容。<br><strong>SQL Select语句完整的执行顺序</strong></p><ol><li>from子句组装来自不同数据源的数据；</li><li>where子句基于指定的条件对记录行进行筛选；</li><li>group by子句将数据划分为多个分组；</li><li>使用聚集函数进行计算；</li><li>使用having子句筛选分组；</li><li>计算所有的表达式；</li><li>使用order by对结果集进行排序；</li><li>执行select。</li></ol><h3 id="DML语句（Insert、Update、Delete）"><a href="#DML语句（Insert、Update、Delete）" class="headerlink" title="DML语句（Insert、Update、Delete）"></a>DML语句（Insert、Update、Delete）</h3><ol><li><p>检查所需的数据是否已经被读取到缓冲区中。如果已经存在缓冲区，则跳过第2部；</p></li><li><p>若所需的数据库并不在缓冲区缓存中，则服务器将数据块从数据文件读取到缓冲区中缓存；</p></li><li><p>对想要修改的表取得的数据行锁定（ Row Exclusive Lock ），之后对所需要修改的数据行取得独占锁；</p></li><li><p>将数据的 Redo 记录复制到 redo log buffer ；</p></li><li><p>产生数据修改的 undo 数据；</p></li><li><p>修改 db buffer ；</p></li><li><p>dbwr 将修改写入数据文件；</p></li></ol><h2 id="返回客户端"><a href="#返回客户端" class="headerlink" title="返回客户端"></a>返回客户端</h2><p>SQL语句被处理完成后Select语句会将查询结果返回给客户端，DML语句执行完后数据库会将对应的执行结果返回给客户端。最终客户端按照不同的方式呈现给用户。至此该SQL语句的生命周期完毕。</p>]]></content>
      
      
      <categories>
          
          <category> Oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TDSQL For MySQL认证-单选题</title>
      <link href="/posts/3039.html"/>
      <url>/posts/3039.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.cdn.cheneyblog.com/blog/202307291510322.png" alt="关注公众号回复TDSQL认证获取更多资源"></p><ol><li><p>TDSQL(mysql)下列关于主键错误的是().</p><p>A. InnoDB表必须指定主键<br>B. 尽量游免更新主键字段<br>C. 如果存在多个唯一健，考虑最常用的唯一键作为主键<br>D. 主键值可以为空</p><blockquote><p>D. 主键值不可以为空，是错误的，应该修改为主键值不允许为空。</p><blockquote><p>在TDSQL中，主键是数据库表中的一个特殊字段，它的值必须是唯一的，且不允许为空，用来唯一标识一条记录。因此，选项D是错误的。选项A是正确的，在使用InnoDB存储引擎的表中，必须指定主键。选项B是正确的，尽量避免对主键字段进行更新操作，以减少索引维护的成本。选项C是合理的建议，根据最常用的唯一键作为主键可以提高查询效率和数据存储的规范性。</p></blockquote></blockquote></li><li><p>在mysql 中innodb引擎表T1，执行update t1 set a=2 where id =1；语句，id列有索引，下面描述正确的是（）.<br>A. 加表锁<br>B. 不加锁<br>C. 加行锁<br>D. 加字段锁</p><blockquote><p>C. 加行锁。</p><blockquote><p>在MySQL中，InnoDB引擎支持行级锁，当执行类似 <code>update t1 set a=2 where id =1</code> 的语句时，根据id列的索引，InnoDB引擎会为该行加上行锁。行锁是最细粒度的锁，只会锁定执行语句中涉及到的行，而不是整张表。这样可以避免不必要的锁竞争，提高并发性能。<br>如果涉及到多行数据的更新，InnoDB引擎会根据语句的执行计划，采用不同的锁策略。如果更新的行数少于等于当前隔离级别下的自增长值，那么会采用行锁；否则会采用表锁，避免出现死锁和性能下降的问题。因此，在具体的开发中需要根据实际情况进行测试和优化。</p></blockquote></blockquote></li><li><p>负责mysqld 进程存活检查并进行拉起的进程是（）.<br>A. Oc agent<br>B. Scheduer.<br>C. manager<br>D. hdfs</p><blockquote><p>B. Scheduler。</p><blockquote><p>MySQL是一个长时间运行的进程，如果因为某种原因意外退出，需要及时拉起，以保证服务的可用性。在腾讯云数据库TDSQL中，负责mysqld进程存活检查并进行拉起的进程是Scheduler。Scheduler是TDSQL的一个重要组件，它负责管理MySQL实例的启动、停止、重启、配置变更等操作，并通过监控Agent对MySQL进程进行存活检查，一旦发现MySQL进程异常退出，就会及时拉起，以保证服务的高可用性和可靠性。选项A的Oc agent是腾讯云的一种云原生容器服务，用于应用的容器化部署；选项C的manager和选项D的hdfs都与MySQL进程的运行管理没有直接的联系。</p></blockquote></blockquote></li><li><p>使用mysql客户端透传登方式录后，可以查看库中有哪些表是分表的语句是（）.<br>A. <code>/*proxy*/show table with shardkey;</code><br>B. <code>show shardkey tables;</code><br>C. <code>/*proxy*/show tables;</code><br>D. <code>/*proxy*/show shardkey tables;</code></p><blockquote><p>A. <code>/*proxy*/show table with shardkey;</code></p><blockquote><p>当使用MySQL客户端透传登方式登录到腾讯云数据库TDSQL分布式实例时，需要在SQL语句前加上注释<code>/*proxy*/</code>，以便将该SQL语句透传到分片节点执行。查看分表信息的语句是<code>show table with shardkey;</code>，加上透传登注释后即为<code>/*proxy*/show table with shardkey;</code>。该语句将返回数据库中所有分表的信息，包括表名、鉴别键类型、分表数量及分表的节点信息等。选项B和D的语法有误；选项C返回了所有表的信息，而不是分表的信息。</p></blockquote></blockquote></li><li><p>TDSQL 修改字段类型命令正确的是（）.<br>A. alter table t1 alter e varchar(20);<br>B. alter table t1 modify e varchar(30);<br>C. alter table t1.e modify varchar(30);<br>D. alter table t1.e alter varchar(30);</p><blockquote><p>B. alter table t1 modify e varchar(30);</p><blockquote><p>在腾讯云数据库TDSQL中，要修改表字段的数据类型，可以使用ALTER TABLE语句。正确的语法是<code>alter table 表名 modify 字段名 字段类型</code>，即选项B。该语句将修改t1表中e字段的类型为varchar(30)。选项A的语法错误，缺少modify关键字；选项C语法错误，应该为<code>alter table t1 modify e varchar(30)</code>；选项D的语法错误，应该为<code>alter table t1 modify e varchar(30)</code>。</p></blockquote></blockquote></li><li><p>使用mysql客户端登录TDSQL时，加哪个参数可以使用透传功能?<br>A. -a<br>B. -b<br>C. -c<br>D. -d</p><blockquote><p>C. <code>-c</code></p><blockquote><p>在使用MySQL客户端登录腾讯云数据库TDSQL时，如果要使用透传功能，需要在登录命令中添加<code>-c</code>参数。使用该参数后，在SQL语句中添加<code>/*proxy*/</code>注释，即可将该SQL语句透传给后端节点执行。例如，使用以下命令登录MySQL客户端，可以开启透传功能：<code>mysql -h hostname -u user -p -P port -c</code><br>其中，<code>hostname</code>是TDSQL实例的内网地址，<code>user</code>是数据库用户名，<code>port</code>是数据库端口，添加了<code>-c</code>参数后，就可以在SQL语句前添加<code>/*proxy*/</code>注释，实现透传功能。</p></blockquote></blockquote></li><li><p>当检测到死锁时，TDSQL InnoDB 存储引擎如何处理它们?<br>A. 两个受影响的事务都将回滚。<br>B. 受职响的事务等待inodb lock wait 超时，然后回滚。<br>C. 一个受影响的事务将回滚，另一个允许继续.<br>D. 事务隔离级别决定回滚哪个事务.</p><blockquote><p>C. 一个受影响的事务将回滚，另一个允许继续.</p><blockquote><p>答案解释如下：<br>A. 两个受影响的事务都将回滚<br>这个选项是错误的。当检测到死锁时，TDSQL InnoDB 存储引擎只需要选择一个牺牲者回滚，不需要把所有事务都回滚。回滚所有事务会导致所有事务的更改都被撤销，可能会导致严重的数据一致性问题。<br>B. 受影响的事务等待 InnoDB lock wait 超时，然后回滚<br>这个选项也是错误的。等待 InnoDB lock wait 超时的事务并不知道它是在等待死锁的解决。等待超时后可能会自行回滚事务，但如果其他事务继续增加锁等待，则问题仍将存在。<br>D. 事务隔离级别决定回滚哪个事务<br>这个选项是错误的。事务隔离级别影响并发操作的方式，但不会决定哪个事务应该被回滚。在 TDSQL 中，当 InnoDB 检测到死锁时，根据其自己的规则选择牺牲者回滚事务，而不考虑事务隔离级别。</p></blockquote></blockquote></li><li><p>存在表T1，有a，b，c三个字段，c 字段有普通索引，下面查询可以使用到索引的是（）.<br>A. <code>select * from t1 where b=1 and c=2</code><br>B. <code>select * from t1 where c+1=2</code><br>C. <code>select * from t1 where c like %2</code><br>D. <code>select * from t1 where c!=2</code></p><blockquote><p>A. <code>select * from t1 where b=1 and c=2</code></p><blockquote><p>B. <code>select * from t1 where c+1=2</code><br>这个查询中的 c + 1 表达式不能使用 c 列上的索引，因为这个表达式不是一个普通的列名。MySQL 在查询解析时，无法直接判断 c+1 表达式的结果。如果你想在查询中使用到 c 列上的索引，可以考虑修改查询条件或者采用 MySQL 的可计算列技术来实现。<br>C. <code>select * from t1 where c like %2</code><br>像前面所说的，因为 % 通配符是以 c 列值开头，且在查询计划时无法确定符合条件的数据行，因此不能使用 c 列上的索引。<br>D. <code>select * from t1 where c!=2</code><br>在这个查询中，该条件不能使用 c 列上的普通索引。这是因为对于索引来说，无法直接响应「不等于」操作符。如果你需要使用不等于查询，并且期望内部使用到索引来处理 WHERE 从句，你可以考虑使用覆盖索引或是使用聚簇索引。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）关于强同步策略描述正确的是?<br>A. 主机不等从机应答直接返客户端成功<br>B. 主机等待多数从机应答再返回客户端成功<br>C. 主机等待至少一台从机应答成功后才返回客户端成功<br>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>D. 主机等待所有从机应答成功后才返回客户端成功</p><blockquote><p>强同步策略需要确保每个从机节点都写入成功后，才返回给客户端成功，这就要求所有从机节点都要可用。虽然强同步策略能够提供最高的数据可靠性，但由于要等待所有从机节点写入成功后才能返回客户端成功，所以会增加写入时延，并且在高并发写入场景下可能会出现瓶颈，因此，应根据实际需求选择合适的同步策略。</p></blockquote></blockquote></li><li><p>MysQL查询哪些进程正在执行().<br>A. <code>show process;</code><br>B. <code>show processlist;</code><br>C. <code>list process;</code><br>D. <code>list processe;</code></p><blockquote><p>B. <code>show processlist;</code></p></blockquote></li><li><p>TDSQL（MySQL版）分布式支持哪种类型的表?<br>A. 分表<br>B. 单表<br>C. 广播表<br>D. 以上都支持</p><blockquote><p>D. 以上都支持</p><blockquote><p>A. 分表是指将一个表的数据按照某种方式拆分成多个表，分布到多个节点上。不同的节点上存储同一张表的不同分片，可以水平扩展表的存储和查询性能。TDSQL（MySQL版）支持分片表。<br>B. 单表是指一个库中只有一张表，这种表类型不涉及到分布式问题。任何一种数据库都支持单表。<br>C. 广播表是指将一个表的数据复制到所有的节点中，每个节点都有该表的完整数据。广播表主要用于数据量较小、对查询性能要求较高、且需要高可靠性的场景。TDSQL（MySQL版）同样支持广播表。</p></blockquote></blockquote></li><li><p>查看InnoDB内存参数设置的命今是（）.<br>A. <code>show variables like &quot;innodb%;</code><br>B. <code>show parameter like &quot;innodb%;</code><br>C. <code>list variables like &quot;innodb%;</code><br>D. <code>list parameter like inodb%;</code></p><blockquote><p>A. <code>show variables like &quot;innodb%;</code></p></blockquote></li><li><p>关于mysql 主从同步中Slave_IO_Running线程描述不正确的是.<br>A. 可以判断I/O线程是否被启动，并成功地连接到主服务器上。<br>B. 备库回放relay log的线程<br>C. 存在备库上面的线程<br>D. 接收到主库binlog 并写入中继日志的线程</p><blockquote><p>B. 备库回放relay log的线程</p><blockquote><p>备库回放 relay log 的线程是 Slave SQL Running 线程完成的。Slave SQL Running 线程是负责执行中继日志中的事件，将这些事件应用到备库上的线程，因此 B 选项描述是错误的。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）的路由信息是保存在哪里的?<br>A. 数据库中<br>B. Scheduler<br>C. Zookeper<br>D. oss</p><blockquote><p>C. Zookeper</p><blockquote><p>ZooKeeper 是一个分布式的、开放源代码的分布式应用程序协调服务，它是 TDSQL（MySQL版）中的重要组件，用于保存和管理集群中的元数据信息和路由信息，包括数据库实例的地址、分片和拆分等信息。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL版）分布式实例中哪些表只存在第一个set上?<br>A. 单表<br>B. 分表<br>C. 广播表<br>D. 所有表</p><blockquote><p>A. 单表</p></blockquote></li><li><p>TDSQL中自增字段描述正确的是（）.<br>A. TDSQL只保证在单个分片内部递增<br>B. TDSQL 可以保证在全局递增，但不是单调递增<br>C. TDSQL不支持自增字段<br>D. TDSQL 可以保证在全局严格单调递增</p><blockquote><p>B. TDSQL 可以保证在全局递增，但不是单调递增</p><blockquote><p>自增字段是一种在插入记录时自动递增的字段。在 TDSQL 中，自增字段可以使用 AUTO_INCREMENT 关键字来定义。当插入记录时，TDSQL 会为自增字段赋一个新值，以便保证每条记录都有唯一的值。<br>在 TDSQL 中，自增字段的递增方式取决于表的分片设置。如果表被水平分片到多个节点上，那么自增字段的递增方式可能是局部递增的，也就是说，在每个节点上自增字段的值都是递增的，但是不同节点上的自增字段值可能会重复。如果表没有被分片或者只被分片到一个节点上，那么自增字段的递增方式将是全局递增的。<br>需要注意的是，在 TDSQL 中，自增字段的递增方式并不一定是单调递增的。这是因为在分片环境下，不同节点上自增字段的值可能会有交错。然而，TDSQL 会保证自增字段在全局上是递增的，也就是说，每个自增字段的值都比之前插入的记录的自增字段的值大。</p></blockquote></blockquote></li><li><p>关于TDSQL 广播表说法正确的是（）?<br>A. 广播表可以将表数据均匀拆分到各个set<br>B. 广播表一般适合数据量较大的表<br>C. 广播表适合用于频繁更新的表<br>D. 广播表适用于更新较少的小表</p><blockquote><p>D. 广播表适用于更新较少的小表</p><blockquote><p>TDSQL 的广播表是将一个表完全复制到集群的所有 Set 上。数据拷贝是在数据变更时同步进行的，因此对数据的读写操作在所有 Set 上都是相同的。由于广播表在所有 Set 上都有完整副本，所以广播表能够提供非常高的查询性能，对于 join、group by 等操作尤为显著。<br>由于广播表拷贝的是完整的数据，所以其适用场景是数据量较小、更新较少的表，如一些配置表、元数据表等。这些表通常不会有太多的数据变动，可以在集群启动时快速拷贝所有数据，然后在之后的运行中进行读取操作。</p></blockquote></blockquote></li><li><p>查看MySQL服务进程是存在?<br>A. ps -ef|grep 端口号<br>B. fs -ef|grep 端口号<br>C. ns-ef|grep 端口号<br>D. ys-ef|grep 端口号</p><blockquote><p>A. ps -ef|grep 端口号</p><blockquote><p>ps命令可以列出当前所有进程的信息，包括进程ID（PID）、进程状态、运行时间等信息。通过grep命令可以过滤出包含指定端口号的进程。因此，在Linux或Unix系统中，可以通过ps -ef|grep 端口号命令来查看MySQL服务进程是否存在。</p></blockquote></blockquote></li><li><p>TDSQL（MySQL)中主备数据一致性检查的工具是？<br>A. pt-online-schema-change<br>B. pt-pmp<br>C. pt-table-checksum<br>D. pt-mysql-summary</p><blockquote><p>C. pt-table-checksum</p><blockquote><p>pt-table-checksum是Percona Toolkit中的一个工具，可以检查MySQL主库和从库之间的数据一致性。它通过对比主库和从库的数据行数、校验和等信息，来确定两个库之间是否存在数据不一致的情况。如果发现不一致，就可以通过其他工具（例如pt-table-sync）来修复数据。因此，pt-table-checksum对于保证TDSQL（MySQL）主从数据一致性非常有用。</p></blockquote></blockquote></li><li><p>下面哪个命令可以通过透传的方式查看tdsql 集群的消息（）.<br>A. <code>show status;</code><br>B. <code>/*proxy*/show status</code><br>C. <code>/*proxy*/cluster status;</code><br>D. <code>/*cluster*/show status;</code></p><blockquote><p>B. <code>/*proxy*/show status</code></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> TDSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TDSQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java开发学习路线</title>
      <link href="/posts/11880.html"/>
      <url>/posts/11880.html</url>
      
        <content type="html"><![CDATA[<p>今天，我们将为大家分享自学Java开发的学习路线，助力您步入编程的精彩世界。无论您是对编程感兴趣的新手，还是希望升级自己技能的开发者，本文将为您提供一份简明扼要的指南。让我们一起探索自学Java开发的学习之旅吧！</p><h2 id="掌握Java基础知识"><a href="#掌握Java基础知识" class="headerlink" title="掌握Java基础知识"></a>掌握Java基础知识</h2><p>Java是一门广泛应用的编程语言，熟练掌握其基础知识是成为合格Java开发者的第一步。以下是您应该着重学习的内容：</p><ol><li><p>语法基础：了解Java的关键词、数据类型、变量、运算符、流程控制等基本语法。</p></li><li><p>面向对象编程（OOP）：掌握类、对象、继承、多态、封装等OOP的核心概念。</p></li><li><p>Java集合框架：学习常用的集合类如List、Set、Map等，掌握它们的用法和特性。</p></li><li><p>异常处理：了解异常的概念、处理机制和异常处理的最佳实践。</p></li></ol><h2 id="深入学习Java核心技术"><a href="#深入学习Java核心技术" class="headerlink" title="深入学习Java核心技术"></a>深入学习Java核心技术</h2><p>除了基础知识外，了解Java核心技术将帮助您更全面地应用和理解Java开发。以下是您应该关注的主题：</p><ol><li><p>IO操作和文件处理：学习Java中的输入输出操作，包括文件读写、流操作、序列化等。</p></li><li><p>多线程编程：掌握多线程的概念、线程同步、锁机制等，以提高程序的并发性能。</p></li><li><p>网络编程：了解Socket编程、HTTP协议等，为构建网络应用打下基础。</p></li><li><p>数据库操作：学习Java与数据库的交互，掌握SQL语句的编写和数据库连接的使用方式。</p></li></ol><h2 id="构建Web应用"><a href="#构建Web应用" class="headerlink" title="构建Web应用"></a>构建Web应用</h2><p>Web开发是Java的一个重要应用领域。学习相关技术将带给您更广阔的发展前景。以下是您需要学习的内容：</p><ol><li><p>Servlet和JSP：了解Servlet的原理和用法，学习JSP的页面开发和动态内容生成。</p></li><li><p>Web框架：研究主流的Java Web框架，如Spring MVC、Struts等，掌握它们的工作原理和使用方式。</p></li><li><p>前端技术：学习HTML、CSS、JavaScript等前端技术，使您能够构建漂亮的用户界面。</p></li><li><p>数据库框架：掌握数据库框架，如Hibernate、MyBatis等，简化与数据库的交互操作。</p></li></ol><h2 id="提升开发效率"><a href="#提升开发效率" class="headerlink" title="提升开发效率"></a>提升开发效率</h2><p>成为一名高效的Java开发者，除了掌握核心技术外，还需要掌握一些工具和技巧：</p><ol><li><p>开发工具：熟练使用开发工具，例如Eclipse、IntelliJ IDEA等。熟悉调试技巧和代码重构。</p></li><li><p>版本控制：学习使用Git等版本控制工具，管理代码的版本和团队协作。</p></li><li><p>构建工具：了解Maven或Gradle等构建工具的使用，自动化依赖管理和项目构建。</p></li><li><p>测试与调试：学习单元测试和集成测试的方法，进行代码调试和性能优化。</p></li></ol><h2 id="实践与项目"><a href="#实践与项目" class="headerlink" title="实践与项目"></a>实践与项目</h2><p>在学习过程中，通过实践项目来应用所学知识是非常重要的。以下是一些建议：</p><ol><li><p>自主开发小项目：尝试独立完成一个小型项目，如个人博客、待办事项管理系统等，锻炼实际应用能力。</p></li><li><p>参与开源项目：加入开源社区，学习借鉴他人的经验，并为项目贡献自己的代码。</p></li><li><p>进行代码审查：与其他开发者交流，互相审查和改进代码，提高质量和可维护性。</p></li></ol><h2 id="持续学习和保持激情"><a href="#持续学习和保持激情" class="headerlink" title="持续学习和保持激情"></a>持续学习和保持激情</h2><p>Java发展日新月异，作为一名Java开发者，需要跟上技术的脚步。以下是一些持续学习的建议：</p><ol><li><p>阅读技术博客和书籍：关注Java技术的最新动态，通过阅读优秀的技术博客和书籍来不断学习。</p></li><li><p>参加技术交流活动：参加技术研讨会、开发者大会等活动，与其他开发者进行交流和分享经验。</p></li><li><p>学习新的技术领域：探索其他相关技术领域，如云计算、人工智能等，丰富自己的技能树。</p></li></ol><p>无论您的目标是在职场中找到更好的机会，还是追求个人技术成长，自学Java开发是一条值得追求的道路。相信通过持续的努力和实践，您将逐渐成为一名优秀的Java开发者。祝您在学习Java开发的旅程中取得成功！</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo操作手册</title>
      <link href="/posts/34671.html"/>
      <url>/posts/34671.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h2><ul><li><p>Hexo官网：<a href="https://hexo.io/zh-cn/">Hexo</a></p></li><li><p>Hexo是一款基于Node.js的静态网站生成器，可用于快速搭建个人博客或静态网站。</p></li></ul><h2 id="安装前配置"><a href="#安装前配置" class="headerlink" title="安装前配置"></a>安装前配置</h2><ol><li><p>Node.js</p><p>Hexo是基于Node.js开发的，因此需要先安装Node.js。</p><p>Node.js官方：<a href="https://nodejs.org/en">Node.js (nodejs.org)</a></p><p>Windows安装Node.js教程</p><iframe src="//player.bilibili.com/player.html?aid=412728509&bvid=BV11V411o7Zh&cid=177010975&page=1" width="100%" height="500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li><li><p>Git</p><p>如果您想使用Hexo主题或插件，可能需要使用Git进行下载和管理。</p><p>Git官网：<a href="https://git-scm.com/">Git (git-scm.com)</a></p><p>Windows安装Git教程</p><iframe src="//player.bilibili.com/player.html?aid=426532004&bvid=BV133411A7zU&cid=721246198&page=1" weight = 100% height = "500" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></li></ol><h2 id="操作手册"><a href="#操作手册" class="headerlink" title="操作手册"></a>操作手册</h2><ol><li><p>打开命令行，使用npm安装Hexo<br><code>npm install hexo-cli -g</code></p></li><li><p>初始化Hexo<br>进入需要存放博客的目录，然后右键选择Git Bash Here</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo init HenryCheney</span><br><span class="line"><span class="built_in">cd</span> HenryCheney</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><p>博客目录：G:\blog\HenryCheney</p></li><li><p>配置Hexo</p><p>进入博客目录，修改<code>_config.yml</code>文件以配置Hexo。在该文件中，你可以设置博客标题、描述、作者信息、主题、链接等内容。<br><img src="https://www.cdn.cheneyblog.com/blog/202307291429384.png" alt="博客配置"></p></li><li><p>编写文章<br><code>hexo new &quot;My New Post&quot;</code><br>新创建一个名为My New Post的文章存放在G:\blog\HenryCheney\source\_posts目录下</p></li><li><p>生成静态文件<br><code>hexo generate</code><br>简写：<code>hexo g</code></p></li><li><p>预览网站</p><p><code>hexo server</code><br>简写：<code>hexo s</code><br>然后在浏览器中访问<code>http://localhost:4000</code>，就可以访问到自己的博客了。</p></li><li><p>网站推送到GitHub<br>A. 首先安装hexo-deployer-git<br>   <code>npm install hexo-deployer-git --save</code><br>B. 修改 _config.yml 文件</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line"><span class="built_in">type</span>: git</span><br><span class="line">repository: git@github.com <span class="comment"># 仓库地址</span></span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p>C. 部署项目到GitHub</p>   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li></ol><h2 id="命令详解"><a href="#命令详解" class="headerlink" title="命令详解"></a>命令详解</h2><ul><li><p><code>hexo init [folder]</code><br> 初始化一个本地文件夹为网站的根目录<br> 如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p></li><li><p><code>hexo new [layout] &lt;title&gt;</code><br> 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。</p></li><li><p><code>hexo generate</code><br> 生成静态文件。<br> 该命令可以简写为<code>hexo g</code></p></li><li><p><code>hexo publish [layout] &lt;filename&gt;</code><br> 发表草稿。</p></li><li><p><code>hexo server</code><br> 启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/">http://localhost:4000/</a><br> 简写：hexo s</p></li><li><p><code>hexo deploy</code><br> 部署网站<br> 简写：hexo d</p></li><li><p><code>hexo clean</code><br> 清除缓存文件 (db.json) 和已生成的静态文件 (public)<br> 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
